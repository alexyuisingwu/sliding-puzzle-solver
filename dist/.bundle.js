/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/script.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/cropperjs/dist/cropper.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/cropperjs/dist/cropper.min.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../css-loader!./cropper.min.css */ \"./node_modules/css-loader/index.js!./node_modules/cropperjs/dist/cropper.min.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5taW4uY3NzPzgxM2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw2SEFBK0M7O0FBRXJFLDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RkFBc0M7O0FBRTNEOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nyb3BwZXJqcy9kaXN0L2Nyb3BwZXIubWluLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY3JvcHBlci5taW4uY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jcm9wcGVyLm1pbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY3JvcHBlci5taW4uY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cropperjs/dist/cropper.min.css\n");

/***/ }),

/***/ "./node_modules/cropperjs/dist/cropper.min.js":
/*!****************************************************!*\
  !*** ./node_modules/cropperjs/dist/cropper.min.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Cropper.js v1.4.1\n * https://fengyuanchen.github.io/cropperjs\n *\n * Copyright 2015-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2018-07-15T09:55:31.170Z\n */\n!function(t,i){ true?module.exports=i():undefined}(this,function(){\"use strict\";var n=\"undefined\"!=typeof window,h=n?window:{},d=\"cropper\",k=\"all\",E=\"crop\",T=\"move\",W=\"zoom\",N=\"e\",H=\"w\",L=\"s\",O=\"n\",z=\"ne\",Y=\"nw\",X=\"se\",R=\"sw\",r=d+\"-crop\",t=d+\"-disabled\",S=d+\"-hidden\",l=d+\"-hide\",o=d+\"-modal\",p=d+\"-move\",m=d+\"Action\",g=d+\"Preview\",s=\"crop\",c=\"move\",u=\"none\",a=\"crop\",f=\"cropend\",v=\"cropmove\",w=\"cropstart\",x=\"dblclick\",b=h.PointerEvent?\"pointerdown\":\"touchstart mousedown\",y=h.PointerEvent?\"pointermove\":\"touchmove mousemove\",M=h.PointerEvent?\"pointerup pointercancel\":\"touchend touchcancel mouseup\",C=\"ready\",D=\"resize\",B=\"wheel mousewheel DOMMouseScroll\",A=\"zoom\",I=/^(?:e|w|s|n|se|sw|ne|nw|all|crop|move|zoom)$/,U=/^data:/,j=/^data:image\\/jpeg;base64,/,P=/^(?:img|canvas)$/i,q={viewMode:0,dragMode:s,initialAspectRatio:NaN,aspectRatio:NaN,data:null,preview:\"\",responsive:!0,restore:!0,checkCrossOrigin:!0,checkOrientation:!0,modal:!0,guides:!0,center:!0,highlight:!0,background:!0,autoCrop:!0,autoCropArea:.8,movable:!0,rotatable:!0,scalable:!0,zoomable:!0,zoomOnTouch:!0,zoomOnWheel:!0,wheelZoomRatio:.1,cropBoxMovable:!0,cropBoxResizable:!0,toggleDragModeOnDblclick:!0,minCanvasWidth:0,minCanvasHeight:0,minCropBoxWidth:0,minCropBoxHeight:0,minContainerWidth:200,minContainerHeight:100,ready:null,cropstart:null,cropmove:null,cropend:null,crop:null,zoom:null},i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},$=function(){function a(t,i){for(var e=0;e<i.length;e++){var a=i[e];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(t,a.key,a)}}return function(t,i,e){return i&&a(t.prototype,i),e&&a(t,e),t}}(),xt=function(t){if(Array.isArray(t)){for(var i=0,e=Array(t.length);i<t.length;i++)e[i]=t[i];return e}return Array.from(t)},e=Number.isNaN||h.isNaN;function Q(t){return\"number\"==typeof t&&!e(t)}function Z(t){return void 0===t}function F(t){return\"object\"===(void 0===t?\"undefined\":i(t))&&null!==t}var K=Object.prototype.hasOwnProperty;function V(t){if(!F(t))return!1;try{var i=t.constructor,e=i.prototype;return i&&e&&K.call(e,\"isPrototypeOf\")}catch(t){return!1}}function G(t){return\"function\"==typeof t}function J(i,e){if(i&&G(e))if(Array.isArray(i)||Q(i.length)){var t=i.length,a=void 0;for(a=0;a<t&&!1!==e.call(i,i[a],a,i);a+=1);}else F(i)&&Object.keys(i).forEach(function(t){e.call(i,i[t],t,i)});return i}var _=Object.assign||function(e){for(var t=arguments.length,i=Array(1<t?t-1:0),a=1;a<t;a++)i[a-1]=arguments[a];return F(e)&&0<i.length&&i.forEach(function(i){F(i)&&Object.keys(i).forEach(function(t){e[t]=i[t]})}),e},tt=/\\.\\d*(?:0|9){12}\\d*$/i;function bt(t){var i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1e11;return tt.test(t)?Math.round(t*i)/i:t}var it=/^(?:width|height|left|top|marginLeft|marginTop)$/;function et(t,i){var e=t.style;J(i,function(t,i){it.test(i)&&Q(t)&&(t+=\"px\"),e[i]=t})}function at(t,i){if(i)if(Q(t.length))J(t,function(t){at(t,i)});else if(t.classList)t.classList.add(i);else{var e=t.className.trim();e?e.indexOf(i)<0&&(t.className=e+\" \"+i):t.className=i}}function nt(t,i){i&&(Q(t.length)?J(t,function(t){nt(t,i)}):t.classList?t.classList.remove(i):0<=t.className.indexOf(i)&&(t.className=t.className.replace(i,\"\")))}function ot(t,i,e){i&&(Q(t.length)?J(t,function(t){ot(t,i,e)}):e?at(t,i):nt(t,i))}var ht=/([a-z\\d])([A-Z])/g;function rt(t){return t.replace(ht,\"$1-$2\").toLowerCase()}function st(t,i){return F(t[i])?t[i]:t.dataset?t.dataset[i]:t.getAttribute(\"data-\"+rt(i))}function ct(t,i,e){F(e)?t[i]=e:t.dataset?t.dataset[i]=e:t.setAttribute(\"data-\"+rt(i),e)}function dt(i,e){if(F(i[e]))try{delete i[e]}catch(t){i[e]=void 0}else if(i.dataset)try{delete i.dataset[e]}catch(t){i.dataset[e]=void 0}else i.removeAttribute(\"data-\"+rt(e))}var lt=/\\s\\s*/,pt=function(){var t=!1;if(n){var i=!1,e=function(){},a=Object.defineProperty({},\"once\",{get:function(){return t=!0,i},set:function(t){i=t}});h.addEventListener(\"test\",e,a),h.removeEventListener(\"test\",e,a)}return t}();function mt(e,t,a){var n=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{},o=a;t.trim().split(lt).forEach(function(t){if(!pt){var i=e.listeners;i&&i[t]&&i[t][a]&&(o=i[t][a],delete i[t][a],0===Object.keys(i[t]).length&&delete i[t],0===Object.keys(i).length&&delete e.listeners)}e.removeEventListener(t,o,n)})}function gt(o,t,h){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{},s=h;t.trim().split(lt).forEach(function(a){if(r.once&&!pt){var t=o.listeners,n=void 0===t?{}:t;s=function(){for(var t=arguments.length,i=Array(t),e=0;e<t;e++)i[e]=arguments[e];delete n[a][h],o.removeEventListener(a,s,r),h.apply(o,i)},n[a]||(n[a]={}),n[a][h]&&o.removeEventListener(a,n[a][h],r),n[a][h]=s,o.listeners=n}o.addEventListener(a,s,r)})}function ut(t,i,e){var a=void 0;return G(Event)&&G(CustomEvent)?a=new CustomEvent(i,{detail:e,bubbles:!0,cancelable:!0}):(a=document.createEvent(\"CustomEvent\")).initCustomEvent(i,!0,!0,e),t.dispatchEvent(a)}function ft(t){var i=t.getBoundingClientRect();return{left:i.left+(window.pageXOffset-document.documentElement.clientLeft),top:i.top+(window.pageYOffset-document.documentElement.clientTop)}}var vt=h.location,wt=/^(https?:)\\/\\/([^:/?#]+):?(\\d*)/i;function yt(t){var i=t.match(wt);return i&&(i[1]!==vt.protocol||i[2]!==vt.hostname||i[3]!==vt.port)}function Mt(t){var i=\"timestamp=\"+(new Date).getTime();return t+(-1===t.indexOf(\"?\")?\"?\":\"&\")+i}function Ct(t){var i=t.rotate,e=t.scaleX,a=t.scaleY,n=t.translateX,o=t.translateY,h=[];Q(n)&&0!==n&&h.push(\"translateX(\"+n+\"px)\"),Q(o)&&0!==o&&h.push(\"translateY(\"+o+\"px)\"),Q(i)&&0!==i&&h.push(\"rotate(\"+i+\"deg)\"),Q(e)&&1!==e&&h.push(\"scaleX(\"+e+\")\"),Q(a)&&1!==a&&h.push(\"scaleY(\"+a+\")\");var r=h.length?h.join(\" \"):\"none\";return{WebkitTransform:r,msTransform:r,transform:r}}function Dt(t,i){var e=t.pageX,a=t.pageY,n={endX:e,endY:a};return i?n:_({startX:e,startY:a},n)}var Bt=Number.isFinite||h.isFinite;function kt(t){var i=t.aspectRatio,e=t.height,a=t.width,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\"contain\",o=function(t){return Bt(t)&&0<t};if(o(a)&&o(e)){var h=e*i;\"contain\"===n&&a<h||\"cover\"===n&&h<a?e=a/i:a=e*i}else o(a)?e=a/i:o(e)&&(a=e*i);return{width:a,height:e}}var Et=String.fromCharCode;var Tt=/^data:.*,/;function Wt(t){var i=new DataView(t),e=void 0,a=void 0,n=void 0,o=void 0;if(255===i.getUint8(0)&&216===i.getUint8(1))for(var h=i.byteLength,r=2;r<h;){if(255===i.getUint8(r)&&225===i.getUint8(r+1)){n=r;break}r+=1}if(n){var s=n+10;if(\"Exif\"===function(t,i,e){var a=\"\",n=void 0;for(e+=i,n=i;n<e;n+=1)a+=Et(t.getUint8(n));return a}(i,n+4,4)){var c=i.getUint16(s);if(((a=18761===c)||19789===c)&&42===i.getUint16(s+2,a)){var d=i.getUint32(s+4,a);8<=d&&(o=s+d)}}}if(o){var l=i.getUint16(o,a),p=void 0,m=void 0;for(m=0;m<l;m+=1)if(p=o+12*m+2,274===i.getUint16(p,a)){p+=8,e=i.getUint16(p,a),i.setUint16(p,1,a);break}}return e}var Nt={render:function(){this.initContainer(),this.initCanvas(),this.initCropBox(),this.renderCanvas(),this.cropped&&this.renderCropBox()},initContainer:function(){var t=this.element,i=this.options,e=this.container,a=this.cropper;at(a,S),nt(t,S);var n={width:Math.max(e.offsetWidth,Number(i.minContainerWidth)||200),height:Math.max(e.offsetHeight,Number(i.minContainerHeight)||100)};et(a,{width:(this.containerData=n).width,height:n.height}),at(t,S),nt(a,S)},initCanvas:function(){var t=this.containerData,i=this.imageData,e=this.options.viewMode,a=Math.abs(i.rotate)%180==90,n=a?i.naturalHeight:i.naturalWidth,o=a?i.naturalWidth:i.naturalHeight,h=n/o,r=t.width,s=t.height;t.height*h>t.width?3===e?r=t.height*h:s=t.width/h:3===e?s=t.width/h:r=t.height*h;var c={aspectRatio:h,naturalWidth:n,naturalHeight:o,width:r,height:s};c.left=(t.width-r)/2,c.top=(t.height-s)/2,c.oldLeft=c.left,c.oldTop=c.top,this.canvasData=c,this.limited=1===e||2===e,this.limitCanvas(!0,!0),this.initialImageData=_({},i),this.initialCanvasData=_({},c)},limitCanvas:function(t,i){var e=this.options,a=this.containerData,n=this.canvasData,o=this.cropBoxData,h=e.viewMode,r=n.aspectRatio,s=this.cropped&&o;if(t){var c=Number(e.minCanvasWidth)||0,d=Number(e.minCanvasHeight)||0;1<h?(c=Math.max(c,a.width),d=Math.max(d,a.height),3===h&&(c<d*r?c=d*r:d=c/r)):0<h&&(c?c=Math.max(c,s?o.width:0):d?d=Math.max(d,s?o.height:0):s&&((c=o.width)<(d=o.height)*r?c=d*r:d=c/r));var l=kt({aspectRatio:r,width:c,height:d});c=l.width,d=l.height,n.minWidth=c,n.minHeight=d,n.maxWidth=1/0,n.maxHeight=1/0}if(i)if((s?0:1)<h){var p=a.width-n.width,m=a.height-n.height;n.minLeft=Math.min(0,p),n.minTop=Math.min(0,m),n.maxLeft=Math.max(0,p),n.maxTop=Math.max(0,m),s&&this.limited&&(n.minLeft=Math.min(o.left,o.left+(o.width-n.width)),n.minTop=Math.min(o.top,o.top+(o.height-n.height)),n.maxLeft=o.left,n.maxTop=o.top,2===h&&(n.width>=a.width&&(n.minLeft=Math.min(0,p),n.maxLeft=Math.max(0,p)),n.height>=a.height&&(n.minTop=Math.min(0,m),n.maxTop=Math.max(0,m))))}else n.minLeft=-n.width,n.minTop=-n.height,n.maxLeft=a.width,n.maxTop=a.height},renderCanvas:function(t,i){var e=this.canvasData,a=this.imageData;if(i){var n=function(t){var i=t.width,e=t.height,a=t.degree;if(90==(a=Math.abs(a)%180))return{width:e,height:i};var n=a%90*Math.PI/180,o=Math.sin(n),h=Math.cos(n),r=i*h+e*o,s=i*o+e*h;return 90<a?{width:s,height:r}:{width:r,height:s}}({width:a.naturalWidth*Math.abs(a.scaleX||1),height:a.naturalHeight*Math.abs(a.scaleY||1),degree:a.rotate||0}),o=n.width,h=n.height,r=e.width*(o/e.naturalWidth),s=e.height*(h/e.naturalHeight);e.left-=(r-e.width)/2,e.top-=(s-e.height)/2,e.width=r,e.height=s,e.aspectRatio=o/h,e.naturalWidth=o,e.naturalHeight=h,this.limitCanvas(!0,!1)}(e.width>e.maxWidth||e.width<e.minWidth)&&(e.left=e.oldLeft),(e.height>e.maxHeight||e.height<e.minHeight)&&(e.top=e.oldTop),e.width=Math.min(Math.max(e.width,e.minWidth),e.maxWidth),e.height=Math.min(Math.max(e.height,e.minHeight),e.maxHeight),this.limitCanvas(!1,!0),e.left=Math.min(Math.max(e.left,e.minLeft),e.maxLeft),e.top=Math.min(Math.max(e.top,e.minTop),e.maxTop),e.oldLeft=e.left,e.oldTop=e.top,et(this.canvas,_({width:e.width,height:e.height},Ct({translateX:e.left,translateY:e.top}))),this.renderImage(t),this.cropped&&this.limited&&this.limitCropBox(!0,!0)},renderImage:function(t){var i=this.canvasData,e=this.imageData,a=e.naturalWidth*(i.width/i.naturalWidth),n=e.naturalHeight*(i.height/i.naturalHeight);_(e,{width:a,height:n,left:(i.width-a)/2,top:(i.height-n)/2}),et(this.image,_({width:e.width,height:e.height},Ct(_({translateX:e.left,translateY:e.top},e)))),t&&this.output()},initCropBox:function(){var t=this.options,i=this.canvasData,e=t.aspectRatio||t.initialAspectRatio,a=Number(t.autoCropArea)||.8,n={width:i.width,height:i.height};e&&(i.height*e>i.width?n.height=n.width/e:n.width=n.height*e),this.cropBoxData=n,this.limitCropBox(!0,!0),n.width=Math.min(Math.max(n.width,n.minWidth),n.maxWidth),n.height=Math.min(Math.max(n.height,n.minHeight),n.maxHeight),n.width=Math.max(n.minWidth,n.width*a),n.height=Math.max(n.minHeight,n.height*a),n.left=i.left+(i.width-n.width)/2,n.top=i.top+(i.height-n.height)/2,n.oldLeft=n.left,n.oldTop=n.top,this.initialCropBoxData=_({},n)},limitCropBox:function(t,i){var e=this.options,a=this.containerData,n=this.canvasData,o=this.cropBoxData,h=this.limited,r=e.aspectRatio;if(t){var s=Number(e.minCropBoxWidth)||0,c=Number(e.minCropBoxHeight)||0,d=h?Math.min(a.width,n.width,n.width+n.left,a.width-n.left):a.width,l=h?Math.min(a.height,n.height,n.height+n.top,a.height-n.top):a.height;s=Math.min(s,a.width),c=Math.min(c,a.height),r&&(s&&c?s<c*r?c=s/r:s=c*r:s?c=s/r:c&&(s=c*r),d<l*r?l=d/r:d=l*r),o.minWidth=Math.min(s,d),o.minHeight=Math.min(c,l),o.maxWidth=d,o.maxHeight=l}i&&(h?(o.minLeft=Math.max(0,n.left),o.minTop=Math.max(0,n.top),o.maxLeft=Math.min(a.width,n.left+n.width)-o.width,o.maxTop=Math.min(a.height,n.top+n.height)-o.height):(o.minLeft=0,o.minTop=0,o.maxLeft=a.width-o.width,o.maxTop=a.height-o.height))},renderCropBox:function(){var t=this.options,i=this.containerData,e=this.cropBoxData;(e.width>e.maxWidth||e.width<e.minWidth)&&(e.left=e.oldLeft),(e.height>e.maxHeight||e.height<e.minHeight)&&(e.top=e.oldTop),e.width=Math.min(Math.max(e.width,e.minWidth),e.maxWidth),e.height=Math.min(Math.max(e.height,e.minHeight),e.maxHeight),this.limitCropBox(!1,!0),e.left=Math.min(Math.max(e.left,e.minLeft),e.maxLeft),e.top=Math.min(Math.max(e.top,e.minTop),e.maxTop),e.oldLeft=e.left,e.oldTop=e.top,t.movable&&t.cropBoxMovable&&ct(this.face,m,e.width>=i.width&&e.height>=i.height?T:k),et(this.cropBox,_({width:e.width,height:e.height},Ct({translateX:e.left,translateY:e.top}))),this.cropped&&this.limited&&this.limitCanvas(!0,!0),this.disabled||this.output()},output:function(){this.preview(),ut(this.element,a,this.getData())}},Ht={initPreview:function(){var e=this.crossOrigin,t=this.options.preview,a=e?this.crossOriginUrl:this.url,i=document.createElement(\"img\");if(e&&(i.crossOrigin=e),i.src=a,this.viewBox.appendChild(i),this.viewBoxImage=i,t){var n=t;\"string\"==typeof t?n=this.element.ownerDocument.querySelectorAll(t):t.querySelector&&(n=[t]),J(this.previews=n,function(t){var i=document.createElement(\"img\");ct(t,g,{width:t.offsetWidth,height:t.offsetHeight,html:t.innerHTML}),e&&(i.crossOrigin=e),i.src=a,i.style.cssText='display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;\"',t.innerHTML=\"\",t.appendChild(i)})}},resetPreview:function(){J(this.previews,function(t){var i=st(t,g);et(t,{width:i.width,height:i.height}),t.innerHTML=i.html,dt(t,g)})},preview:function(){var r=this.imageData,t=this.canvasData,i=this.cropBoxData,s=i.width,c=i.height,d=r.width,l=r.height,p=i.left-t.left-r.left,m=i.top-t.top-r.top;this.cropped&&!this.disabled&&(et(this.viewBoxImage,_({width:d,height:l},Ct(_({translateX:-p,translateY:-m},r)))),J(this.previews,function(t){var i=st(t,g),e=i.width,a=i.height,n=e,o=a,h=1;s&&(o=c*(h=e/s)),c&&a<o&&(n=s*(h=a/c),o=a),et(t,{width:n,height:o}),et(t.getElementsByTagName(\"img\")[0],_({width:d*h,height:l*h},Ct(_({translateX:-p*h,translateY:-m*h},r))))}))}},Lt={bind:function(){var t=this.element,i=this.options,e=this.cropper;G(i.cropstart)&&gt(t,w,i.cropstart),G(i.cropmove)&&gt(t,v,i.cropmove),G(i.cropend)&&gt(t,f,i.cropend),G(i.crop)&&gt(t,a,i.crop),G(i.zoom)&&gt(t,A,i.zoom),gt(e,b,this.onCropStart=this.cropStart.bind(this)),i.zoomable&&i.zoomOnWheel&&gt(e,B,this.onWheel=this.wheel.bind(this)),i.toggleDragModeOnDblclick&&gt(e,x,this.onDblclick=this.dblclick.bind(this)),gt(t.ownerDocument,y,this.onCropMove=this.cropMove.bind(this)),gt(t.ownerDocument,M,this.onCropEnd=this.cropEnd.bind(this)),i.responsive&&gt(window,D,this.onResize=this.resize.bind(this))},unbind:function(){var t=this.element,i=this.options,e=this.cropper;G(i.cropstart)&&mt(t,w,i.cropstart),G(i.cropmove)&&mt(t,v,i.cropmove),G(i.cropend)&&mt(t,f,i.cropend),G(i.crop)&&mt(t,a,i.crop),G(i.zoom)&&mt(t,A,i.zoom),mt(e,b,this.onCropStart),i.zoomable&&i.zoomOnWheel&&mt(e,B,this.onWheel),i.toggleDragModeOnDblclick&&mt(e,x,this.onDblclick),mt(t.ownerDocument,y,this.onCropMove),mt(t.ownerDocument,M,this.onCropEnd),i.responsive&&mt(window,D,this.onResize)}},Ot={resize:function(){var t=this.options,i=this.container,e=this.containerData,a=Number(t.minContainerWidth)||200,n=Number(t.minContainerHeight)||100;if(!(this.disabled||e.width<=a||e.height<=n)){var o=i.offsetWidth/e.width;if(1!==o||i.offsetHeight!==e.height){var h=void 0,r=void 0;t.restore&&(h=this.getCanvasData(),r=this.getCropBoxData()),this.render(),t.restore&&(this.setCanvasData(J(h,function(t,i){h[i]=t*o})),this.setCropBoxData(J(r,function(t,i){r[i]=t*o})))}}},dblclick:function(){var t,i;this.disabled||this.options.dragMode===u||this.setDragMode((t=this.dragBox,i=r,(t.classList?t.classList.contains(i):-1<t.className.indexOf(i))?c:s))},wheel:function(t){var i=this,e=Number(this.options.wheelZoomRatio)||.1,a=1;this.disabled||(t.preventDefault(),this.wheeling||(this.wheeling=!0,setTimeout(function(){i.wheeling=!1},50),t.deltaY?a=0<t.deltaY?1:-1:t.wheelDelta?a=-t.wheelDelta/120:t.detail&&(a=0<t.detail?1:-1),this.zoom(-a*e,t)))},cropStart:function(t){if(!this.disabled){var i=this.options,e=this.pointers,a=void 0;t.changedTouches?J(t.changedTouches,function(t){e[t.identifier]=Dt(t)}):e[t.pointerId||0]=Dt(t),a=1<Object.keys(e).length&&i.zoomable&&i.zoomOnTouch?W:st(t.target,m),I.test(a)&&!1!==ut(this.element,w,{originalEvent:t,action:a})&&(t.preventDefault(),this.action=a,this.cropping=!1,a===E&&(this.cropping=!0,at(this.dragBox,o)))}},cropMove:function(t){var i=this.action;if(!this.disabled&&i){var e=this.pointers;t.preventDefault(),!1!==ut(this.element,v,{originalEvent:t,action:i})&&(t.changedTouches?J(t.changedTouches,function(t){_(e[t.identifier],Dt(t,!0))}):_(e[t.pointerId||0],Dt(t,!0)),this.change(t))}},cropEnd:function(t){if(!this.disabled){var i=this.action,e=this.pointers;t.changedTouches?J(t.changedTouches,function(t){delete e[t.identifier]}):delete e[t.pointerId||0],i&&(t.preventDefault(),Object.keys(e).length||(this.action=\"\"),this.cropping&&(this.cropping=!1,ot(this.dragBox,o,this.cropped&&this.options.modal)),ut(this.element,f,{originalEvent:t,action:i}))}}},zt={change:function(t){var i=this.options,e=this.canvasData,a=this.containerData,n=this.cropBoxData,o=this.pointers,h=this.action,r=i.aspectRatio,s=n.left,c=n.top,d=n.width,l=n.height,p=s+d,m=c+l,g=0,u=0,f=a.width,v=a.height,w=!0,x=void 0;!r&&t.shiftKey&&(r=d&&l?d/l:1),this.limited&&(g=n.minLeft,u=n.minTop,f=g+Math.min(a.width,e.width,e.left+e.width),v=u+Math.min(a.height,e.height,e.top+e.height));var b,y,M,C=o[Object.keys(o)[0]],D={x:C.endX-C.startX,y:C.endY-C.startY},B=function(t){switch(t){case N:p+D.x>f&&(D.x=f-p);break;case H:s+D.x<g&&(D.x=g-s);break;case O:c+D.y<u&&(D.y=u-c);break;case L:m+D.y>v&&(D.y=v-m)}};switch(h){case k:s+=D.x,c+=D.y;break;case N:if(0<=D.x&&(f<=p||r&&(c<=u||v<=m))){w=!1;break}B(N),(d+=D.x)<0&&(h=H,s-=d=-d),r&&(l=d/r,c+=(n.height-l)/2);break;case O:if(D.y<=0&&(c<=u||r&&(s<=g||f<=p))){w=!1;break}B(O),l-=D.y,c+=D.y,l<0&&(h=L,c-=l=-l),r&&(d=l*r,s+=(n.width-d)/2);break;case H:if(D.x<=0&&(s<=g||r&&(c<=u||v<=m))){w=!1;break}B(H),d-=D.x,s+=D.x,d<0&&(h=N,s-=d=-d),r&&(l=d/r,c+=(n.height-l)/2);break;case L:if(0<=D.y&&(v<=m||r&&(s<=g||f<=p))){w=!1;break}B(L),(l+=D.y)<0&&(h=O,c-=l=-l),r&&(d=l*r,s+=(n.width-d)/2);break;case z:if(r){if(D.y<=0&&(c<=u||f<=p)){w=!1;break}B(O),l-=D.y,c+=D.y,d=l*r}else B(O),B(N),0<=D.x?p<f?d+=D.x:D.y<=0&&c<=u&&(w=!1):d+=D.x,D.y<=0?u<c&&(l-=D.y,c+=D.y):(l-=D.y,c+=D.y);d<0&&l<0?(h=R,c-=l=-l,s-=d=-d):d<0?(h=Y,s-=d=-d):l<0&&(h=X,c-=l=-l);break;case Y:if(r){if(D.y<=0&&(c<=u||s<=g)){w=!1;break}B(O),l-=D.y,c+=D.y,d=l*r,s+=n.width-d}else B(O),B(H),D.x<=0?g<s?(d-=D.x,s+=D.x):D.y<=0&&c<=u&&(w=!1):(d-=D.x,s+=D.x),D.y<=0?u<c&&(l-=D.y,c+=D.y):(l-=D.y,c+=D.y);d<0&&l<0?(h=X,c-=l=-l,s-=d=-d):d<0?(h=z,s-=d=-d):l<0&&(h=R,c-=l=-l);break;case R:if(r){if(D.x<=0&&(s<=g||v<=m)){w=!1;break}B(H),d-=D.x,s+=D.x,l=d/r}else B(L),B(H),D.x<=0?g<s?(d-=D.x,s+=D.x):0<=D.y&&v<=m&&(w=!1):(d-=D.x,s+=D.x),0<=D.y?m<v&&(l+=D.y):l+=D.y;d<0&&l<0?(h=z,c-=l=-l,s-=d=-d):d<0?(h=X,s-=d=-d):l<0&&(h=Y,c-=l=-l);break;case X:if(r){if(0<=D.x&&(f<=p||v<=m)){w=!1;break}B(N),l=(d+=D.x)/r}else B(L),B(N),0<=D.x?p<f?d+=D.x:0<=D.y&&v<=m&&(w=!1):d+=D.x,0<=D.y?m<v&&(l+=D.y):l+=D.y;d<0&&l<0?(h=Y,c-=l=-l,s-=d=-d):d<0?(h=R,s-=d=-d):l<0&&(h=z,c-=l=-l);break;case T:this.move(D.x,D.y),w=!1;break;case W:this.zoom((y=_({},b=o),M=[],J(b,function(r,t){delete y[t],J(y,function(t){var i=Math.abs(r.startX-t.startX),e=Math.abs(r.startY-t.startY),a=Math.abs(r.endX-t.endX),n=Math.abs(r.endY-t.endY),o=Math.sqrt(i*i+e*e),h=(Math.sqrt(a*a+n*n)-o)/o;M.push(h)})}),M.sort(function(t,i){return Math.abs(t)<Math.abs(i)}),M[0]),t),w=!1;break;case E:if(!D.x||!D.y){w=!1;break}x=ft(this.cropper),s=C.startX-x.left,c=C.startY-x.top,d=n.minWidth,l=n.minHeight,0<D.x?h=0<D.y?X:z:D.x<0&&(s-=d,h=0<D.y?R:Y),D.y<0&&(c-=l),this.cropped||(nt(this.cropBox,S),this.cropped=!0,this.limited&&this.limitCropBox(!0,!0))}w&&(n.width=d,n.height=l,n.left=s,n.top=c,this.action=h,this.renderCropBox()),J(o,function(t){t.startX=t.endX,t.startY=t.endY})}},Yt={crop:function(){return!this.ready||this.cropped||this.disabled||(this.cropped=!0,this.limitCropBox(!0,!0),this.options.modal&&at(this.dragBox,o),nt(this.cropBox,S),this.setCropBoxData(this.initialCropBoxData)),this},reset:function(){return this.ready&&!this.disabled&&(this.imageData=_({},this.initialImageData),this.canvasData=_({},this.initialCanvasData),this.cropBoxData=_({},this.initialCropBoxData),this.renderCanvas(),this.cropped&&this.renderCropBox()),this},clear:function(){return this.cropped&&!this.disabled&&(_(this.cropBoxData,{left:0,top:0,width:0,height:0}),this.cropped=!1,this.renderCropBox(),this.limitCanvas(!0,!0),this.renderCanvas(),nt(this.dragBox,o),at(this.cropBox,S)),this},replace:function(i){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1];return!this.disabled&&i&&(this.isImg&&(this.element.src=i),t?(this.url=i,this.image.src=i,this.ready&&(this.viewBoxImage.src=i,J(this.previews,function(t){t.getElementsByTagName(\"img\")[0].src=i}))):(this.isImg&&(this.replaced=!0),this.options.data=null,this.uncreate(),this.load(i))),this},enable:function(){return this.ready&&this.disabled&&(this.disabled=!1,nt(this.cropper,t)),this},disable:function(){return this.ready&&!this.disabled&&(this.disabled=!0,at(this.cropper,t)),this},destroy:function(){var t=this.element;return st(t,d)&&(this.isImg&&this.replaced&&(t.src=this.originalUrl),this.uncreate(),dt(t,d)),this},move:function(t){var i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:t,e=this.canvasData,a=e.left,n=e.top;return this.moveTo(Z(t)?t:a+Number(t),Z(i)?i:n+Number(i))},moveTo:function(t){var i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:t,e=this.canvasData,a=!1;return t=Number(t),i=Number(i),this.ready&&!this.disabled&&this.options.movable&&(Q(t)&&(e.left=t,a=!0),Q(i)&&(e.top=i,a=!0),a&&this.renderCanvas(!0)),this},zoom:function(t,i){var e=this.canvasData;return t=(t=Number(t))<0?1/(1-t):1+t,this.zoomTo(e.width*t/e.naturalWidth,null,i)},zoomTo:function(t,i,e){var a,n,o,h=this.options,r=this.canvasData,s=r.width,c=r.height,d=r.naturalWidth,l=r.naturalHeight;if(0<=(t=Number(t))&&this.ready&&!this.disabled&&h.zoomable){var p=d*t,m=l*t;if(!1===ut(this.element,A,{ratio:t,oldRatio:s/d,originalEvent:e}))return this;if(e){var g=this.pointers,u=ft(this.cropper),f=g&&Object.keys(g).length?(o=n=a=0,J(g,function(t){var i=t.startX,e=t.startY;a+=i,n+=e,o+=1}),{pageX:a/=o,pageY:n/=o}):{pageX:e.pageX,pageY:e.pageY};r.left-=(p-s)*((f.pageX-u.left-r.left)/s),r.top-=(m-c)*((f.pageY-u.top-r.top)/c)}else V(i)&&Q(i.x)&&Q(i.y)?(r.left-=(p-s)*((i.x-r.left)/s),r.top-=(m-c)*((i.y-r.top)/c)):(r.left-=(p-s)/2,r.top-=(m-c)/2);r.width=p,r.height=m,this.renderCanvas(!0)}return this},rotate:function(t){return this.rotateTo((this.imageData.rotate||0)+Number(t))},rotateTo:function(t){return Q(t=Number(t))&&this.ready&&!this.disabled&&this.options.rotatable&&(this.imageData.rotate=t%360,this.renderCanvas(!0,!0)),this},scaleX:function(t){var i=this.imageData.scaleY;return this.scale(t,Q(i)?i:1)},scaleY:function(t){var i=this.imageData.scaleX;return this.scale(Q(i)?i:1,t)},scale:function(t){var i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:t,e=this.imageData,a=!1;return t=Number(t),i=Number(i),this.ready&&!this.disabled&&this.options.scalable&&(Q(t)&&(e.scaleX=t,a=!0),Q(i)&&(e.scaleY=i,a=!0),a&&this.renderCanvas(!0,!0)),this},getData:function(){var t=0<arguments.length&&void 0!==arguments[0]&&arguments[0],i=this.options,e=this.imageData,a=this.canvasData,n=this.cropBoxData,o=void 0;if(this.ready&&this.cropped){o={x:n.left-a.left,y:n.top-a.top,width:n.width,height:n.height};var h=e.width/e.naturalWidth;if(J(o,function(t,i){o[i]=t/h}),t){var r=Math.round(o.y+o.height),s=Math.round(o.x+o.width);o.x=Math.round(o.x),o.y=Math.round(o.y),o.width=s-o.x,o.height=r-o.y}}else o={x:0,y:0,width:0,height:0};return i.rotatable&&(o.rotate=e.rotate||0),i.scalable&&(o.scaleX=e.scaleX||1,o.scaleY=e.scaleY||1),o},setData:function(t){var i=this.options,e=this.imageData,a=this.canvasData,n={};if(this.ready&&!this.disabled&&V(t)){var o=!1;i.rotatable&&Q(t.rotate)&&t.rotate!==e.rotate&&(e.rotate=t.rotate,o=!0),i.scalable&&(Q(t.scaleX)&&t.scaleX!==e.scaleX&&(e.scaleX=t.scaleX,o=!0),Q(t.scaleY)&&t.scaleY!==e.scaleY&&(e.scaleY=t.scaleY,o=!0)),o&&this.renderCanvas(!0,!0);var h=e.width/e.naturalWidth;Q(t.x)&&(n.left=t.x*h+a.left),Q(t.y)&&(n.top=t.y*h+a.top),Q(t.width)&&(n.width=t.width*h),Q(t.height)&&(n.height=t.height*h),this.setCropBoxData(n)}return this},getContainerData:function(){return this.ready?_({},this.containerData):{}},getImageData:function(){return this.sized?_({},this.imageData):{}},getCanvasData:function(){var i=this.canvasData,e={};return this.ready&&J([\"left\",\"top\",\"width\",\"height\",\"naturalWidth\",\"naturalHeight\"],function(t){e[t]=i[t]}),e},setCanvasData:function(t){var i=this.canvasData,e=i.aspectRatio;return this.ready&&!this.disabled&&V(t)&&(Q(t.left)&&(i.left=t.left),Q(t.top)&&(i.top=t.top),Q(t.width)?(i.width=t.width,i.height=t.width/e):Q(t.height)&&(i.height=t.height,i.width=t.height*e),this.renderCanvas(!0)),this},getCropBoxData:function(){var t=this.cropBoxData,i=void 0;return this.ready&&this.cropped&&(i={left:t.left,top:t.top,width:t.width,height:t.height}),i||{}},setCropBoxData:function(t){var i=this.cropBoxData,e=this.options.aspectRatio,a=void 0,n=void 0;return this.ready&&this.cropped&&!this.disabled&&V(t)&&(Q(t.left)&&(i.left=t.left),Q(t.top)&&(i.top=t.top),Q(t.width)&&t.width!==i.width&&(a=!0,i.width=t.width),Q(t.height)&&t.height!==i.height&&(n=!0,i.height=t.height),e&&(a?i.height=i.width/e:n&&(i.width=i.height*e)),this.renderCropBox()),this},getCroppedCanvas:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(!this.ready||!window.HTMLCanvasElement)return null;var i,e,a,n,o,h,r,s,c,d,l,p,m,g,u,f,v,w,x,b,y,M,C,D,B,k,E,T,W,N,H,L,O,z,Y,X,R,S,A,I,U,j=this.canvasData,P=(i=this.image,e=this.imageData,a=j,n=t,o=e.aspectRatio,h=e.naturalWidth,r=e.naturalHeight,s=e.rotate,c=void 0===s?0:s,d=e.scaleX,l=void 0===d?1:d,p=e.scaleY,m=void 0===p?1:p,g=a.aspectRatio,u=a.naturalWidth,f=a.naturalHeight,v=n.fillColor,w=void 0===v?\"transparent\":v,x=n.imageSmoothingEnabled,b=void 0===x||x,y=n.imageSmoothingQuality,M=void 0===y?\"low\":y,C=n.maxWidth,D=void 0===C?1/0:C,B=n.maxHeight,k=void 0===B?1/0:B,E=n.minWidth,T=void 0===E?0:E,W=n.minHeight,N=void 0===W?0:W,H=document.createElement(\"canvas\"),L=H.getContext(\"2d\"),O=kt({aspectRatio:g,width:D,height:k}),z=kt({aspectRatio:g,width:T,height:N},\"cover\"),Y=Math.min(O.width,Math.max(z.width,u)),X=Math.min(O.height,Math.max(z.height,f)),R=kt({aspectRatio:o,width:D,height:k}),S=kt({aspectRatio:o,width:T,height:N},\"cover\"),A=Math.min(R.width,Math.max(S.width,h)),I=Math.min(R.height,Math.max(S.height,r)),U=[-A/2,-I/2,A,I],H.width=bt(Y),H.height=bt(X),L.fillStyle=w,L.fillRect(0,0,Y,X),L.save(),L.translate(Y/2,X/2),L.rotate(c*Math.PI/180),L.scale(l,m),L.imageSmoothingEnabled=b,L.imageSmoothingQuality=M,L.drawImage.apply(L,[i].concat(xt(U.map(function(t){return Math.floor(bt(t))})))),L.restore(),H);if(!this.cropped)return P;var q=this.getData(),$=q.x,Q=q.y,Z=q.width,F=q.height,K=P.width/Math.floor(j.naturalWidth);1!==K&&($*=K,Q*=K,Z*=K,F*=K);var V=Z/F,G=kt({aspectRatio:V,width:t.maxWidth||1/0,height:t.maxHeight||1/0}),J=kt({aspectRatio:V,width:t.minWidth||0,height:t.minHeight||0},\"cover\"),_=kt({aspectRatio:V,width:t.width||(1!==K?P.width:Z),height:t.height||(1!==K?P.height:F)}),tt=_.width,it=_.height;tt=Math.min(G.width,Math.max(J.width,tt)),it=Math.min(G.height,Math.max(J.height,it));var et=document.createElement(\"canvas\"),at=et.getContext(\"2d\");et.width=bt(tt),et.height=bt(it),at.fillStyle=t.fillColor||\"transparent\",at.fillRect(0,0,tt,it);var nt=t.imageSmoothingEnabled,ot=void 0===nt||nt,ht=t.imageSmoothingQuality;at.imageSmoothingEnabled=ot,ht&&(at.imageSmoothingQuality=ht);var rt=P.width,st=P.height,ct=$,dt=Q,lt=void 0,pt=void 0,mt=void 0,gt=void 0,ut=void 0,ft=void 0;ct<=-Z||rt<ct?ut=mt=lt=ct=0:ct<=0?(mt=-ct,ct=0,ut=lt=Math.min(rt,Z+ct)):ct<=rt&&(mt=0,ut=lt=Math.min(Z,rt-ct)),lt<=0||dt<=-F||st<dt?ft=gt=pt=dt=0:dt<=0?(gt=-dt,dt=0,ft=pt=Math.min(st,F+dt)):dt<=st&&(gt=0,ft=pt=Math.min(F,st-dt));var vt=[ct,dt,lt,pt];if(0<ut&&0<ft){var wt=tt/Z;vt.push(mt*wt,gt*wt,ut*wt,ft*wt)}return at.drawImage.apply(at,[P].concat(xt(vt.map(function(t){return Math.floor(bt(t))})))),et},setAspectRatio:function(t){var i=this.options;return this.disabled||Z(t)||(i.aspectRatio=Math.max(0,t)||NaN,this.ready&&(this.initCropBox(),this.cropped&&this.renderCropBox())),this},setDragMode:function(t){var i=this.options,e=this.dragBox,a=this.face;if(this.ready&&!this.disabled){var n=t===s,o=i.movable&&t===c;t=n||o?t:u,i.dragMode=t,ct(e,m,t),ot(e,r,n),ot(e,p,o),i.cropBoxMovable||(ct(a,m,t),ot(a,r,n),ot(a,p,o))}return this}},Xt=h.Cropper,Rt=function(){function e(t){var i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(function(t,i){if(!(t instanceof i))throw new TypeError(\"Cannot call a class as a function\")}(this,e),!t||!P.test(t.tagName))throw new Error(\"The first argument is required and must be an <img> or <canvas> element.\");this.element=t,this.options=_({},q,V(i)&&i),this.cropped=!1,this.disabled=!1,this.pointers={},this.ready=!1,this.reloading=!1,this.replaced=!1,this.sized=!1,this.sizing=!1,this.init()}return $(e,[{key:\"init\",value:function(){var t=this.element,i=t.tagName.toLowerCase(),e=void 0;if(!st(t,d)){if(ct(t,d,this),\"img\"===i){if(this.isImg=!0,e=t.getAttribute(\"src\")||\"\",!(this.originalUrl=e))return;e=t.src}else\"canvas\"===i&&window.HTMLCanvasElement&&(e=t.toDataURL());this.load(e)}}},{key:\"load\",value:function(t){var i=this;if(t){this.url=t,this.imageData={};var e=this.element,a=this.options;if(a.rotatable||a.scalable||(a.checkOrientation=!1),a.checkOrientation&&window.ArrayBuffer)if(U.test(t))j.test(t)?this.read((n=t.replace(Tt,\"\"),o=atob(n),h=new ArrayBuffer(o.length),J(r=new Uint8Array(h),function(t,i){r[i]=o.charCodeAt(i)}),h)):this.clone();else{var n,o,h,r,s=new XMLHttpRequest;this.reloading=!0,this.xhr=s;var c=function(){i.reloading=!1,i.xhr=null};s.ontimeout=c,s.onabort=c,s.onerror=function(){c(),i.clone()},s.onload=function(){c(),i.read(s.response)},a.checkCrossOrigin&&yt(t)&&e.crossOrigin&&(t=Mt(t)),s.open(\"get\",t),s.responseType=\"arraybuffer\",s.withCredentials=\"use-credentials\"===e.crossOrigin,s.send()}else this.clone()}}},{key:\"read\",value:function(t){var i,e,a,n=this.options,o=this.imageData,h=Wt(t),r=0,s=1,c=1;if(1<h){this.url=(i=\"image/jpeg\",e=new Uint8Array(t),a=\"\",G(e.forEach)?e.forEach(function(t){a+=Et(t)}):J(e,function(t){a+=Et(t)}),\"data:\"+i+\";base64,\"+btoa(a));var d=function(t){var i=0,e=1,a=1;switch(t){case 2:e=-1;break;case 3:i=-180;break;case 4:a=-1;break;case 5:i=90,a=-1;break;case 6:i=90;break;case 7:i=90,e=-1;break;case 8:i=-90}return{rotate:i,scaleX:e,scaleY:a}}(h);r=d.rotate,s=d.scaleX,c=d.scaleY}n.rotatable&&(o.rotate=r),n.scalable&&(o.scaleX=s,o.scaleY=c),this.clone()}},{key:\"clone\",value:function(){var t=this.element,i=this.url,e=void 0,a=void 0;this.options.checkCrossOrigin&&yt(i)&&((e=t.crossOrigin)?a=i:(e=\"anonymous\",a=Mt(i))),this.crossOrigin=e,this.crossOriginUrl=a;var n=document.createElement(\"img\");e&&(n.crossOrigin=e),n.src=a||i,(this.image=n).onload=this.start.bind(this),n.onerror=this.stop.bind(this),at(n,l),t.parentNode.insertBefore(n,t.nextSibling)}},{key:\"start\",value:function(){var e=this,t=this.isImg?this.element:this.image;t.onload=null,t.onerror=null,this.sizing=!0;var i=h.navigator&&/(Macintosh|iPhone|iPod|iPad).*AppleWebKit/i.test(h.navigator.userAgent),a=function(t,i){_(e.imageData,{naturalWidth:t,naturalHeight:i,aspectRatio:t/i}),e.sizing=!1,e.sized=!0,e.build()};if(!t.naturalWidth||i){var n=document.createElement(\"img\"),o=document.body||document.documentElement;(this.sizingImage=n).onload=function(){a(n.width,n.height),i||o.removeChild(n)},n.src=t.src,i||(n.style.cssText=\"left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;\",o.appendChild(n))}else a(t.naturalWidth,t.naturalHeight)}},{key:\"stop\",value:function(){var t=this.image;t.onload=null,t.onerror=null,t.parentNode.removeChild(t),this.image=null}},{key:\"build\",value:function(){if(this.sized&&!this.ready){var t=this.element,i=this.options,e=this.image,a=t.parentNode,n=document.createElement(\"div\");n.innerHTML='<div class=\"cropper-container\" touch-action=\"none\"><div class=\"cropper-wrap-box\"><div class=\"cropper-canvas\"></div></div><div class=\"cropper-drag-box\"></div><div class=\"cropper-crop-box\"><span class=\"cropper-view-box\"></span><span class=\"cropper-dashed dashed-h\"></span><span class=\"cropper-dashed dashed-v\"></span><span class=\"cropper-center\"></span><span class=\"cropper-face\"></span><span class=\"cropper-line line-e\" data-cropper-action=\"e\"></span><span class=\"cropper-line line-n\" data-cropper-action=\"n\"></span><span class=\"cropper-line line-w\" data-cropper-action=\"w\"></span><span class=\"cropper-line line-s\" data-cropper-action=\"s\"></span><span class=\"cropper-point point-e\" data-cropper-action=\"e\"></span><span class=\"cropper-point point-n\" data-cropper-action=\"n\"></span><span class=\"cropper-point point-w\" data-cropper-action=\"w\"></span><span class=\"cropper-point point-s\" data-cropper-action=\"s\"></span><span class=\"cropper-point point-ne\" data-cropper-action=\"ne\"></span><span class=\"cropper-point point-nw\" data-cropper-action=\"nw\"></span><span class=\"cropper-point point-sw\" data-cropper-action=\"sw\"></span><span class=\"cropper-point point-se\" data-cropper-action=\"se\"></span></div></div>';var o=n.querySelector(\".\"+d+\"-container\"),h=o.querySelector(\".\"+d+\"-canvas\"),r=o.querySelector(\".\"+d+\"-drag-box\"),s=o.querySelector(\".\"+d+\"-crop-box\"),c=s.querySelector(\".\"+d+\"-face\");this.container=a,this.cropper=o,this.canvas=h,this.dragBox=r,this.cropBox=s,this.viewBox=o.querySelector(\".\"+d+\"-view-box\"),this.face=c,h.appendChild(e),at(t,S),a.insertBefore(o,t.nextSibling),this.isImg||nt(e,l),this.initPreview(),this.bind(),i.initialAspectRatio=Math.max(0,i.initialAspectRatio)||NaN,i.aspectRatio=Math.max(0,i.aspectRatio)||NaN,i.viewMode=Math.max(0,Math.min(3,Math.round(i.viewMode)))||0,at(s,S),i.guides||at(s.getElementsByClassName(d+\"-dashed\"),S),i.center||at(s.getElementsByClassName(d+\"-center\"),S),i.background&&at(o,d+\"-bg\"),i.highlight||at(c,\"cropper-invisible\"),i.cropBoxMovable&&(at(c,p),ct(c,m,k)),i.cropBoxResizable||(at(s.getElementsByClassName(d+\"-line\"),S),at(s.getElementsByClassName(d+\"-point\"),S)),this.render(),this.ready=!0,this.setDragMode(i.dragMode),i.autoCrop&&this.crop(),this.setData(i.data),G(i.ready)&&gt(t,C,i.ready,{once:!0}),ut(t,C)}}},{key:\"unbuild\",value:function(){this.ready&&(this.ready=!1,this.unbind(),this.resetPreview(),this.cropper.parentNode.removeChild(this.cropper),nt(this.element,S))}},{key:\"uncreate\",value:function(){this.ready?(this.unbuild(),this.ready=!1,this.cropped=!1):this.sizing?(this.sizingImage.onload=null,this.sizing=!1,this.sized=!1):this.reloading?this.xhr.abort():this.image&&this.stop()}}],[{key:\"noConflict\",value:function(){return window.Cropper=Xt,e}},{key:\"setDefaults\",value:function(t){_(q,V(t)&&t)}}]),e}();return _(Rt.prototype,Nt,Ht,Lt,Ot,zt,Yt),Rt});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5taW4uanM/MjA1ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQW9ELG9CQUFvQixTQUE2RCxDQUFDLGlCQUFpQixhQUFhLDhDQUE4Qyw4bUJBQThtQixrQ0FBa0MsdWtCQUF1a0IsMkVBQTJFLGdCQUFnQixhQUFhLG9HQUFvRyxjQUFjLGdCQUFnQixZQUFZLFdBQVcsS0FBSyxXQUFXLCtHQUErRyx1QkFBdUIsd0NBQXdDLGtCQUFrQixxQkFBcUIsOEJBQThCLFdBQVcsY0FBYyxTQUFTLHFCQUFxQix5QkFBeUIsY0FBYyxnQ0FBZ0MsY0FBYyxrQkFBa0IsY0FBYyx5REFBeUQsc0NBQXNDLGNBQWMsa0JBQWtCLElBQUksa0NBQWtDLHVDQUF1QyxTQUFTLFVBQVUsY0FBYywyQkFBMkIsZ0JBQWdCLDZDQUE2Qyx3QkFBd0IsUUFBUSw2QkFBNkIsT0FBTyw4Q0FBOEMsbUJBQW1CLEVBQUUsU0FBUyxpQ0FBaUMsa0RBQWtELElBQUksd0JBQXdCLCtDQUErQyx5Q0FBeUMsVUFBVSxFQUFFLElBQUksa0JBQWtCLEdBQUcsT0FBTyxlQUFlLGtFQUFrRSxzQ0FBc0MsMERBQTBELGlCQUFpQixjQUFjLGtCQUFrQixtQ0FBbUMsRUFBRSxpQkFBaUIsb0NBQW9DLFFBQVEsRUFBRSx1Q0FBdUMsS0FBSyx5QkFBeUIsdURBQXVELGlCQUFpQixnQ0FBZ0MsUUFBUSx3R0FBd0csbUJBQW1CLGdDQUFnQyxVQUFVLHFCQUFxQiwyQkFBMkIsZUFBZSwyQ0FBMkMsaUJBQWlCLHlFQUF5RSxtQkFBbUIscUVBQXFFLGlCQUFpQixlQUFlLFlBQVksU0FBUyxZQUFZLHNCQUFzQixvQkFBb0IsU0FBUyxvQkFBb0Isc0NBQXNDLDZCQUE2QixTQUFTLE1BQU0sdUJBQXVCLDJCQUEyQixTQUFTLGVBQWUs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QStKLG9CQUFvQixFQUFFLDZCQUE2Qiw4REFBOEQsUUFBUSxxRkFBcUYsU0FBUyxrQkFBa0IsU0FBUyxjQUFjLGtCQUFrQixrQkFBa0IsZ0JBQWdCLFVBQVUsWUFBWSxNQUFNLGNBQWMsTUFBTSxZQUFZLE1BQU0saUJBQWlCLE1BQU0sWUFBWSxNQUFNLGlCQUFpQixNQUFNLGFBQWEsT0FBTyw0QkFBNEIsSUFBSSxpQ0FBaUMsNEVBQTRFLEVBQUUsNkJBQTZCLGdEQUFnRCwrSEFBK0gsb0NBQW9DLCtKQUErSixFQUFFLDZCQUE2QixnREFBZ0QsNENBQTRDLDRHQUE0RyxlQUFlLCtDQUErQyxvQ0FBb0MsdUJBQXVCLDhFQUE4RSx1Q0FBdUMsd0NBQXdDLHlDQUF5QywwQkFBMEIseUJBQXlCLHVCQUF1QixzQkFBc0IsVUFBVSxrQkFBa0IsTUFBTSxXQUFXLG9CQUFvQix3Q0FBd0MsRUFBRSw0QkFBNEIsaUJBQWlCLDBFQUEwRSxFQUFFLDZCQUE2Qiw0QkFBNEIsOEZBQThGLGdzQ0FBZ3NDLHdMQUF3TCxtMkJBQW0yQixRQUFRLFlBQVksRUFBRSwrQkFBK0Isb0lBQW9JLEVBQUUsZ0NBQWdDLDJMQUEyTCxJQUFJLGtDQUFrQyw0QkFBNEIsRUFBRSxvQ0FBb0MsY0FBYyxLQUFLLEdBQUcsNENBQTRDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nyb3BwZXJqcy9kaXN0L2Nyb3BwZXIubWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDcm9wcGVyLmpzIHYxLjQuMVxuICogaHR0cHM6Ly9mZW5neXVhbmNoZW4uZ2l0aHViLmlvL2Nyb3BwZXJqc1xuICpcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQgQ2hlbiBGZW5neXVhblxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOC0wNy0xNVQwOTo1NTozMS4xNzBaXG4gKi9cbiFmdW5jdGlvbih0LGkpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWkoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGkpOnQuQ3JvcHBlcj1pKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93LGg9bj93aW5kb3c6e30sZD1cImNyb3BwZXJcIixrPVwiYWxsXCIsRT1cImNyb3BcIixUPVwibW92ZVwiLFc9XCJ6b29tXCIsTj1cImVcIixIPVwid1wiLEw9XCJzXCIsTz1cIm5cIix6PVwibmVcIixZPVwibndcIixYPVwic2VcIixSPVwic3dcIixyPWQrXCItY3JvcFwiLHQ9ZCtcIi1kaXNhYmxlZFwiLFM9ZCtcIi1oaWRkZW5cIixsPWQrXCItaGlkZVwiLG89ZCtcIi1tb2RhbFwiLHA9ZCtcIi1tb3ZlXCIsbT1kK1wiQWN0aW9uXCIsZz1kK1wiUHJldmlld1wiLHM9XCJjcm9wXCIsYz1cIm1vdmVcIix1PVwibm9uZVwiLGE9XCJjcm9wXCIsZj1cImNyb3BlbmRcIix2PVwiY3JvcG1vdmVcIix3PVwiY3JvcHN0YXJ0XCIseD1cImRibGNsaWNrXCIsYj1oLlBvaW50ZXJFdmVudD9cInBvaW50ZXJkb3duXCI6XCJ0b3VjaHN0YXJ0IG1vdXNlZG93blwiLHk9aC5Qb2ludGVyRXZlbnQ/XCJwb2ludGVybW92ZVwiOlwidG91Y2htb3ZlIG1vdXNlbW92ZVwiLE09aC5Qb2ludGVyRXZlbnQ/XCJwb2ludGVydXAgcG9pbnRlcmNhbmNlbFwiOlwidG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cFwiLEM9XCJyZWFkeVwiLEQ9XCJyZXNpemVcIixCPVwid2hlZWwgbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbFwiLEE9XCJ6b29tXCIsST0vXig/OmV8d3xzfG58c2V8c3d8bmV8bnd8YWxsfGNyb3B8bW92ZXx6b29tKSQvLFU9L15kYXRhOi8saj0vXmRhdGE6aW1hZ2VcXC9qcGVnO2Jhc2U2NCwvLFA9L14oPzppbWd8Y2FudmFzKSQvaSxxPXt2aWV3TW9kZTowLGRyYWdNb2RlOnMsaW5pdGlhbEFzcGVjdFJhdGlvOk5hTixhc3BlY3RSYXRpbzpOYU4sZGF0YTpudWxsLHByZXZpZXc6XCJcIixyZXNwb25zaXZlOiEwLHJlc3RvcmU6ITAsY2hlY2tDcm9zc09yaWdpbjohMCxjaGVja09yaWVudGF0aW9uOiEwLG1vZGFsOiEwLGd1aWRlczohMCxjZW50ZXI6ITAsaGlnaGxpZ2h0OiEwLGJhY2tncm91bmQ6ITAsYXV0b0Nyb3A6ITAsYXV0b0Nyb3BBcmVhOi44LG1vdmFibGU6ITAscm90YXRhYmxlOiEwLHNjYWxhYmxlOiEwLHpvb21hYmxlOiEwLHpvb21PblRvdWNoOiEwLHpvb21PbldoZWVsOiEwLHdoZWVsWm9vbVJhdGlvOi4xLGNyb3BCb3hNb3ZhYmxlOiEwLGNyb3BCb3hSZXNpemFibGU6ITAsdG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrOiEwLG1pbkNhbnZhc1dpZHRoOjAsbWluQ2FudmFzSGVpZ2h0OjAsbWluQ3JvcEJveFdpZHRoOjAsbWluQ3JvcEJveEhlaWdodDowLG1pbkNvbnRhaW5lcldpZHRoOjIwMCxtaW5Db250YWluZXJIZWlnaHQ6MTAwLHJlYWR5Om51bGwsY3JvcHN0YXJ0Om51bGwsY3JvcG1vdmU6bnVsbCxjcm9wZW5kOm51bGwsY3JvcDpudWxsLHpvb206bnVsbH0saT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSwkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSh0LGkpe2Zvcih2YXIgZT0wO2U8aS5sZW5ndGg7ZSsrKXt2YXIgYT1pW2VdO2EuZW51bWVyYWJsZT1hLmVudW1lcmFibGV8fCExLGEuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGEmJihhLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxhLmtleSxhKX19cmV0dXJuIGZ1bmN0aW9uKHQsaSxlKXtyZXR1cm4gaSYmYSh0LnByb3RvdHlwZSxpKSxlJiZhKHQsZSksdH19KCkseHQ9ZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSl7Zm9yKHZhciBpPTAsZT1BcnJheSh0Lmxlbmd0aCk7aTx0Lmxlbmd0aDtpKyspZVtpXT10W2ldO3JldHVybiBlfXJldHVybiBBcnJheS5mcm9tKHQpfSxlPU51bWJlci5pc05hTnx8aC5pc05hTjtmdW5jdGlvbiBRKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiYhZSh0KX1mdW5jdGlvbiBaKHQpe3JldHVybiB2b2lkIDA9PT10fWZ1bmN0aW9uIEYodCl7cmV0dXJuXCJvYmplY3RcIj09PSh2b2lkIDA9PT10P1widW5kZWZpbmVkXCI6aSh0KSkmJm51bGwhPT10fXZhciBLPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gVih0KXtpZighRih0KSlyZXR1cm4hMTt0cnl7dmFyIGk9dC5jb25zdHJ1Y3RvcixlPWkucHJvdG90eXBlO3JldHVybiBpJiZlJiZLLmNhbGwoZSxcImlzUHJvdG90eXBlT2ZcIil9Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIEcodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH1mdW5jdGlvbiBKKGksZSl7aWYoaSYmRyhlKSlpZihBcnJheS5pc0FycmF5KGkpfHxRKGkubGVuZ3RoKSl7dmFyIHQ9aS5sZW5ndGgsYT12b2lkIDA7Zm9yKGE9MDthPHQmJiExIT09ZS5jYWxsKGksaVthXSxhLGkpO2ErPTEpO31lbHNlIEYoaSkmJk9iamVjdC5rZXlzKGkpLmZvckVhY2goZnVuY3Rpb24odCl7ZS5jYWxsKGksaVt0XSx0LGkpfSk7cmV0dXJuIGl9dmFyIF89T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsaT1BcnJheSgxPHQ/dC0xOjApLGE9MTthPHQ7YSsrKWlbYS0xXT1hcmd1bWVudHNbYV07cmV0dXJuIEYoZSkmJjA8aS5sZW5ndGgmJmkuZm9yRWFjaChmdW5jdGlvbihpKXtGKGkpJiZPYmplY3Qua2V5cyhpKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2VbdF09aVt0XX0pfSksZX0sdHQ9L1xcLlxcZCooPzowfDkpezEyfVxcZCokL2k7ZnVuY3Rpb24gYnQodCl7dmFyIGk9MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjFlMTE7cmV0dXJuIHR0LnRlc3QodCk/TWF0aC5yb3VuZCh0KmkpL2k6dH12YXIgaXQ9L14oPzp3aWR0aHxoZWlnaHR8bGVmdHx0b3B8bWFyZ2luTGVmdHxtYXJnaW5Ub3ApJC87ZnVuY3Rpb24gZXQodCxpKXt2YXIgZT10LnN0eWxlO0ooaSxmdW5jdGlvbih0LGkpe2l0LnRlc3QoaSkmJlEodCkmJih0Kz1cInB4XCIpLGVbaV09dH0pfWZ1bmN0aW9uIGF0KHQsaSl7aWYoaSlpZihRKHQubGVuZ3RoKSlKKHQsZnVuY3Rpb24odCl7YXQodCxpKX0pO2Vsc2UgaWYodC5jbGFzc0xpc3QpdC5jbGFzc0xpc3QuYWRkKGkpO2Vsc2V7dmFyIGU9dC5jbGFzc05hbWUudHJpbSgpO2U/ZS5pbmRleE9mKGkpPDAmJih0LmNsYXNzTmFtZT1lK1wiIFwiK2kpOnQuY2xhc3NOYW1lPWl9fWZ1bmN0aW9uIG50KHQsaSl7aSYmKFEodC5sZW5ndGgpP0oodCxmdW5jdGlvbih0KXtudCh0LGkpfSk6dC5jbGFzc0xpc3Q/dC5jbGFzc0xpc3QucmVtb3ZlKGkpOjA8PXQuY2xhc3NOYW1lLmluZGV4T2YoaSkmJih0LmNsYXNzTmFtZT10LmNsYXNzTmFtZS5yZXBsYWNlKGksXCJcIikpKX1mdW5jdGlvbiBvdCh0LGksZSl7aSYmKFEodC5sZW5ndGgpP0oodCxmdW5jdGlvbih0KXtvdCh0LGksZSl9KTplP2F0KHQsaSk6bnQodCxpKSl9dmFyIGh0PS8oW2EtelxcZF0pKFtBLVpdKS9nO2Z1bmN0aW9uIHJ0KHQpe3JldHVybiB0LnJlcGxhY2UoaHQsXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIHN0KHQsaSl7cmV0dXJuIEYodFtpXSk/dFtpXTp0LmRhdGFzZXQ/dC5kYXRhc2V0W2ldOnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1cIitydChpKSl9ZnVuY3Rpb24gY3QodCxpLGUpe0YoZSk/dFtpXT1lOnQuZGF0YXNldD90LmRhdGFzZXRbaV09ZTp0LnNldEF0dHJpYnV0ZShcImRhdGEtXCIrcnQoaSksZSl9ZnVuY3Rpb24gZHQoaSxlKXtpZihGKGlbZV0pKXRyeXtkZWxldGUgaVtlXX1jYXRjaCh0KXtpW2VdPXZvaWQgMH1lbHNlIGlmKGkuZGF0YXNldCl0cnl7ZGVsZXRlIGkuZGF0YXNldFtlXX1jYXRjaCh0KXtpLmRhdGFzZXRbZV09dm9pZCAwfWVsc2UgaS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLVwiK3J0KGUpKX12YXIgbHQ9L1xcc1xccyovLHB0PWZ1bmN0aW9uKCl7dmFyIHQ9ITE7aWYobil7dmFyIGk9ITEsZT1mdW5jdGlvbigpe30sYT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJvbmNlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0PSEwLGl9LHNldDpmdW5jdGlvbih0KXtpPXR9fSk7aC5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLGUsYSksaC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLGUsYSl9cmV0dXJuIHR9KCk7ZnVuY3Rpb24gbXQoZSx0LGEpe3ZhciBuPTM8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTp7fSxvPWE7dC50cmltKCkuc3BsaXQobHQpLmZvckVhY2goZnVuY3Rpb24odCl7aWYoIXB0KXt2YXIgaT1lLmxpc3RlbmVycztpJiZpW3RdJiZpW3RdW2FdJiYobz1pW3RdW2FdLGRlbGV0ZSBpW3RdW2FdLDA9PT1PYmplY3Qua2V5cyhpW3RdKS5sZW5ndGgmJmRlbGV0ZSBpW3RdLDA9PT1PYmplY3Qua2V5cyhpKS5sZW5ndGgmJmRlbGV0ZSBlLmxpc3RlbmVycyl9ZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsbyxuKX0pfWZ1bmN0aW9uIGd0KG8sdCxoKXt2YXIgcj0zPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106e30scz1oO3QudHJpbSgpLnNwbGl0KGx0KS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2lmKHIub25jZSYmIXB0KXt2YXIgdD1vLmxpc3RlbmVycyxuPXZvaWQgMD09PXQ/e306dDtzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsaT1BcnJheSh0KSxlPTA7ZTx0O2UrKylpW2VdPWFyZ3VtZW50c1tlXTtkZWxldGUgblthXVtoXSxvLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxzLHIpLGguYXBwbHkobyxpKX0sblthXXx8KG5bYV09e30pLG5bYV1baF0mJm8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLG5bYV1baF0sciksblthXVtoXT1zLG8ubGlzdGVuZXJzPW59by5hZGRFdmVudExpc3RlbmVyKGEscyxyKX0pfWZ1bmN0aW9uIHV0KHQsaSxlKXt2YXIgYT12b2lkIDA7cmV0dXJuIEcoRXZlbnQpJiZHKEN1c3RvbUV2ZW50KT9hPW5ldyBDdXN0b21FdmVudChpLHtkZXRhaWw6ZSxidWJibGVzOiEwLGNhbmNlbGFibGU6ITB9KTooYT1kb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpKS5pbml0Q3VzdG9tRXZlbnQoaSwhMCwhMCxlKSx0LmRpc3BhdGNoRXZlbnQoYSl9ZnVuY3Rpb24gZnQodCl7dmFyIGk9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57bGVmdDppLmxlZnQrKHdpbmRvdy5wYWdlWE9mZnNldC1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50TGVmdCksdG9wOmkudG9wKyh3aW5kb3cucGFnZVlPZmZzZXQtZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFRvcCl9fXZhciB2dD1oLmxvY2F0aW9uLHd0PS9eKGh0dHBzPzopXFwvXFwvKFteOi8/I10rKTo/KFxcZCopL2k7ZnVuY3Rpb24geXQodCl7dmFyIGk9dC5tYXRjaCh3dCk7cmV0dXJuIGkmJihpWzFdIT09dnQucHJvdG9jb2x8fGlbMl0hPT12dC5ob3N0bmFtZXx8aVszXSE9PXZ0LnBvcnQpfWZ1bmN0aW9uIE10KHQpe3ZhciBpPVwidGltZXN0YW1wPVwiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpO3JldHVybiB0KygtMT09PXQuaW5kZXhPZihcIj9cIik/XCI/XCI6XCImXCIpK2l9ZnVuY3Rpb24gQ3QodCl7dmFyIGk9dC5yb3RhdGUsZT10LnNjYWxlWCxhPXQuc2NhbGVZLG49dC50cmFuc2xhdGVYLG89dC50cmFuc2xhdGVZLGg9W107UShuKSYmMCE9PW4mJmgucHVzaChcInRyYW5zbGF0ZVgoXCIrbitcInB4KVwiKSxRKG8pJiYwIT09byYmaC5wdXNoKFwidHJhbnNsYXRlWShcIitvK1wicHgpXCIpLFEoaSkmJjAhPT1pJiZoLnB1c2goXCJyb3RhdGUoXCIraStcImRlZylcIiksUShlKSYmMSE9PWUmJmgucHVzaChcInNjYWxlWChcIitlK1wiKVwiKSxRKGEpJiYxIT09YSYmaC5wdXNoKFwic2NhbGVZKFwiK2ErXCIpXCIpO3ZhciByPWgubGVuZ3RoP2guam9pbihcIiBcIik6XCJub25lXCI7cmV0dXJue1dlYmtpdFRyYW5zZm9ybTpyLG1zVHJhbnNmb3JtOnIsdHJhbnNmb3JtOnJ9fWZ1bmN0aW9uIER0KHQsaSl7dmFyIGU9dC5wYWdlWCxhPXQucGFnZVksbj17ZW5kWDplLGVuZFk6YX07cmV0dXJuIGk/bjpfKHtzdGFydFg6ZSxzdGFydFk6YX0sbil9dmFyIEJ0PU51bWJlci5pc0Zpbml0ZXx8aC5pc0Zpbml0ZTtmdW5jdGlvbiBrdCh0KXt2YXIgaT10LmFzcGVjdFJhdGlvLGU9dC5oZWlnaHQsYT10LndpZHRoLG49MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlwiY29udGFpblwiLG89ZnVuY3Rpb24odCl7cmV0dXJuIEJ0KHQpJiYwPHR9O2lmKG8oYSkmJm8oZSkpe3ZhciBoPWUqaTtcImNvbnRhaW5cIj09PW4mJmE8aHx8XCJjb3ZlclwiPT09biYmaDxhP2U9YS9pOmE9ZSppfWVsc2UgbyhhKT9lPWEvaTpvKGUpJiYoYT1lKmkpO3JldHVybnt3aWR0aDphLGhlaWdodDplfX12YXIgRXQ9U3RyaW5nLmZyb21DaGFyQ29kZTt2YXIgVHQ9L15kYXRhOi4qLC87ZnVuY3Rpb24gV3QodCl7dmFyIGk9bmV3IERhdGFWaWV3KHQpLGU9dm9pZCAwLGE9dm9pZCAwLG49dm9pZCAwLG89dm9pZCAwO2lmKDI1NT09PWkuZ2V0VWludDgoMCkmJjIxNj09PWkuZ2V0VWludDgoMSkpZm9yKHZhciBoPWkuYnl0ZUxlbmd0aCxyPTI7cjxoOyl7aWYoMjU1PT09aS5nZXRVaW50OChyKSYmMjI1PT09aS5nZXRVaW50OChyKzEpKXtuPXI7YnJlYWt9cis9MX1pZihuKXt2YXIgcz1uKzEwO2lmKFwiRXhpZlwiPT09ZnVuY3Rpb24odCxpLGUpe3ZhciBhPVwiXCIsbj12b2lkIDA7Zm9yKGUrPWksbj1pO248ZTtuKz0xKWErPUV0KHQuZ2V0VWludDgobikpO3JldHVybiBhfShpLG4rNCw0KSl7dmFyIGM9aS5nZXRVaW50MTYocyk7aWYoKChhPTE4NzYxPT09Yyl8fDE5Nzg5PT09YykmJjQyPT09aS5nZXRVaW50MTYocysyLGEpKXt2YXIgZD1pLmdldFVpbnQzMihzKzQsYSk7ODw9ZCYmKG89cytkKX19fWlmKG8pe3ZhciBsPWkuZ2V0VWludDE2KG8sYSkscD12b2lkIDAsbT12b2lkIDA7Zm9yKG09MDttPGw7bSs9MSlpZihwPW8rMTIqbSsyLDI3ND09PWkuZ2V0VWludDE2KHAsYSkpe3ArPTgsZT1pLmdldFVpbnQxNihwLGEpLGkuc2V0VWludDE2KHAsMSxhKTticmVha319cmV0dXJuIGV9dmFyIE50PXtyZW5kZXI6ZnVuY3Rpb24oKXt0aGlzLmluaXRDb250YWluZXIoKSx0aGlzLmluaXRDYW52YXMoKSx0aGlzLmluaXRDcm9wQm94KCksdGhpcy5yZW5kZXJDYW52YXMoKSx0aGlzLmNyb3BwZWQmJnRoaXMucmVuZGVyQ3JvcEJveCgpfSxpbml0Q29udGFpbmVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lbGVtZW50LGk9dGhpcy5vcHRpb25zLGU9dGhpcy5jb250YWluZXIsYT10aGlzLmNyb3BwZXI7YXQoYSxTKSxudCh0LFMpO3ZhciBuPXt3aWR0aDpNYXRoLm1heChlLm9mZnNldFdpZHRoLE51bWJlcihpLm1pbkNvbnRhaW5lcldpZHRoKXx8MjAwKSxoZWlnaHQ6TWF0aC5tYXgoZS5vZmZzZXRIZWlnaHQsTnVtYmVyKGkubWluQ29udGFpbmVySGVpZ2h0KXx8MTAwKX07ZXQoYSx7d2lkdGg6KHRoaXMuY29udGFpbmVyRGF0YT1uKS53aWR0aCxoZWlnaHQ6bi5oZWlnaHR9KSxhdCh0LFMpLG50KGEsUyl9LGluaXRDYW52YXM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvbnRhaW5lckRhdGEsaT10aGlzLmltYWdlRGF0YSxlPXRoaXMub3B0aW9ucy52aWV3TW9kZSxhPU1hdGguYWJzKGkucm90YXRlKSUxODA9PTkwLG49YT9pLm5hdHVyYWxIZWlnaHQ6aS5uYXR1cmFsV2lkdGgsbz1hP2kubmF0dXJhbFdpZHRoOmkubmF0dXJhbEhlaWdodCxoPW4vbyxyPXQud2lkdGgscz10LmhlaWdodDt0LmhlaWdodCpoPnQud2lkdGg/Mz09PWU/cj10LmhlaWdodCpoOnM9dC53aWR0aC9oOjM9PT1lP3M9dC53aWR0aC9oOnI9dC5oZWlnaHQqaDt2YXIgYz17YXNwZWN0UmF0aW86aCxuYXR1cmFsV2lkdGg6bixuYXR1cmFsSGVpZ2h0Om8sd2lkdGg6cixoZWlnaHQ6c307Yy5sZWZ0PSh0LndpZHRoLXIpLzIsYy50b3A9KHQuaGVpZ2h0LXMpLzIsYy5vbGRMZWZ0PWMubGVmdCxjLm9sZFRvcD1jLnRvcCx0aGlzLmNhbnZhc0RhdGE9Yyx0aGlzLmxpbWl0ZWQ9MT09PWV8fDI9PT1lLHRoaXMubGltaXRDYW52YXMoITAsITApLHRoaXMuaW5pdGlhbEltYWdlRGF0YT1fKHt9LGkpLHRoaXMuaW5pdGlhbENhbnZhc0RhdGE9Xyh7fSxjKX0sbGltaXRDYW52YXM6ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLm9wdGlvbnMsYT10aGlzLmNvbnRhaW5lckRhdGEsbj10aGlzLmNhbnZhc0RhdGEsbz10aGlzLmNyb3BCb3hEYXRhLGg9ZS52aWV3TW9kZSxyPW4uYXNwZWN0UmF0aW8scz10aGlzLmNyb3BwZWQmJm87aWYodCl7dmFyIGM9TnVtYmVyKGUubWluQ2FudmFzV2lkdGgpfHwwLGQ9TnVtYmVyKGUubWluQ2FudmFzSGVpZ2h0KXx8MDsxPGg/KGM9TWF0aC5tYXgoYyxhLndpZHRoKSxkPU1hdGgubWF4KGQsYS5oZWlnaHQpLDM9PT1oJiYoYzxkKnI/Yz1kKnI6ZD1jL3IpKTowPGgmJihjP2M9TWF0aC5tYXgoYyxzP28ud2lkdGg6MCk6ZD9kPU1hdGgubWF4KGQscz9vLmhlaWdodDowKTpzJiYoKGM9by53aWR0aCk8KGQ9by5oZWlnaHQpKnI/Yz1kKnI6ZD1jL3IpKTt2YXIgbD1rdCh7YXNwZWN0UmF0aW86cix3aWR0aDpjLGhlaWdodDpkfSk7Yz1sLndpZHRoLGQ9bC5oZWlnaHQsbi5taW5XaWR0aD1jLG4ubWluSGVpZ2h0PWQsbi5tYXhXaWR0aD0xLzAsbi5tYXhIZWlnaHQ9MS8wfWlmKGkpaWYoKHM/MDoxKTxoKXt2YXIgcD1hLndpZHRoLW4ud2lkdGgsbT1hLmhlaWdodC1uLmhlaWdodDtuLm1pbkxlZnQ9TWF0aC5taW4oMCxwKSxuLm1pblRvcD1NYXRoLm1pbigwLG0pLG4ubWF4TGVmdD1NYXRoLm1heCgwLHApLG4ubWF4VG9wPU1hdGgubWF4KDAsbSkscyYmdGhpcy5saW1pdGVkJiYobi5taW5MZWZ0PU1hdGgubWluKG8ubGVmdCxvLmxlZnQrKG8ud2lkdGgtbi53aWR0aCkpLG4ubWluVG9wPU1hdGgubWluKG8udG9wLG8udG9wKyhvLmhlaWdodC1uLmhlaWdodCkpLG4ubWF4TGVmdD1vLmxlZnQsbi5tYXhUb3A9by50b3AsMj09PWgmJihuLndpZHRoPj1hLndpZHRoJiYobi5taW5MZWZ0PU1hdGgubWluKDAscCksbi5tYXhMZWZ0PU1hdGgubWF4KDAscCkpLG4uaGVpZ2h0Pj1hLmhlaWdodCYmKG4ubWluVG9wPU1hdGgubWluKDAsbSksbi5tYXhUb3A9TWF0aC5tYXgoMCxtKSkpKX1lbHNlIG4ubWluTGVmdD0tbi53aWR0aCxuLm1pblRvcD0tbi5oZWlnaHQsbi5tYXhMZWZ0PWEud2lkdGgsbi5tYXhUb3A9YS5oZWlnaHR9LHJlbmRlckNhbnZhczpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMuY2FudmFzRGF0YSxhPXRoaXMuaW1hZ2VEYXRhO2lmKGkpe3ZhciBuPWZ1bmN0aW9uKHQpe3ZhciBpPXQud2lkdGgsZT10LmhlaWdodCxhPXQuZGVncmVlO2lmKDkwPT0oYT1NYXRoLmFicyhhKSUxODApKXJldHVybnt3aWR0aDplLGhlaWdodDppfTt2YXIgbj1hJTkwKk1hdGguUEkvMTgwLG89TWF0aC5zaW4obiksaD1NYXRoLmNvcyhuKSxyPWkqaCtlKm8scz1pKm8rZSpoO3JldHVybiA5MDxhP3t3aWR0aDpzLGhlaWdodDpyfTp7d2lkdGg6cixoZWlnaHQ6c319KHt3aWR0aDphLm5hdHVyYWxXaWR0aCpNYXRoLmFicyhhLnNjYWxlWHx8MSksaGVpZ2h0OmEubmF0dXJhbEhlaWdodCpNYXRoLmFicyhhLnNjYWxlWXx8MSksZGVncmVlOmEucm90YXRlfHwwfSksbz1uLndpZHRoLGg9bi5oZWlnaHQscj1lLndpZHRoKihvL2UubmF0dXJhbFdpZHRoKSxzPWUuaGVpZ2h0KihoL2UubmF0dXJhbEhlaWdodCk7ZS5sZWZ0LT0oci1lLndpZHRoKS8yLGUudG9wLT0ocy1lLmhlaWdodCkvMixlLndpZHRoPXIsZS5oZWlnaHQ9cyxlLmFzcGVjdFJhdGlvPW8vaCxlLm5hdHVyYWxXaWR0aD1vLGUubmF0dXJhbEhlaWdodD1oLHRoaXMubGltaXRDYW52YXMoITAsITEpfShlLndpZHRoPmUubWF4V2lkdGh8fGUud2lkdGg8ZS5taW5XaWR0aCkmJihlLmxlZnQ9ZS5vbGRMZWZ0KSwoZS5oZWlnaHQ+ZS5tYXhIZWlnaHR8fGUuaGVpZ2h0PGUubWluSGVpZ2h0KSYmKGUudG9wPWUub2xkVG9wKSxlLndpZHRoPU1hdGgubWluKE1hdGgubWF4KGUud2lkdGgsZS5taW5XaWR0aCksZS5tYXhXaWR0aCksZS5oZWlnaHQ9TWF0aC5taW4oTWF0aC5tYXgoZS5oZWlnaHQsZS5taW5IZWlnaHQpLGUubWF4SGVpZ2h0KSx0aGlzLmxpbWl0Q2FudmFzKCExLCEwKSxlLmxlZnQ9TWF0aC5taW4oTWF0aC5tYXgoZS5sZWZ0LGUubWluTGVmdCksZS5tYXhMZWZ0KSxlLnRvcD1NYXRoLm1pbihNYXRoLm1heChlLnRvcCxlLm1pblRvcCksZS5tYXhUb3ApLGUub2xkTGVmdD1lLmxlZnQsZS5vbGRUb3A9ZS50b3AsZXQodGhpcy5jYW52YXMsXyh7d2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHR9LEN0KHt0cmFuc2xhdGVYOmUubGVmdCx0cmFuc2xhdGVZOmUudG9wfSkpKSx0aGlzLnJlbmRlckltYWdlKHQpLHRoaXMuY3JvcHBlZCYmdGhpcy5saW1pdGVkJiZ0aGlzLmxpbWl0Q3JvcEJveCghMCwhMCl9LHJlbmRlckltYWdlOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuY2FudmFzRGF0YSxlPXRoaXMuaW1hZ2VEYXRhLGE9ZS5uYXR1cmFsV2lkdGgqKGkud2lkdGgvaS5uYXR1cmFsV2lkdGgpLG49ZS5uYXR1cmFsSGVpZ2h0KihpLmhlaWdodC9pLm5hdHVyYWxIZWlnaHQpO18oZSx7d2lkdGg6YSxoZWlnaHQ6bixsZWZ0OihpLndpZHRoLWEpLzIsdG9wOihpLmhlaWdodC1uKS8yfSksZXQodGhpcy5pbWFnZSxfKHt3aWR0aDplLndpZHRoLGhlaWdodDplLmhlaWdodH0sQ3QoXyh7dHJhbnNsYXRlWDplLmxlZnQsdHJhbnNsYXRlWTplLnRvcH0sZSkpKSksdCYmdGhpcy5vdXRwdXQoKX0saW5pdENyb3BCb3g6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnMsaT10aGlzLmNhbnZhc0RhdGEsZT10LmFzcGVjdFJhdGlvfHx0LmluaXRpYWxBc3BlY3RSYXRpbyxhPU51bWJlcih0LmF1dG9Dcm9wQXJlYSl8fC44LG49e3dpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0fTtlJiYoaS5oZWlnaHQqZT5pLndpZHRoP24uaGVpZ2h0PW4ud2lkdGgvZTpuLndpZHRoPW4uaGVpZ2h0KmUpLHRoaXMuY3JvcEJveERhdGE9bix0aGlzLmxpbWl0Q3JvcEJveCghMCwhMCksbi53aWR0aD1NYXRoLm1pbihNYXRoLm1heChuLndpZHRoLG4ubWluV2lkdGgpLG4ubWF4V2lkdGgpLG4uaGVpZ2h0PU1hdGgubWluKE1hdGgubWF4KG4uaGVpZ2h0LG4ubWluSGVpZ2h0KSxuLm1heEhlaWdodCksbi53aWR0aD1NYXRoLm1heChuLm1pbldpZHRoLG4ud2lkdGgqYSksbi5oZWlnaHQ9TWF0aC5tYXgobi5taW5IZWlnaHQsbi5oZWlnaHQqYSksbi5sZWZ0PWkubGVmdCsoaS53aWR0aC1uLndpZHRoKS8yLG4udG9wPWkudG9wKyhpLmhlaWdodC1uLmhlaWdodCkvMixuLm9sZExlZnQ9bi5sZWZ0LG4ub2xkVG9wPW4udG9wLHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhPV8oe30sbil9LGxpbWl0Q3JvcEJveDpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMub3B0aW9ucyxhPXRoaXMuY29udGFpbmVyRGF0YSxuPXRoaXMuY2FudmFzRGF0YSxvPXRoaXMuY3JvcEJveERhdGEsaD10aGlzLmxpbWl0ZWQscj1lLmFzcGVjdFJhdGlvO2lmKHQpe3ZhciBzPU51bWJlcihlLm1pbkNyb3BCb3hXaWR0aCl8fDAsYz1OdW1iZXIoZS5taW5Dcm9wQm94SGVpZ2h0KXx8MCxkPWg/TWF0aC5taW4oYS53aWR0aCxuLndpZHRoLG4ud2lkdGgrbi5sZWZ0LGEud2lkdGgtbi5sZWZ0KTphLndpZHRoLGw9aD9NYXRoLm1pbihhLmhlaWdodCxuLmhlaWdodCxuLmhlaWdodCtuLnRvcCxhLmhlaWdodC1uLnRvcCk6YS5oZWlnaHQ7cz1NYXRoLm1pbihzLGEud2lkdGgpLGM9TWF0aC5taW4oYyxhLmhlaWdodCksciYmKHMmJmM/czxjKnI/Yz1zL3I6cz1jKnI6cz9jPXMvcjpjJiYocz1jKnIpLGQ8bCpyP2w9ZC9yOmQ9bCpyKSxvLm1pbldpZHRoPU1hdGgubWluKHMsZCksby5taW5IZWlnaHQ9TWF0aC5taW4oYyxsKSxvLm1heFdpZHRoPWQsby5tYXhIZWlnaHQ9bH1pJiYoaD8oby5taW5MZWZ0PU1hdGgubWF4KDAsbi5sZWZ0KSxvLm1pblRvcD1NYXRoLm1heCgwLG4udG9wKSxvLm1heExlZnQ9TWF0aC5taW4oYS53aWR0aCxuLmxlZnQrbi53aWR0aCktby53aWR0aCxvLm1heFRvcD1NYXRoLm1pbihhLmhlaWdodCxuLnRvcCtuLmhlaWdodCktby5oZWlnaHQpOihvLm1pbkxlZnQ9MCxvLm1pblRvcD0wLG8ubWF4TGVmdD1hLndpZHRoLW8ud2lkdGgsby5tYXhUb3A9YS5oZWlnaHQtby5oZWlnaHQpKX0scmVuZGVyQ3JvcEJveDpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucyxpPXRoaXMuY29udGFpbmVyRGF0YSxlPXRoaXMuY3JvcEJveERhdGE7KGUud2lkdGg+ZS5tYXhXaWR0aHx8ZS53aWR0aDxlLm1pbldpZHRoKSYmKGUubGVmdD1lLm9sZExlZnQpLChlLmhlaWdodD5lLm1heEhlaWdodHx8ZS5oZWlnaHQ8ZS5taW5IZWlnaHQpJiYoZS50b3A9ZS5vbGRUb3ApLGUud2lkdGg9TWF0aC5taW4oTWF0aC5tYXgoZS53aWR0aCxlLm1pbldpZHRoKSxlLm1heFdpZHRoKSxlLmhlaWdodD1NYXRoLm1pbihNYXRoLm1heChlLmhlaWdodCxlLm1pbkhlaWdodCksZS5tYXhIZWlnaHQpLHRoaXMubGltaXRDcm9wQm94KCExLCEwKSxlLmxlZnQ9TWF0aC5taW4oTWF0aC5tYXgoZS5sZWZ0LGUubWluTGVmdCksZS5tYXhMZWZ0KSxlLnRvcD1NYXRoLm1pbihNYXRoLm1heChlLnRvcCxlLm1pblRvcCksZS5tYXhUb3ApLGUub2xkTGVmdD1lLmxlZnQsZS5vbGRUb3A9ZS50b3AsdC5tb3ZhYmxlJiZ0LmNyb3BCb3hNb3ZhYmxlJiZjdCh0aGlzLmZhY2UsbSxlLndpZHRoPj1pLndpZHRoJiZlLmhlaWdodD49aS5oZWlnaHQ/VDprKSxldCh0aGlzLmNyb3BCb3gsXyh7d2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHR9LEN0KHt0cmFuc2xhdGVYOmUubGVmdCx0cmFuc2xhdGVZOmUudG9wfSkpKSx0aGlzLmNyb3BwZWQmJnRoaXMubGltaXRlZCYmdGhpcy5saW1pdENhbnZhcyghMCwhMCksdGhpcy5kaXNhYmxlZHx8dGhpcy5vdXRwdXQoKX0sb3V0cHV0OmZ1bmN0aW9uKCl7dGhpcy5wcmV2aWV3KCksdXQodGhpcy5lbGVtZW50LGEsdGhpcy5nZXREYXRhKCkpfX0sSHQ9e2luaXRQcmV2aWV3OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jcm9zc09yaWdpbix0PXRoaXMub3B0aW9ucy5wcmV2aWV3LGE9ZT90aGlzLmNyb3NzT3JpZ2luVXJsOnRoaXMudXJsLGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtpZihlJiYoaS5jcm9zc09yaWdpbj1lKSxpLnNyYz1hLHRoaXMudmlld0JveC5hcHBlbmRDaGlsZChpKSx0aGlzLnZpZXdCb3hJbWFnZT1pLHQpe3ZhciBuPXQ7XCJzdHJpbmdcIj09dHlwZW9mIHQ/bj10aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpOnQucXVlcnlTZWxlY3RvciYmKG49W3RdKSxKKHRoaXMucHJldmlld3M9bixmdW5jdGlvbih0KXt2YXIgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO2N0KHQsZyx7d2lkdGg6dC5vZmZzZXRXaWR0aCxoZWlnaHQ6dC5vZmZzZXRIZWlnaHQsaHRtbDp0LmlubmVySFRNTH0pLGUmJihpLmNyb3NzT3JpZ2luPWUpLGkuc3JjPWEsaS5zdHlsZS5jc3NUZXh0PSdkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OmF1dG87bWluLXdpZHRoOjAhaW1wb3J0YW50O21pbi1oZWlnaHQ6MCFpbXBvcnRhbnQ7bWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50O21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnQ7aW1hZ2Utb3JpZW50YXRpb246MGRlZyFpbXBvcnRhbnQ7XCInLHQuaW5uZXJIVE1MPVwiXCIsdC5hcHBlbmRDaGlsZChpKX0pfX0scmVzZXRQcmV2aWV3OmZ1bmN0aW9uKCl7Sih0aGlzLnByZXZpZXdzLGZ1bmN0aW9uKHQpe3ZhciBpPXN0KHQsZyk7ZXQodCx7d2lkdGg6aS53aWR0aCxoZWlnaHQ6aS5oZWlnaHR9KSx0LmlubmVySFRNTD1pLmh0bWwsZHQodCxnKX0pfSxwcmV2aWV3OmZ1bmN0aW9uKCl7dmFyIHI9dGhpcy5pbWFnZURhdGEsdD10aGlzLmNhbnZhc0RhdGEsaT10aGlzLmNyb3BCb3hEYXRhLHM9aS53aWR0aCxjPWkuaGVpZ2h0LGQ9ci53aWR0aCxsPXIuaGVpZ2h0LHA9aS5sZWZ0LXQubGVmdC1yLmxlZnQsbT1pLnRvcC10LnRvcC1yLnRvcDt0aGlzLmNyb3BwZWQmJiF0aGlzLmRpc2FibGVkJiYoZXQodGhpcy52aWV3Qm94SW1hZ2UsXyh7d2lkdGg6ZCxoZWlnaHQ6bH0sQ3QoXyh7dHJhbnNsYXRlWDotcCx0cmFuc2xhdGVZOi1tfSxyKSkpKSxKKHRoaXMucHJldmlld3MsZnVuY3Rpb24odCl7dmFyIGk9c3QodCxnKSxlPWkud2lkdGgsYT1pLmhlaWdodCxuPWUsbz1hLGg9MTtzJiYobz1jKihoPWUvcykpLGMmJmE8byYmKG49cyooaD1hL2MpLG89YSksZXQodCx7d2lkdGg6bixoZWlnaHQ6b30pLGV0KHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbWdcIilbMF0sXyh7d2lkdGg6ZCpoLGhlaWdodDpsKmh9LEN0KF8oe3RyYW5zbGF0ZVg6LXAqaCx0cmFuc2xhdGVZOi1tKmh9LHIpKSkpfSkpfX0sTHQ9e2JpbmQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVsZW1lbnQsaT10aGlzLm9wdGlvbnMsZT10aGlzLmNyb3BwZXI7RyhpLmNyb3BzdGFydCkmJmd0KHQsdyxpLmNyb3BzdGFydCksRyhpLmNyb3Btb3ZlKSYmZ3QodCx2LGkuY3JvcG1vdmUpLEcoaS5jcm9wZW5kKSYmZ3QodCxmLGkuY3JvcGVuZCksRyhpLmNyb3ApJiZndCh0LGEsaS5jcm9wKSxHKGkuem9vbSkmJmd0KHQsQSxpLnpvb20pLGd0KGUsYix0aGlzLm9uQ3JvcFN0YXJ0PXRoaXMuY3JvcFN0YXJ0LmJpbmQodGhpcykpLGkuem9vbWFibGUmJmkuem9vbU9uV2hlZWwmJmd0KGUsQix0aGlzLm9uV2hlZWw9dGhpcy53aGVlbC5iaW5kKHRoaXMpKSxpLnRvZ2dsZURyYWdNb2RlT25EYmxjbGljayYmZ3QoZSx4LHRoaXMub25EYmxjbGljaz10aGlzLmRibGNsaWNrLmJpbmQodGhpcykpLGd0KHQub3duZXJEb2N1bWVudCx5LHRoaXMub25Dcm9wTW92ZT10aGlzLmNyb3BNb3ZlLmJpbmQodGhpcykpLGd0KHQub3duZXJEb2N1bWVudCxNLHRoaXMub25Dcm9wRW5kPXRoaXMuY3JvcEVuZC5iaW5kKHRoaXMpKSxpLnJlc3BvbnNpdmUmJmd0KHdpbmRvdyxELHRoaXMub25SZXNpemU9dGhpcy5yZXNpemUuYmluZCh0aGlzKSl9LHVuYmluZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWxlbWVudCxpPXRoaXMub3B0aW9ucyxlPXRoaXMuY3JvcHBlcjtHKGkuY3JvcHN0YXJ0KSYmbXQodCx3LGkuY3JvcHN0YXJ0KSxHKGkuY3JvcG1vdmUpJiZtdCh0LHYsaS5jcm9wbW92ZSksRyhpLmNyb3BlbmQpJiZtdCh0LGYsaS5jcm9wZW5kKSxHKGkuY3JvcCkmJm10KHQsYSxpLmNyb3ApLEcoaS56b29tKSYmbXQodCxBLGkuem9vbSksbXQoZSxiLHRoaXMub25Dcm9wU3RhcnQpLGkuem9vbWFibGUmJmkuem9vbU9uV2hlZWwmJm10KGUsQix0aGlzLm9uV2hlZWwpLGkudG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrJiZtdChlLHgsdGhpcy5vbkRibGNsaWNrKSxtdCh0Lm93bmVyRG9jdW1lbnQseSx0aGlzLm9uQ3JvcE1vdmUpLG10KHQub3duZXJEb2N1bWVudCxNLHRoaXMub25Dcm9wRW5kKSxpLnJlc3BvbnNpdmUmJm10KHdpbmRvdyxELHRoaXMub25SZXNpemUpfX0sT3Q9e3Jlc2l6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucyxpPXRoaXMuY29udGFpbmVyLGU9dGhpcy5jb250YWluZXJEYXRhLGE9TnVtYmVyKHQubWluQ29udGFpbmVyV2lkdGgpfHwyMDAsbj1OdW1iZXIodC5taW5Db250YWluZXJIZWlnaHQpfHwxMDA7aWYoISh0aGlzLmRpc2FibGVkfHxlLndpZHRoPD1hfHxlLmhlaWdodDw9bikpe3ZhciBvPWkub2Zmc2V0V2lkdGgvZS53aWR0aDtpZigxIT09b3x8aS5vZmZzZXRIZWlnaHQhPT1lLmhlaWdodCl7dmFyIGg9dm9pZCAwLHI9dm9pZCAwO3QucmVzdG9yZSYmKGg9dGhpcy5nZXRDYW52YXNEYXRhKCkscj10aGlzLmdldENyb3BCb3hEYXRhKCkpLHRoaXMucmVuZGVyKCksdC5yZXN0b3JlJiYodGhpcy5zZXRDYW52YXNEYXRhKEooaCxmdW5jdGlvbih0LGkpe2hbaV09dCpvfSkpLHRoaXMuc2V0Q3JvcEJveERhdGEoSihyLGZ1bmN0aW9uKHQsaSl7cltpXT10Km99KSkpfX19LGRibGNsaWNrOmZ1bmN0aW9uKCl7dmFyIHQsaTt0aGlzLmRpc2FibGVkfHx0aGlzLm9wdGlvbnMuZHJhZ01vZGU9PT11fHx0aGlzLnNldERyYWdNb2RlKCh0PXRoaXMuZHJhZ0JveCxpPXIsKHQuY2xhc3NMaXN0P3QuY2xhc3NMaXN0LmNvbnRhaW5zKGkpOi0xPHQuY2xhc3NOYW1lLmluZGV4T2YoaSkpP2M6cykpfSx3aGVlbDpmdW5jdGlvbih0KXt2YXIgaT10aGlzLGU9TnVtYmVyKHRoaXMub3B0aW9ucy53aGVlbFpvb21SYXRpbyl8fC4xLGE9MTt0aGlzLmRpc2FibGVkfHwodC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMud2hlZWxpbmd8fCh0aGlzLndoZWVsaW5nPSEwLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpLndoZWVsaW5nPSExfSw1MCksdC5kZWx0YVk/YT0wPHQuZGVsdGFZPzE6LTE6dC53aGVlbERlbHRhP2E9LXQud2hlZWxEZWx0YS8xMjA6dC5kZXRhaWwmJihhPTA8dC5kZXRhaWw/MTotMSksdGhpcy56b29tKC1hKmUsdCkpKX0sY3JvcFN0YXJ0OmZ1bmN0aW9uKHQpe2lmKCF0aGlzLmRpc2FibGVkKXt2YXIgaT10aGlzLm9wdGlvbnMsZT10aGlzLnBvaW50ZXJzLGE9dm9pZCAwO3QuY2hhbmdlZFRvdWNoZXM/Sih0LmNoYW5nZWRUb3VjaGVzLGZ1bmN0aW9uKHQpe2VbdC5pZGVudGlmaWVyXT1EdCh0KX0pOmVbdC5wb2ludGVySWR8fDBdPUR0KHQpLGE9MTxPYmplY3Qua2V5cyhlKS5sZW5ndGgmJmkuem9vbWFibGUmJmkuem9vbU9uVG91Y2g/VzpzdCh0LnRhcmdldCxtKSxJLnRlc3QoYSkmJiExIT09dXQodGhpcy5lbGVtZW50LHcse29yaWdpbmFsRXZlbnQ6dCxhY3Rpb246YX0pJiYodC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuYWN0aW9uPWEsdGhpcy5jcm9wcGluZz0hMSxhPT09RSYmKHRoaXMuY3JvcHBpbmc9ITAsYXQodGhpcy5kcmFnQm94LG8pKSl9fSxjcm9wTW92ZTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLmFjdGlvbjtpZighdGhpcy5kaXNhYmxlZCYmaSl7dmFyIGU9dGhpcy5wb2ludGVyczt0LnByZXZlbnREZWZhdWx0KCksITEhPT11dCh0aGlzLmVsZW1lbnQsdix7b3JpZ2luYWxFdmVudDp0LGFjdGlvbjppfSkmJih0LmNoYW5nZWRUb3VjaGVzP0oodC5jaGFuZ2VkVG91Y2hlcyxmdW5jdGlvbih0KXtfKGVbdC5pZGVudGlmaWVyXSxEdCh0LCEwKSl9KTpfKGVbdC5wb2ludGVySWR8fDBdLER0KHQsITApKSx0aGlzLmNoYW5nZSh0KSl9fSxjcm9wRW5kOmZ1bmN0aW9uKHQpe2lmKCF0aGlzLmRpc2FibGVkKXt2YXIgaT10aGlzLmFjdGlvbixlPXRoaXMucG9pbnRlcnM7dC5jaGFuZ2VkVG91Y2hlcz9KKHQuY2hhbmdlZFRvdWNoZXMsZnVuY3Rpb24odCl7ZGVsZXRlIGVbdC5pZGVudGlmaWVyXX0pOmRlbGV0ZSBlW3QucG9pbnRlcklkfHwwXSxpJiYodC5wcmV2ZW50RGVmYXVsdCgpLE9iamVjdC5rZXlzKGUpLmxlbmd0aHx8KHRoaXMuYWN0aW9uPVwiXCIpLHRoaXMuY3JvcHBpbmcmJih0aGlzLmNyb3BwaW5nPSExLG90KHRoaXMuZHJhZ0JveCxvLHRoaXMuY3JvcHBlZCYmdGhpcy5vcHRpb25zLm1vZGFsKSksdXQodGhpcy5lbGVtZW50LGYse29yaWdpbmFsRXZlbnQ6dCxhY3Rpb246aX0pKX19fSx6dD17Y2hhbmdlOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMub3B0aW9ucyxlPXRoaXMuY2FudmFzRGF0YSxhPXRoaXMuY29udGFpbmVyRGF0YSxuPXRoaXMuY3JvcEJveERhdGEsbz10aGlzLnBvaW50ZXJzLGg9dGhpcy5hY3Rpb24scj1pLmFzcGVjdFJhdGlvLHM9bi5sZWZ0LGM9bi50b3AsZD1uLndpZHRoLGw9bi5oZWlnaHQscD1zK2QsbT1jK2wsZz0wLHU9MCxmPWEud2lkdGgsdj1hLmhlaWdodCx3PSEwLHg9dm9pZCAwOyFyJiZ0LnNoaWZ0S2V5JiYocj1kJiZsP2QvbDoxKSx0aGlzLmxpbWl0ZWQmJihnPW4ubWluTGVmdCx1PW4ubWluVG9wLGY9ZytNYXRoLm1pbihhLndpZHRoLGUud2lkdGgsZS5sZWZ0K2Uud2lkdGgpLHY9dStNYXRoLm1pbihhLmhlaWdodCxlLmhlaWdodCxlLnRvcCtlLmhlaWdodCkpO3ZhciBiLHksTSxDPW9bT2JqZWN0LmtleXMobylbMF1dLEQ9e3g6Qy5lbmRYLUMuc3RhcnRYLHk6Qy5lbmRZLUMuc3RhcnRZfSxCPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIE46cCtELng+ZiYmKEQueD1mLXApO2JyZWFrO2Nhc2UgSDpzK0QueDxnJiYoRC54PWctcyk7YnJlYWs7Y2FzZSBPOmMrRC55PHUmJihELnk9dS1jKTticmVhaztjYXNlIEw6bStELnk+diYmKEQueT12LW0pfX07c3dpdGNoKGgpe2Nhc2UgazpzKz1ELngsYys9RC55O2JyZWFrO2Nhc2UgTjppZigwPD1ELngmJihmPD1wfHxyJiYoYzw9dXx8djw9bSkpKXt3PSExO2JyZWFrfUIoTiksKGQrPUQueCk8MCYmKGg9SCxzLT1kPS1kKSxyJiYobD1kL3IsYys9KG4uaGVpZ2h0LWwpLzIpO2JyZWFrO2Nhc2UgTzppZihELnk8PTAmJihjPD11fHxyJiYoczw9Z3x8Zjw9cCkpKXt3PSExO2JyZWFrfUIoTyksbC09RC55LGMrPUQueSxsPDAmJihoPUwsYy09bD0tbCksciYmKGQ9bCpyLHMrPShuLndpZHRoLWQpLzIpO2JyZWFrO2Nhc2UgSDppZihELng8PTAmJihzPD1nfHxyJiYoYzw9dXx8djw9bSkpKXt3PSExO2JyZWFrfUIoSCksZC09RC54LHMrPUQueCxkPDAmJihoPU4scy09ZD0tZCksciYmKGw9ZC9yLGMrPShuLmhlaWdodC1sKS8yKTticmVhaztjYXNlIEw6aWYoMDw9RC55JiYodjw9bXx8ciYmKHM8PWd8fGY8PXApKSl7dz0hMTticmVha31CKEwpLChsKz1ELnkpPDAmJihoPU8sYy09bD0tbCksciYmKGQ9bCpyLHMrPShuLndpZHRoLWQpLzIpO2JyZWFrO2Nhc2UgejppZihyKXtpZihELnk8PTAmJihjPD11fHxmPD1wKSl7dz0hMTticmVha31CKE8pLGwtPUQueSxjKz1ELnksZD1sKnJ9ZWxzZSBCKE8pLEIoTiksMDw9RC54P3A8Zj9kKz1ELng6RC55PD0wJiZjPD11JiYodz0hMSk6ZCs9RC54LEQueTw9MD91PGMmJihsLT1ELnksYys9RC55KToobC09RC55LGMrPUQueSk7ZDwwJiZsPDA/KGg9UixjLT1sPS1sLHMtPWQ9LWQpOmQ8MD8oaD1ZLHMtPWQ9LWQpOmw8MCYmKGg9WCxjLT1sPS1sKTticmVhaztjYXNlIFk6aWYocil7aWYoRC55PD0wJiYoYzw9dXx8czw9Zykpe3c9ITE7YnJlYWt9QihPKSxsLT1ELnksYys9RC55LGQ9bCpyLHMrPW4ud2lkdGgtZH1lbHNlIEIoTyksQihIKSxELng8PTA/ZzxzPyhkLT1ELngscys9RC54KTpELnk8PTAmJmM8PXUmJih3PSExKTooZC09RC54LHMrPUQueCksRC55PD0wP3U8YyYmKGwtPUQueSxjKz1ELnkpOihsLT1ELnksYys9RC55KTtkPDAmJmw8MD8oaD1YLGMtPWw9LWwscy09ZD0tZCk6ZDwwPyhoPXoscy09ZD0tZCk6bDwwJiYoaD1SLGMtPWw9LWwpO2JyZWFrO2Nhc2UgUjppZihyKXtpZihELng8PTAmJihzPD1nfHx2PD1tKSl7dz0hMTticmVha31CKEgpLGQtPUQueCxzKz1ELngsbD1kL3J9ZWxzZSBCKEwpLEIoSCksRC54PD0wP2c8cz8oZC09RC54LHMrPUQueCk6MDw9RC55JiZ2PD1tJiYodz0hMSk6KGQtPUQueCxzKz1ELngpLDA8PUQueT9tPHYmJihsKz1ELnkpOmwrPUQueTtkPDAmJmw8MD8oaD16LGMtPWw9LWwscy09ZD0tZCk6ZDwwPyhoPVgscy09ZD0tZCk6bDwwJiYoaD1ZLGMtPWw9LWwpO2JyZWFrO2Nhc2UgWDppZihyKXtpZigwPD1ELngmJihmPD1wfHx2PD1tKSl7dz0hMTticmVha31CKE4pLGw9KGQrPUQueCkvcn1lbHNlIEIoTCksQihOKSwwPD1ELng/cDxmP2QrPUQueDowPD1ELnkmJnY8PW0mJih3PSExKTpkKz1ELngsMDw9RC55P208diYmKGwrPUQueSk6bCs9RC55O2Q8MCYmbDwwPyhoPVksYy09bD0tbCxzLT1kPS1kKTpkPDA/KGg9UixzLT1kPS1kKTpsPDAmJihoPXosYy09bD0tbCk7YnJlYWs7Y2FzZSBUOnRoaXMubW92ZShELngsRC55KSx3PSExO2JyZWFrO2Nhc2UgVzp0aGlzLnpvb20oKHk9Xyh7fSxiPW8pLE09W10sSihiLGZ1bmN0aW9uKHIsdCl7ZGVsZXRlIHlbdF0sSih5LGZ1bmN0aW9uKHQpe3ZhciBpPU1hdGguYWJzKHIuc3RhcnRYLXQuc3RhcnRYKSxlPU1hdGguYWJzKHIuc3RhcnRZLXQuc3RhcnRZKSxhPU1hdGguYWJzKHIuZW5kWC10LmVuZFgpLG49TWF0aC5hYnMoci5lbmRZLXQuZW5kWSksbz1NYXRoLnNxcnQoaSppK2UqZSksaD0oTWF0aC5zcXJ0KGEqYStuKm4pLW8pL287TS5wdXNoKGgpfSl9KSxNLnNvcnQoZnVuY3Rpb24odCxpKXtyZXR1cm4gTWF0aC5hYnModCk8TWF0aC5hYnMoaSl9KSxNWzBdKSx0KSx3PSExO2JyZWFrO2Nhc2UgRTppZighRC54fHwhRC55KXt3PSExO2JyZWFrfXg9ZnQodGhpcy5jcm9wcGVyKSxzPUMuc3RhcnRYLXgubGVmdCxjPUMuc3RhcnRZLXgudG9wLGQ9bi5taW5XaWR0aCxsPW4ubWluSGVpZ2h0LDA8RC54P2g9MDxELnk/WDp6OkQueDwwJiYocy09ZCxoPTA8RC55P1I6WSksRC55PDAmJihjLT1sKSx0aGlzLmNyb3BwZWR8fChudCh0aGlzLmNyb3BCb3gsUyksdGhpcy5jcm9wcGVkPSEwLHRoaXMubGltaXRlZCYmdGhpcy5saW1pdENyb3BCb3goITAsITApKX13JiYobi53aWR0aD1kLG4uaGVpZ2h0PWwsbi5sZWZ0PXMsbi50b3A9Yyx0aGlzLmFjdGlvbj1oLHRoaXMucmVuZGVyQ3JvcEJveCgpKSxKKG8sZnVuY3Rpb24odCl7dC5zdGFydFg9dC5lbmRYLHQuc3RhcnRZPXQuZW5kWX0pfX0sWXQ9e2Nyb3A6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5yZWFkeXx8dGhpcy5jcm9wcGVkfHx0aGlzLmRpc2FibGVkfHwodGhpcy5jcm9wcGVkPSEwLHRoaXMubGltaXRDcm9wQm94KCEwLCEwKSx0aGlzLm9wdGlvbnMubW9kYWwmJmF0KHRoaXMuZHJhZ0JveCxvKSxudCh0aGlzLmNyb3BCb3gsUyksdGhpcy5zZXRDcm9wQm94RGF0YSh0aGlzLmluaXRpYWxDcm9wQm94RGF0YSkpLHRoaXN9LHJlc2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVhZHkmJiF0aGlzLmRpc2FibGVkJiYodGhpcy5pbWFnZURhdGE9Xyh7fSx0aGlzLmluaXRpYWxJbWFnZURhdGEpLHRoaXMuY2FudmFzRGF0YT1fKHt9LHRoaXMuaW5pdGlhbENhbnZhc0RhdGEpLHRoaXMuY3JvcEJveERhdGE9Xyh7fSx0aGlzLmluaXRpYWxDcm9wQm94RGF0YSksdGhpcy5yZW5kZXJDYW52YXMoKSx0aGlzLmNyb3BwZWQmJnRoaXMucmVuZGVyQ3JvcEJveCgpKSx0aGlzfSxjbGVhcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNyb3BwZWQmJiF0aGlzLmRpc2FibGVkJiYoXyh0aGlzLmNyb3BCb3hEYXRhLHtsZWZ0OjAsdG9wOjAsd2lkdGg6MCxoZWlnaHQ6MH0pLHRoaXMuY3JvcHBlZD0hMSx0aGlzLnJlbmRlckNyb3BCb3goKSx0aGlzLmxpbWl0Q2FudmFzKCEwLCEwKSx0aGlzLnJlbmRlckNhbnZhcygpLG50KHRoaXMuZHJhZ0JveCxvKSxhdCh0aGlzLmNyb3BCb3gsUykpLHRoaXN9LHJlcGxhY2U6ZnVuY3Rpb24oaSl7dmFyIHQ9MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtyZXR1cm4hdGhpcy5kaXNhYmxlZCYmaSYmKHRoaXMuaXNJbWcmJih0aGlzLmVsZW1lbnQuc3JjPWkpLHQ/KHRoaXMudXJsPWksdGhpcy5pbWFnZS5zcmM9aSx0aGlzLnJlYWR5JiYodGhpcy52aWV3Qm94SW1hZ2Uuc3JjPWksSih0aGlzLnByZXZpZXdzLGZ1bmN0aW9uKHQpe3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbWdcIilbMF0uc3JjPWl9KSkpOih0aGlzLmlzSW1nJiYodGhpcy5yZXBsYWNlZD0hMCksdGhpcy5vcHRpb25zLmRhdGE9bnVsbCx0aGlzLnVuY3JlYXRlKCksdGhpcy5sb2FkKGkpKSksdGhpc30sZW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVhZHkmJnRoaXMuZGlzYWJsZWQmJih0aGlzLmRpc2FibGVkPSExLG50KHRoaXMuY3JvcHBlcix0KSksdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlYWR5JiYhdGhpcy5kaXNhYmxlZCYmKHRoaXMuZGlzYWJsZWQ9ITAsYXQodGhpcy5jcm9wcGVyLHQpKSx0aGlzfSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lbGVtZW50O3JldHVybiBzdCh0LGQpJiYodGhpcy5pc0ltZyYmdGhpcy5yZXBsYWNlZCYmKHQuc3JjPXRoaXMub3JpZ2luYWxVcmwpLHRoaXMudW5jcmVhdGUoKSxkdCh0LGQpKSx0aGlzfSxtb3ZlOmZ1bmN0aW9uKHQpe3ZhciBpPTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0LGU9dGhpcy5jYW52YXNEYXRhLGE9ZS5sZWZ0LG49ZS50b3A7cmV0dXJuIHRoaXMubW92ZVRvKFoodCk/dDphK051bWJlcih0KSxaKGkpP2k6bitOdW1iZXIoaSkpfSxtb3ZlVG86ZnVuY3Rpb24odCl7dmFyIGk9MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnQsZT10aGlzLmNhbnZhc0RhdGEsYT0hMTtyZXR1cm4gdD1OdW1iZXIodCksaT1OdW1iZXIoaSksdGhpcy5yZWFkeSYmIXRoaXMuZGlzYWJsZWQmJnRoaXMub3B0aW9ucy5tb3ZhYmxlJiYoUSh0KSYmKGUubGVmdD10LGE9ITApLFEoaSkmJihlLnRvcD1pLGE9ITApLGEmJnRoaXMucmVuZGVyQ2FudmFzKCEwKSksdGhpc30sem9vbTpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMuY2FudmFzRGF0YTtyZXR1cm4gdD0odD1OdW1iZXIodCkpPDA/MS8oMS10KToxK3QsdGhpcy56b29tVG8oZS53aWR0aCp0L2UubmF0dXJhbFdpZHRoLG51bGwsaSl9LHpvb21UbzpmdW5jdGlvbih0LGksZSl7dmFyIGEsbixvLGg9dGhpcy5vcHRpb25zLHI9dGhpcy5jYW52YXNEYXRhLHM9ci53aWR0aCxjPXIuaGVpZ2h0LGQ9ci5uYXR1cmFsV2lkdGgsbD1yLm5hdHVyYWxIZWlnaHQ7aWYoMDw9KHQ9TnVtYmVyKHQpKSYmdGhpcy5yZWFkeSYmIXRoaXMuZGlzYWJsZWQmJmguem9vbWFibGUpe3ZhciBwPWQqdCxtPWwqdDtpZighMT09PXV0KHRoaXMuZWxlbWVudCxBLHtyYXRpbzp0LG9sZFJhdGlvOnMvZCxvcmlnaW5hbEV2ZW50OmV9KSlyZXR1cm4gdGhpcztpZihlKXt2YXIgZz10aGlzLnBvaW50ZXJzLHU9ZnQodGhpcy5jcm9wcGVyKSxmPWcmJk9iamVjdC5rZXlzKGcpLmxlbmd0aD8obz1uPWE9MCxKKGcsZnVuY3Rpb24odCl7dmFyIGk9dC5zdGFydFgsZT10LnN0YXJ0WTthKz1pLG4rPWUsbys9MX0pLHtwYWdlWDphLz1vLHBhZ2VZOm4vPW99KTp7cGFnZVg6ZS5wYWdlWCxwYWdlWTplLnBhZ2VZfTtyLmxlZnQtPShwLXMpKigoZi5wYWdlWC11LmxlZnQtci5sZWZ0KS9zKSxyLnRvcC09KG0tYykqKChmLnBhZ2VZLXUudG9wLXIudG9wKS9jKX1lbHNlIFYoaSkmJlEoaS54KSYmUShpLnkpPyhyLmxlZnQtPShwLXMpKigoaS54LXIubGVmdCkvcyksci50b3AtPShtLWMpKigoaS55LXIudG9wKS9jKSk6KHIubGVmdC09KHAtcykvMixyLnRvcC09KG0tYykvMik7ci53aWR0aD1wLHIuaGVpZ2h0PW0sdGhpcy5yZW5kZXJDYW52YXMoITApfXJldHVybiB0aGlzfSxyb3RhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucm90YXRlVG8oKHRoaXMuaW1hZ2VEYXRhLnJvdGF0ZXx8MCkrTnVtYmVyKHQpKX0scm90YXRlVG86ZnVuY3Rpb24odCl7cmV0dXJuIFEodD1OdW1iZXIodCkpJiZ0aGlzLnJlYWR5JiYhdGhpcy5kaXNhYmxlZCYmdGhpcy5vcHRpb25zLnJvdGF0YWJsZSYmKHRoaXMuaW1hZ2VEYXRhLnJvdGF0ZT10JTM2MCx0aGlzLnJlbmRlckNhbnZhcyghMCwhMCkpLHRoaXN9LHNjYWxlWDpmdW5jdGlvbih0KXt2YXIgaT10aGlzLmltYWdlRGF0YS5zY2FsZVk7cmV0dXJuIHRoaXMuc2NhbGUodCxRKGkpP2k6MSl9LHNjYWxlWTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLmltYWdlRGF0YS5zY2FsZVg7cmV0dXJuIHRoaXMuc2NhbGUoUShpKT9pOjEsdCl9LHNjYWxlOmZ1bmN0aW9uKHQpe3ZhciBpPTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0LGU9dGhpcy5pbWFnZURhdGEsYT0hMTtyZXR1cm4gdD1OdW1iZXIodCksaT1OdW1iZXIoaSksdGhpcy5yZWFkeSYmIXRoaXMuZGlzYWJsZWQmJnRoaXMub3B0aW9ucy5zY2FsYWJsZSYmKFEodCkmJihlLnNjYWxlWD10LGE9ITApLFEoaSkmJihlLnNjYWxlWT1pLGE9ITApLGEmJnRoaXMucmVuZGVyQ2FudmFzKCEwLCEwKSksdGhpc30sZ2V0RGF0YTpmdW5jdGlvbigpe3ZhciB0PTA8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0saT10aGlzLm9wdGlvbnMsZT10aGlzLmltYWdlRGF0YSxhPXRoaXMuY2FudmFzRGF0YSxuPXRoaXMuY3JvcEJveERhdGEsbz12b2lkIDA7aWYodGhpcy5yZWFkeSYmdGhpcy5jcm9wcGVkKXtvPXt4Om4ubGVmdC1hLmxlZnQseTpuLnRvcC1hLnRvcCx3aWR0aDpuLndpZHRoLGhlaWdodDpuLmhlaWdodH07dmFyIGg9ZS53aWR0aC9lLm5hdHVyYWxXaWR0aDtpZihKKG8sZnVuY3Rpb24odCxpKXtvW2ldPXQvaH0pLHQpe3ZhciByPU1hdGgucm91bmQoby55K28uaGVpZ2h0KSxzPU1hdGgucm91bmQoby54K28ud2lkdGgpO28ueD1NYXRoLnJvdW5kKG8ueCksby55PU1hdGgucm91bmQoby55KSxvLndpZHRoPXMtby54LG8uaGVpZ2h0PXItby55fX1lbHNlIG89e3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MH07cmV0dXJuIGkucm90YXRhYmxlJiYoby5yb3RhdGU9ZS5yb3RhdGV8fDApLGkuc2NhbGFibGUmJihvLnNjYWxlWD1lLnNjYWxlWHx8MSxvLnNjYWxlWT1lLnNjYWxlWXx8MSksb30sc2V0RGF0YTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLm9wdGlvbnMsZT10aGlzLmltYWdlRGF0YSxhPXRoaXMuY2FudmFzRGF0YSxuPXt9O2lmKHRoaXMucmVhZHkmJiF0aGlzLmRpc2FibGVkJiZWKHQpKXt2YXIgbz0hMTtpLnJvdGF0YWJsZSYmUSh0LnJvdGF0ZSkmJnQucm90YXRlIT09ZS5yb3RhdGUmJihlLnJvdGF0ZT10LnJvdGF0ZSxvPSEwKSxpLnNjYWxhYmxlJiYoUSh0LnNjYWxlWCkmJnQuc2NhbGVYIT09ZS5zY2FsZVgmJihlLnNjYWxlWD10LnNjYWxlWCxvPSEwKSxRKHQuc2NhbGVZKSYmdC5zY2FsZVkhPT1lLnNjYWxlWSYmKGUuc2NhbGVZPXQuc2NhbGVZLG89ITApKSxvJiZ0aGlzLnJlbmRlckNhbnZhcyghMCwhMCk7dmFyIGg9ZS53aWR0aC9lLm5hdHVyYWxXaWR0aDtRKHQueCkmJihuLmxlZnQ9dC54KmgrYS5sZWZ0KSxRKHQueSkmJihuLnRvcD10LnkqaCthLnRvcCksUSh0LndpZHRoKSYmKG4ud2lkdGg9dC53aWR0aCpoKSxRKHQuaGVpZ2h0KSYmKG4uaGVpZ2h0PXQuaGVpZ2h0KmgpLHRoaXMuc2V0Q3JvcEJveERhdGEobil9cmV0dXJuIHRoaXN9LGdldENvbnRhaW5lckRhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWFkeT9fKHt9LHRoaXMuY29udGFpbmVyRGF0YSk6e319LGdldEltYWdlRGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemVkP18oe30sdGhpcy5pbWFnZURhdGEpOnt9fSxnZXRDYW52YXNEYXRhOmZ1bmN0aW9uKCl7dmFyIGk9dGhpcy5jYW52YXNEYXRhLGU9e307cmV0dXJuIHRoaXMucmVhZHkmJkooW1wibGVmdFwiLFwidG9wXCIsXCJ3aWR0aFwiLFwiaGVpZ2h0XCIsXCJuYXR1cmFsV2lkdGhcIixcIm5hdHVyYWxIZWlnaHRcIl0sZnVuY3Rpb24odCl7ZVt0XT1pW3RdfSksZX0sc2V0Q2FudmFzRGF0YTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLmNhbnZhc0RhdGEsZT1pLmFzcGVjdFJhdGlvO3JldHVybiB0aGlzLnJlYWR5JiYhdGhpcy5kaXNhYmxlZCYmVih0KSYmKFEodC5sZWZ0KSYmKGkubGVmdD10LmxlZnQpLFEodC50b3ApJiYoaS50b3A9dC50b3ApLFEodC53aWR0aCk/KGkud2lkdGg9dC53aWR0aCxpLmhlaWdodD10LndpZHRoL2UpOlEodC5oZWlnaHQpJiYoaS5oZWlnaHQ9dC5oZWlnaHQsaS53aWR0aD10LmhlaWdodCplKSx0aGlzLnJlbmRlckNhbnZhcyghMCkpLHRoaXN9LGdldENyb3BCb3hEYXRhOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jcm9wQm94RGF0YSxpPXZvaWQgMDtyZXR1cm4gdGhpcy5yZWFkeSYmdGhpcy5jcm9wcGVkJiYoaT17bGVmdDp0LmxlZnQsdG9wOnQudG9wLHdpZHRoOnQud2lkdGgsaGVpZ2h0OnQuaGVpZ2h0fSksaXx8e319LHNldENyb3BCb3hEYXRhOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuY3JvcEJveERhdGEsZT10aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW8sYT12b2lkIDAsbj12b2lkIDA7cmV0dXJuIHRoaXMucmVhZHkmJnRoaXMuY3JvcHBlZCYmIXRoaXMuZGlzYWJsZWQmJlYodCkmJihRKHQubGVmdCkmJihpLmxlZnQ9dC5sZWZ0KSxRKHQudG9wKSYmKGkudG9wPXQudG9wKSxRKHQud2lkdGgpJiZ0LndpZHRoIT09aS53aWR0aCYmKGE9ITAsaS53aWR0aD10LndpZHRoKSxRKHQuaGVpZ2h0KSYmdC5oZWlnaHQhPT1pLmhlaWdodCYmKG49ITAsaS5oZWlnaHQ9dC5oZWlnaHQpLGUmJihhP2kuaGVpZ2h0PWkud2lkdGgvZTpuJiYoaS53aWR0aD1pLmhlaWdodCplKSksdGhpcy5yZW5kZXJDcm9wQm94KCkpLHRoaXN9LGdldENyb3BwZWRDYW52YXM6ZnVuY3Rpb24oKXt2YXIgdD0wPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307aWYoIXRoaXMucmVhZHl8fCF3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQpcmV0dXJuIG51bGw7dmFyIGksZSxhLG4sbyxoLHIscyxjLGQsbCxwLG0sZyx1LGYsdix3LHgsYix5LE0sQyxELEIsayxFLFQsVyxOLEgsTCxPLHosWSxYLFIsUyxBLEksVSxqPXRoaXMuY2FudmFzRGF0YSxQPShpPXRoaXMuaW1hZ2UsZT10aGlzLmltYWdlRGF0YSxhPWosbj10LG89ZS5hc3BlY3RSYXRpbyxoPWUubmF0dXJhbFdpZHRoLHI9ZS5uYXR1cmFsSGVpZ2h0LHM9ZS5yb3RhdGUsYz12b2lkIDA9PT1zPzA6cyxkPWUuc2NhbGVYLGw9dm9pZCAwPT09ZD8xOmQscD1lLnNjYWxlWSxtPXZvaWQgMD09PXA/MTpwLGc9YS5hc3BlY3RSYXRpbyx1PWEubmF0dXJhbFdpZHRoLGY9YS5uYXR1cmFsSGVpZ2h0LHY9bi5maWxsQ29sb3Isdz12b2lkIDA9PT12P1widHJhbnNwYXJlbnRcIjp2LHg9bi5pbWFnZVNtb290aGluZ0VuYWJsZWQsYj12b2lkIDA9PT14fHx4LHk9bi5pbWFnZVNtb290aGluZ1F1YWxpdHksTT12b2lkIDA9PT15P1wibG93XCI6eSxDPW4ubWF4V2lkdGgsRD12b2lkIDA9PT1DPzEvMDpDLEI9bi5tYXhIZWlnaHQsaz12b2lkIDA9PT1CPzEvMDpCLEU9bi5taW5XaWR0aCxUPXZvaWQgMD09PUU/MDpFLFc9bi5taW5IZWlnaHQsTj12b2lkIDA9PT1XPzA6VyxIPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksTD1ILmdldENvbnRleHQoXCIyZFwiKSxPPWt0KHthc3BlY3RSYXRpbzpnLHdpZHRoOkQsaGVpZ2h0Omt9KSx6PWt0KHthc3BlY3RSYXRpbzpnLHdpZHRoOlQsaGVpZ2h0Ok59LFwiY292ZXJcIiksWT1NYXRoLm1pbihPLndpZHRoLE1hdGgubWF4KHoud2lkdGgsdSkpLFg9TWF0aC5taW4oTy5oZWlnaHQsTWF0aC5tYXgoei5oZWlnaHQsZikpLFI9a3Qoe2FzcGVjdFJhdGlvOm8sd2lkdGg6RCxoZWlnaHQ6a30pLFM9a3Qoe2FzcGVjdFJhdGlvOm8sd2lkdGg6VCxoZWlnaHQ6Tn0sXCJjb3ZlclwiKSxBPU1hdGgubWluKFIud2lkdGgsTWF0aC5tYXgoUy53aWR0aCxoKSksST1NYXRoLm1pbihSLmhlaWdodCxNYXRoLm1heChTLmhlaWdodCxyKSksVT1bLUEvMiwtSS8yLEEsSV0sSC53aWR0aD1idChZKSxILmhlaWdodD1idChYKSxMLmZpbGxTdHlsZT13LEwuZmlsbFJlY3QoMCwwLFksWCksTC5zYXZlKCksTC50cmFuc2xhdGUoWS8yLFgvMiksTC5yb3RhdGUoYypNYXRoLlBJLzE4MCksTC5zY2FsZShsLG0pLEwuaW1hZ2VTbW9vdGhpbmdFbmFibGVkPWIsTC5pbWFnZVNtb290aGluZ1F1YWxpdHk9TSxMLmRyYXdJbWFnZS5hcHBseShMLFtpXS5jb25jYXQoeHQoVS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguZmxvb3IoYnQodCkpfSkpKSksTC5yZXN0b3JlKCksSCk7aWYoIXRoaXMuY3JvcHBlZClyZXR1cm4gUDt2YXIgcT10aGlzLmdldERhdGEoKSwkPXEueCxRPXEueSxaPXEud2lkdGgsRj1xLmhlaWdodCxLPVAud2lkdGgvTWF0aC5mbG9vcihqLm5hdHVyYWxXaWR0aCk7MSE9PUsmJigkKj1LLFEqPUssWio9SyxGKj1LKTt2YXIgVj1aL0YsRz1rdCh7YXNwZWN0UmF0aW86Vix3aWR0aDp0Lm1heFdpZHRofHwxLzAsaGVpZ2h0OnQubWF4SGVpZ2h0fHwxLzB9KSxKPWt0KHthc3BlY3RSYXRpbzpWLHdpZHRoOnQubWluV2lkdGh8fDAsaGVpZ2h0OnQubWluSGVpZ2h0fHwwfSxcImNvdmVyXCIpLF89a3Qoe2FzcGVjdFJhdGlvOlYsd2lkdGg6dC53aWR0aHx8KDEhPT1LP1Aud2lkdGg6WiksaGVpZ2h0OnQuaGVpZ2h0fHwoMSE9PUs/UC5oZWlnaHQ6Ril9KSx0dD1fLndpZHRoLGl0PV8uaGVpZ2h0O3R0PU1hdGgubWluKEcud2lkdGgsTWF0aC5tYXgoSi53aWR0aCx0dCkpLGl0PU1hdGgubWluKEcuaGVpZ2h0LE1hdGgubWF4KEouaGVpZ2h0LGl0KSk7dmFyIGV0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksYXQ9ZXQuZ2V0Q29udGV4dChcIjJkXCIpO2V0LndpZHRoPWJ0KHR0KSxldC5oZWlnaHQ9YnQoaXQpLGF0LmZpbGxTdHlsZT10LmZpbGxDb2xvcnx8XCJ0cmFuc3BhcmVudFwiLGF0LmZpbGxSZWN0KDAsMCx0dCxpdCk7dmFyIG50PXQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkLG90PXZvaWQgMD09PW50fHxudCxodD10LmltYWdlU21vb3RoaW5nUXVhbGl0eTthdC5pbWFnZVNtb290aGluZ0VuYWJsZWQ9b3QsaHQmJihhdC5pbWFnZVNtb290aGluZ1F1YWxpdHk9aHQpO3ZhciBydD1QLndpZHRoLHN0PVAuaGVpZ2h0LGN0PSQsZHQ9USxsdD12b2lkIDAscHQ9dm9pZCAwLG10PXZvaWQgMCxndD12b2lkIDAsdXQ9dm9pZCAwLGZ0PXZvaWQgMDtjdDw9LVp8fHJ0PGN0P3V0PW10PWx0PWN0PTA6Y3Q8PTA/KG10PS1jdCxjdD0wLHV0PWx0PU1hdGgubWluKHJ0LForY3QpKTpjdDw9cnQmJihtdD0wLHV0PWx0PU1hdGgubWluKFoscnQtY3QpKSxsdDw9MHx8ZHQ8PS1GfHxzdDxkdD9mdD1ndD1wdD1kdD0wOmR0PD0wPyhndD0tZHQsZHQ9MCxmdD1wdD1NYXRoLm1pbihzdCxGK2R0KSk6ZHQ8PXN0JiYoZ3Q9MCxmdD1wdD1NYXRoLm1pbihGLHN0LWR0KSk7dmFyIHZ0PVtjdCxkdCxsdCxwdF07aWYoMDx1dCYmMDxmdCl7dmFyIHd0PXR0L1o7dnQucHVzaChtdCp3dCxndCp3dCx1dCp3dCxmdCp3dCl9cmV0dXJuIGF0LmRyYXdJbWFnZS5hcHBseShhdCxbUF0uY29uY2F0KHh0KHZ0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5mbG9vcihidCh0KSl9KSkpKSxldH0sc2V0QXNwZWN0UmF0aW86ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5vcHRpb25zO3JldHVybiB0aGlzLmRpc2FibGVkfHxaKHQpfHwoaS5hc3BlY3RSYXRpbz1NYXRoLm1heCgwLHQpfHxOYU4sdGhpcy5yZWFkeSYmKHRoaXMuaW5pdENyb3BCb3goKSx0aGlzLmNyb3BwZWQmJnRoaXMucmVuZGVyQ3JvcEJveCgpKSksdGhpc30sc2V0RHJhZ01vZGU6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5vcHRpb25zLGU9dGhpcy5kcmFnQm94LGE9dGhpcy5mYWNlO2lmKHRoaXMucmVhZHkmJiF0aGlzLmRpc2FibGVkKXt2YXIgbj10PT09cyxvPWkubW92YWJsZSYmdD09PWM7dD1ufHxvP3Q6dSxpLmRyYWdNb2RlPXQsY3QoZSxtLHQpLG90KGUscixuKSxvdChlLHAsbyksaS5jcm9wQm94TW92YWJsZXx8KGN0KGEsbSx0KSxvdChhLHIsbiksb3QoYSxwLG8pKX1yZXR1cm4gdGhpc319LFh0PWguQ3JvcHBlcixSdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIGk9MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O2lmKGZ1bmN0aW9uKHQsaSl7aWYoISh0IGluc3RhbmNlb2YgaSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSwhdHx8IVAudGVzdCh0LnRhZ05hbWUpKXRocm93IG5ldyBFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiA8aW1nPiBvciA8Y2FudmFzPiBlbGVtZW50LlwiKTt0aGlzLmVsZW1lbnQ9dCx0aGlzLm9wdGlvbnM9Xyh7fSxxLFYoaSkmJmkpLHRoaXMuY3JvcHBlZD0hMSx0aGlzLmRpc2FibGVkPSExLHRoaXMucG9pbnRlcnM9e30sdGhpcy5yZWFkeT0hMSx0aGlzLnJlbG9hZGluZz0hMSx0aGlzLnJlcGxhY2VkPSExLHRoaXMuc2l6ZWQ9ITEsdGhpcy5zaXppbmc9ITEsdGhpcy5pbml0KCl9cmV0dXJuICQoZSxbe2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWxlbWVudCxpPXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLGU9dm9pZCAwO2lmKCFzdCh0LGQpKXtpZihjdCh0LGQsdGhpcyksXCJpbWdcIj09PWkpe2lmKHRoaXMuaXNJbWc9ITAsZT10LmdldEF0dHJpYnV0ZShcInNyY1wiKXx8XCJcIiwhKHRoaXMub3JpZ2luYWxVcmw9ZSkpcmV0dXJuO2U9dC5zcmN9ZWxzZVwiY2FudmFzXCI9PT1pJiZ3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQmJihlPXQudG9EYXRhVVJMKCkpO3RoaXMubG9hZChlKX19fSx7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXM7aWYodCl7dGhpcy51cmw9dCx0aGlzLmltYWdlRGF0YT17fTt2YXIgZT10aGlzLmVsZW1lbnQsYT10aGlzLm9wdGlvbnM7aWYoYS5yb3RhdGFibGV8fGEuc2NhbGFibGV8fChhLmNoZWNrT3JpZW50YXRpb249ITEpLGEuY2hlY2tPcmllbnRhdGlvbiYmd2luZG93LkFycmF5QnVmZmVyKWlmKFUudGVzdCh0KSlqLnRlc3QodCk/dGhpcy5yZWFkKChuPXQucmVwbGFjZShUdCxcIlwiKSxvPWF0b2IobiksaD1uZXcgQXJyYXlCdWZmZXIoby5sZW5ndGgpLEoocj1uZXcgVWludDhBcnJheShoKSxmdW5jdGlvbih0LGkpe3JbaV09by5jaGFyQ29kZUF0KGkpfSksaCkpOnRoaXMuY2xvbmUoKTtlbHNle3ZhciBuLG8saCxyLHM9bmV3IFhNTEh0dHBSZXF1ZXN0O3RoaXMucmVsb2FkaW5nPSEwLHRoaXMueGhyPXM7dmFyIGM9ZnVuY3Rpb24oKXtpLnJlbG9hZGluZz0hMSxpLnhocj1udWxsfTtzLm9udGltZW91dD1jLHMub25hYm9ydD1jLHMub25lcnJvcj1mdW5jdGlvbigpe2MoKSxpLmNsb25lKCl9LHMub25sb2FkPWZ1bmN0aW9uKCl7YygpLGkucmVhZChzLnJlc3BvbnNlKX0sYS5jaGVja0Nyb3NzT3JpZ2luJiZ5dCh0KSYmZS5jcm9zc09yaWdpbiYmKHQ9TXQodCkpLHMub3BlbihcImdldFwiLHQpLHMucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixzLndpdGhDcmVkZW50aWFscz1cInVzZS1jcmVkZW50aWFsc1wiPT09ZS5jcm9zc09yaWdpbixzLnNlbmQoKX1lbHNlIHRoaXMuY2xvbmUoKX19fSx7a2V5OlwicmVhZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBpLGUsYSxuPXRoaXMub3B0aW9ucyxvPXRoaXMuaW1hZ2VEYXRhLGg9V3QodCkscj0wLHM9MSxjPTE7aWYoMTxoKXt0aGlzLnVybD0oaT1cImltYWdlL2pwZWdcIixlPW5ldyBVaW50OEFycmF5KHQpLGE9XCJcIixHKGUuZm9yRWFjaCk/ZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2ErPUV0KHQpfSk6SihlLGZ1bmN0aW9uKHQpe2ErPUV0KHQpfSksXCJkYXRhOlwiK2krXCI7YmFzZTY0LFwiK2J0b2EoYSkpO3ZhciBkPWZ1bmN0aW9uKHQpe3ZhciBpPTAsZT0xLGE9MTtzd2l0Y2godCl7Y2FzZSAyOmU9LTE7YnJlYWs7Y2FzZSAzOmk9LTE4MDticmVhaztjYXNlIDQ6YT0tMTticmVhaztjYXNlIDU6aT05MCxhPS0xO2JyZWFrO2Nhc2UgNjppPTkwO2JyZWFrO2Nhc2UgNzppPTkwLGU9LTE7YnJlYWs7Y2FzZSA4Omk9LTkwfXJldHVybntyb3RhdGU6aSxzY2FsZVg6ZSxzY2FsZVk6YX19KGgpO3I9ZC5yb3RhdGUscz1kLnNjYWxlWCxjPWQuc2NhbGVZfW4ucm90YXRhYmxlJiYoby5yb3RhdGU9ciksbi5zY2FsYWJsZSYmKG8uc2NhbGVYPXMsby5zY2FsZVk9YyksdGhpcy5jbG9uZSgpfX0se2tleTpcImNsb25lXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVsZW1lbnQsaT10aGlzLnVybCxlPXZvaWQgMCxhPXZvaWQgMDt0aGlzLm9wdGlvbnMuY2hlY2tDcm9zc09yaWdpbiYmeXQoaSkmJigoZT10LmNyb3NzT3JpZ2luKT9hPWk6KGU9XCJhbm9ueW1vdXNcIixhPU10KGkpKSksdGhpcy5jcm9zc09yaWdpbj1lLHRoaXMuY3Jvc3NPcmlnaW5Vcmw9YTt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO2UmJihuLmNyb3NzT3JpZ2luPWUpLG4uc3JjPWF8fGksKHRoaXMuaW1hZ2U9bikub25sb2FkPXRoaXMuc3RhcnQuYmluZCh0aGlzKSxuLm9uZXJyb3I9dGhpcy5zdG9wLmJpbmQodGhpcyksYXQobixsKSx0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG4sdC5uZXh0U2libGluZyl9fSx7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLmlzSW1nP3RoaXMuZWxlbWVudDp0aGlzLmltYWdlO3Qub25sb2FkPW51bGwsdC5vbmVycm9yPW51bGwsdGhpcy5zaXppbmc9ITA7dmFyIGk9aC5uYXZpZ2F0b3ImJi8oTWFjaW50b3NofGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdC9pLnRlc3QoaC5uYXZpZ2F0b3IudXNlckFnZW50KSxhPWZ1bmN0aW9uKHQsaSl7XyhlLmltYWdlRGF0YSx7bmF0dXJhbFdpZHRoOnQsbmF0dXJhbEhlaWdodDppLGFzcGVjdFJhdGlvOnQvaX0pLGUuc2l6aW5nPSExLGUuc2l6ZWQ9ITAsZS5idWlsZCgpfTtpZighdC5uYXR1cmFsV2lkdGh8fGkpe3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiksbz1kb2N1bWVudC5ib2R5fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7KHRoaXMuc2l6aW5nSW1hZ2U9bikub25sb2FkPWZ1bmN0aW9uKCl7YShuLndpZHRoLG4uaGVpZ2h0KSxpfHxvLnJlbW92ZUNoaWxkKG4pfSxuLnNyYz10LnNyYyxpfHwobi5zdHlsZS5jc3NUZXh0PVwibGVmdDowO21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnQ7bWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50O21pbi1oZWlnaHQ6MCFpbXBvcnRhbnQ7bWluLXdpZHRoOjAhaW1wb3J0YW50O29wYWNpdHk6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt6LWluZGV4Oi0xO1wiLG8uYXBwZW5kQ2hpbGQobikpfWVsc2UgYSh0Lm5hdHVyYWxXaWR0aCx0Lm5hdHVyYWxIZWlnaHQpfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuaW1hZ2U7dC5vbmxvYWQ9bnVsbCx0Lm9uZXJyb3I9bnVsbCx0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCksdGhpcy5pbWFnZT1udWxsfX0se2tleTpcImJ1aWxkXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLnNpemVkJiYhdGhpcy5yZWFkeSl7dmFyIHQ9dGhpcy5lbGVtZW50LGk9dGhpcy5vcHRpb25zLGU9dGhpcy5pbWFnZSxhPXQucGFyZW50Tm9kZSxuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7bi5pbm5lckhUTUw9JzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNvbnRhaW5lclwiIHRvdWNoLWFjdGlvbj1cIm5vbmVcIj48ZGl2IGNsYXNzPVwiY3JvcHBlci13cmFwLWJveFwiPjxkaXYgY2xhc3M9XCJjcm9wcGVyLWNhbnZhc1wiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJjcm9wcGVyLWRyYWctYm94XCI+PC9kaXY+PGRpdiBjbGFzcz1cImNyb3BwZXItY3JvcC1ib3hcIj48c3BhbiBjbGFzcz1cImNyb3BwZXItdmlldy1ib3hcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjcm9wcGVyLWRhc2hlZCBkYXNoZWQtaFwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImNyb3BwZXItZGFzaGVkIGRhc2hlZC12XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiY3JvcHBlci1jZW50ZXJcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjcm9wcGVyLWZhY2VcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS1lXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cImVcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS1uXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm5cIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS13XCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIndcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS1zXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cInNcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LWVcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwiZVwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtblwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJuXCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC13XCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIndcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LXNcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwic1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtbmVcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwibmVcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LW53XCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm53XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1zd1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzd1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtc2VcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwic2VcIj48L3NwYW4+PC9kaXY+PC9kaXY+Jzt2YXIgbz1uLnF1ZXJ5U2VsZWN0b3IoXCIuXCIrZCtcIi1jb250YWluZXJcIiksaD1vLnF1ZXJ5U2VsZWN0b3IoXCIuXCIrZCtcIi1jYW52YXNcIikscj1vLnF1ZXJ5U2VsZWN0b3IoXCIuXCIrZCtcIi1kcmFnLWJveFwiKSxzPW8ucXVlcnlTZWxlY3RvcihcIi5cIitkK1wiLWNyb3AtYm94XCIpLGM9cy5xdWVyeVNlbGVjdG9yKFwiLlwiK2QrXCItZmFjZVwiKTt0aGlzLmNvbnRhaW5lcj1hLHRoaXMuY3JvcHBlcj1vLHRoaXMuY2FudmFzPWgsdGhpcy5kcmFnQm94PXIsdGhpcy5jcm9wQm94PXMsdGhpcy52aWV3Qm94PW8ucXVlcnlTZWxlY3RvcihcIi5cIitkK1wiLXZpZXctYm94XCIpLHRoaXMuZmFjZT1jLGguYXBwZW5kQ2hpbGQoZSksYXQodCxTKSxhLmluc2VydEJlZm9yZShvLHQubmV4dFNpYmxpbmcpLHRoaXMuaXNJbWd8fG50KGUsbCksdGhpcy5pbml0UHJldmlldygpLHRoaXMuYmluZCgpLGkuaW5pdGlhbEFzcGVjdFJhdGlvPU1hdGgubWF4KDAsaS5pbml0aWFsQXNwZWN0UmF0aW8pfHxOYU4saS5hc3BlY3RSYXRpbz1NYXRoLm1heCgwLGkuYXNwZWN0UmF0aW8pfHxOYU4saS52aWV3TW9kZT1NYXRoLm1heCgwLE1hdGgubWluKDMsTWF0aC5yb3VuZChpLnZpZXdNb2RlKSkpfHwwLGF0KHMsUyksaS5ndWlkZXN8fGF0KHMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShkK1wiLWRhc2hlZFwiKSxTKSxpLmNlbnRlcnx8YXQocy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGQrXCItY2VudGVyXCIpLFMpLGkuYmFja2dyb3VuZCYmYXQobyxkK1wiLWJnXCIpLGkuaGlnaGxpZ2h0fHxhdChjLFwiY3JvcHBlci1pbnZpc2libGVcIiksaS5jcm9wQm94TW92YWJsZSYmKGF0KGMscCksY3QoYyxtLGspKSxpLmNyb3BCb3hSZXNpemFibGV8fChhdChzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZCtcIi1saW5lXCIpLFMpLGF0KHMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShkK1wiLXBvaW50XCIpLFMpKSx0aGlzLnJlbmRlcigpLHRoaXMucmVhZHk9ITAsdGhpcy5zZXREcmFnTW9kZShpLmRyYWdNb2RlKSxpLmF1dG9Dcm9wJiZ0aGlzLmNyb3AoKSx0aGlzLnNldERhdGEoaS5kYXRhKSxHKGkucmVhZHkpJiZndCh0LEMsaS5yZWFkeSx7b25jZTohMH0pLHV0KHQsQyl9fX0se2tleTpcInVuYnVpbGRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucmVhZHkmJih0aGlzLnJlYWR5PSExLHRoaXMudW5iaW5kKCksdGhpcy5yZXNldFByZXZpZXcoKSx0aGlzLmNyb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNyb3BwZXIpLG50KHRoaXMuZWxlbWVudCxTKSl9fSx7a2V5OlwidW5jcmVhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucmVhZHk/KHRoaXMudW5idWlsZCgpLHRoaXMucmVhZHk9ITEsdGhpcy5jcm9wcGVkPSExKTp0aGlzLnNpemluZz8odGhpcy5zaXppbmdJbWFnZS5vbmxvYWQ9bnVsbCx0aGlzLnNpemluZz0hMSx0aGlzLnNpemVkPSExKTp0aGlzLnJlbG9hZGluZz90aGlzLnhoci5hYm9ydCgpOnRoaXMuaW1hZ2UmJnRoaXMuc3RvcCgpfX1dLFt7a2V5Olwibm9Db25mbGljdFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5Dcm9wcGVyPVh0LGV9fSx7a2V5Olwic2V0RGVmYXVsdHNcIix2YWx1ZTpmdW5jdGlvbih0KXtfKHEsVih0KSYmdCl9fV0pLGV9KCk7cmV0dXJuIF8oUnQucHJvdG90eXBlLE50LEh0LEx0LE90LHp0LFl0KSxSdH0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/cropperjs/dist/cropper.min.js\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/cropperjs/dist/cropper.min.css":
/*!*******************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/cropperjs/dist/cropper.min.css ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/*!\\n * Cropper.js v1.4.1\\n * https://fengyuanchen.github.io/cropperjs\\n *\\n * Copyright 2015-present Chen Fengyuan\\n * Released under the MIT license\\n *\\n * Date: 2018-07-15T09:54:43.167Z\\n */.cropper-container{-moz-user-select:none;-ms-touch-action:none;-ms-user-select:none;-webkit-user-select:none;direction:ltr;font-size:0;line-height:0;position:relative;touch-action:none;user-select:none}.cropper-container img{display:block;height:100%;image-orientation:0deg;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;width:100%}.cropper-canvas,.cropper-crop-box,.cropper-drag-box,.cropper-modal,.cropper-wrap-box{bottom:0;left:0;position:absolute;right:0;top:0}.cropper-canvas,.cropper-wrap-box{overflow:hidden}.cropper-drag-box{background-color:#fff;opacity:0}.cropper-modal{background-color:#000;opacity:.5}.cropper-view-box{display:block;height:100%;outline:1px solid #39f;outline-color:rgba(51,153,255,.75);overflow:hidden;width:100%}.cropper-dashed{border:0 dashed #eee;display:block;opacity:.5;position:absolute}.cropper-dashed.dashed-h{border-bottom-width:1px;border-top-width:1px;height:33.33333%;left:0;top:33.33333%;width:100%}.cropper-dashed.dashed-v{border-left-width:1px;border-right-width:1px;height:100%;left:33.33333%;top:0;width:33.33333%}.cropper-center{display:block;height:0;left:50%;opacity:.75;position:absolute;top:50%;width:0}.cropper-center:after,.cropper-center:before{background-color:#eee;content:\\\" \\\";display:block;position:absolute}.cropper-center:before{height:1px;left:-3px;top:0;width:7px}.cropper-center:after{height:7px;left:0;top:-3px;width:1px}.cropper-face,.cropper-line,.cropper-point{display:block;height:100%;opacity:.1;position:absolute;width:100%}.cropper-face{background-color:#fff;left:0;top:0}.cropper-line{background-color:#39f}.cropper-line.line-e{cursor:ew-resize;right:-3px;top:0;width:5px}.cropper-line.line-n{cursor:ns-resize;height:5px;left:0;top:-3px}.cropper-line.line-w{cursor:ew-resize;left:-3px;top:0;width:5px}.cropper-line.line-s{bottom:-3px;cursor:ns-resize;height:5px;left:0}.cropper-point{background-color:#39f;height:5px;opacity:.75;width:5px}.cropper-point.point-e{cursor:ew-resize;margin-top:-3px;right:-3px;top:50%}.cropper-point.point-n{cursor:ns-resize;left:50%;margin-left:-3px;top:-3px}.cropper-point.point-w{cursor:ew-resize;left:-3px;margin-top:-3px;top:50%}.cropper-point.point-s{bottom:-3px;cursor:s-resize;left:50%;margin-left:-3px}.cropper-point.point-ne{cursor:nesw-resize;right:-3px;top:-3px}.cropper-point.point-nw{cursor:nwse-resize;left:-3px;top:-3px}.cropper-point.point-sw{bottom:-3px;cursor:nesw-resize;left:-3px}.cropper-point.point-se{bottom:-3px;cursor:nwse-resize;height:20px;opacity:1;right:-3px;width:20px}@media (min-width:768px){.cropper-point.point-se{height:15px;width:15px}}@media (min-width:992px){.cropper-point.point-se{height:10px;width:10px}}@media (min-width:1200px){.cropper-point.point-se{height:5px;opacity:.75;width:5px}}.cropper-point.point-se:before{background-color:#39f;bottom:-50%;content:\\\" \\\";display:block;height:200%;opacity:0;position:absolute;right:-50%;width:200%}.cropper-invisible{opacity:0}.cropper-bg{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC\\\")}.cropper-hide{display:block;height:0;position:absolute;width:0}.cropper-hidden{display:none!important}.cropper-move{cursor:move}.cropper-crop{cursor:crosshair}.cropper-disabled .cropper-drag-box,.cropper-disabled .cropper-face,.cropper-disabled .cropper-line,.cropper-disabled .cropper-point{cursor:not-allowed}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5taW4uY3NzPzA2YWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsbUZBQWtDO0FBQ3JFOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyx3TkFBd04sc0JBQXNCLHNCQUFzQixxQkFBcUIseUJBQXlCLGNBQWMsWUFBWSxjQUFjLGtCQUFrQixrQkFBa0IsaUJBQWlCLHVCQUF1QixjQUFjLFlBQVksdUJBQXVCLDBCQUEwQix5QkFBeUIsdUJBQXVCLHNCQUFzQixXQUFXLHFGQUFxRixTQUFTLE9BQU8sa0JBQWtCLFFBQVEsTUFBTSxrQ0FBa0MsZ0JBQWdCLGtCQUFrQixzQkFBc0IsVUFBVSxlQUFlLHNCQUFzQixXQUFXLGtCQUFrQixjQUFjLFlBQVksdUJBQXVCLG1DQUFtQyxnQkFBZ0IsV0FBVyxnQkFBZ0IscUJBQXFCLGNBQWMsV0FBVyxrQkFBa0IseUJBQXlCLHdCQUF3QixxQkFBcUIsaUJBQWlCLE9BQU8sY0FBYyxXQUFXLHlCQUF5QixzQkFBc0IsdUJBQXVCLFlBQVksZUFBZSxNQUFNLGdCQUFnQixnQkFBZ0IsY0FBYyxTQUFTLFNBQVMsWUFBWSxrQkFBa0IsUUFBUSxRQUFRLDZDQUE2QyxzQkFBc0IsY0FBYyxjQUFjLGtCQUFrQix1QkFBdUIsV0FBVyxVQUFVLE1BQU0sVUFBVSxzQkFBc0IsV0FBVyxPQUFPLFNBQVMsVUFBVSwyQ0FBMkMsY0FBYyxZQUFZLFdBQVcsa0JBQWtCLFdBQVcsY0FBYyxzQkFBc0IsT0FBTyxNQUFNLGNBQWMsc0JBQXNCLHFCQUFxQixpQkFBaUIsV0FBVyxNQUFNLFVBQVUscUJBQXFCLGlCQUFpQixXQUFXLE9BQU8sU0FBUyxxQkFBcUIsaUJBQWlCLFVBQVUsTUFBTSxVQUFVLHFCQUFxQixZQUFZLGlCQUFpQixXQUFXLE9BQU8sZUFBZSxzQkFBc0IsV0FBVyxZQUFZLFVBQVUsdUJBQXVCLGlCQUFpQixnQkFBZ0IsV0FBVyxRQUFRLHVCQUF1QixpQkFBaUIsU0FBUyxpQkFBaUIsU0FBUyx1QkFBdUIsaUJBQWlCLFVBQVUsZ0JBQWdCLFFBQVEsdUJBQXVCLFlBQVksZ0JBQWdCLFNBQVMsaUJBQWlCLHdCQUF3QixtQkFBbUIsV0FBVyxTQUFTLHdCQUF3QixtQkFBbUIsVUFBVSxTQUFTLHdCQUF3QixZQUFZLG1CQUFtQixVQUFVLHdCQUF3QixZQUFZLG1CQUFtQixZQUFZLFVBQVUsV0FBVyxXQUFXLHlCQUF5Qix3QkFBd0IsWUFBWSxZQUFZLHlCQUF5Qix3QkFBd0IsWUFBWSxZQUFZLDBCQUEwQix3QkFBd0IsV0FBVyxZQUFZLFdBQVcsK0JBQStCLHNCQUFzQixZQUFZLGNBQWMsY0FBYyxZQUFZLFVBQVUsa0JBQWtCLFdBQVcsV0FBVyxtQkFBbUIsVUFBVSxZQUFZLHNDQUFzQywyT0FBMk8sY0FBYyxjQUFjLFNBQVMsa0JBQWtCLFFBQVEsZ0JBQWdCLHVCQUF1QixjQUFjLFlBQVksY0FBYyxpQkFBaUIscUlBQXFJLG1CQUFtQjs7QUFFcnNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5taW4uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcbiAqIENyb3BwZXIuanMgdjEuNC4xXFxuICogaHR0cHM6Ly9mZW5neXVhbmNoZW4uZ2l0aHViLmlvL2Nyb3BwZXJqc1xcbiAqXFxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCBDaGVuIEZlbmd5dWFuXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE4LTA3LTE1VDA5OjU0OjQzLjE2N1pcXG4gKi8uY3JvcHBlci1jb250YWluZXJ7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy10b3VjaC1hY3Rpb246bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7ZGlyZWN0aW9uOmx0cjtmb250LXNpemU6MDtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3RvdWNoLWFjdGlvbjpub25lO3VzZXItc2VsZWN0Om5vbmV9LmNyb3BwZXItY29udGFpbmVyIGltZ3tkaXNwbGF5OmJsb2NrO2hlaWdodDoxMDAlO2ltYWdlLW9yaWVudGF0aW9uOjBkZWc7bWF4LWhlaWdodDpub25lIWltcG9ydGFudDttYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnQ7bWluLWhlaWdodDowIWltcG9ydGFudDttaW4td2lkdGg6MCFpbXBvcnRhbnQ7d2lkdGg6MTAwJX0uY3JvcHBlci1jYW52YXMsLmNyb3BwZXItY3JvcC1ib3gsLmNyb3BwZXItZHJhZy1ib3gsLmNyb3BwZXItbW9kYWwsLmNyb3BwZXItd3JhcC1ib3h7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmNyb3BwZXItY2FudmFzLC5jcm9wcGVyLXdyYXAtYm94e292ZXJmbG93OmhpZGRlbn0uY3JvcHBlci1kcmFnLWJveHtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7b3BhY2l0eTowfS5jcm9wcGVyLW1vZGFse2JhY2tncm91bmQtY29sb3I6IzAwMDtvcGFjaXR5Oi41fS5jcm9wcGVyLXZpZXctYm94e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMCU7b3V0bGluZToxcHggc29saWQgIzM5ZjtvdXRsaW5lLWNvbG9yOnJnYmEoNTEsMTUzLDI1NSwuNzUpO292ZXJmbG93OmhpZGRlbjt3aWR0aDoxMDAlfS5jcm9wcGVyLWRhc2hlZHtib3JkZXI6MCBkYXNoZWQgI2VlZTtkaXNwbGF5OmJsb2NrO29wYWNpdHk6LjU7cG9zaXRpb246YWJzb2x1dGV9LmNyb3BwZXItZGFzaGVkLmRhc2hlZC1oe2JvcmRlci1ib3R0b20td2lkdGg6MXB4O2JvcmRlci10b3Atd2lkdGg6MXB4O2hlaWdodDozMy4zMzMzMyU7bGVmdDowO3RvcDozMy4zMzMzMyU7d2lkdGg6MTAwJX0uY3JvcHBlci1kYXNoZWQuZGFzaGVkLXZ7Ym9yZGVyLWxlZnQtd2lkdGg6MXB4O2JvcmRlci1yaWdodC13aWR0aDoxcHg7aGVpZ2h0OjEwMCU7bGVmdDozMy4zMzMzMyU7dG9wOjA7d2lkdGg6MzMuMzMzMzMlfS5jcm9wcGVyLWNlbnRlcntkaXNwbGF5OmJsb2NrO2hlaWdodDowO2xlZnQ6NTAlO29wYWNpdHk6Ljc1O3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7d2lkdGg6MH0uY3JvcHBlci1jZW50ZXI6YWZ0ZXIsLmNyb3BwZXItY2VudGVyOmJlZm9yZXtiYWNrZ3JvdW5kLWNvbG9yOiNlZWU7Y29udGVudDpcXFwiIFxcXCI7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZX0uY3JvcHBlci1jZW50ZXI6YmVmb3Jle2hlaWdodDoxcHg7bGVmdDotM3B4O3RvcDowO3dpZHRoOjdweH0uY3JvcHBlci1jZW50ZXI6YWZ0ZXJ7aGVpZ2h0OjdweDtsZWZ0OjA7dG9wOi0zcHg7d2lkdGg6MXB4fS5jcm9wcGVyLWZhY2UsLmNyb3BwZXItbGluZSwuY3JvcHBlci1wb2ludHtkaXNwbGF5OmJsb2NrO2hlaWdodDoxMDAlO29wYWNpdHk6LjE7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJX0uY3JvcHBlci1mYWNle2JhY2tncm91bmQtY29sb3I6I2ZmZjtsZWZ0OjA7dG9wOjB9LmNyb3BwZXItbGluZXtiYWNrZ3JvdW5kLWNvbG9yOiMzOWZ9LmNyb3BwZXItbGluZS5saW5lLWV7Y3Vyc29yOmV3LXJlc2l6ZTtyaWdodDotM3B4O3RvcDowO3dpZHRoOjVweH0uY3JvcHBlci1saW5lLmxpbmUtbntjdXJzb3I6bnMtcmVzaXplO2hlaWdodDo1cHg7bGVmdDowO3RvcDotM3B4fS5jcm9wcGVyLWxpbmUubGluZS13e2N1cnNvcjpldy1yZXNpemU7bGVmdDotM3B4O3RvcDowO3dpZHRoOjVweH0uY3JvcHBlci1saW5lLmxpbmUtc3tib3R0b206LTNweDtjdXJzb3I6bnMtcmVzaXplO2hlaWdodDo1cHg7bGVmdDowfS5jcm9wcGVyLXBvaW50e2JhY2tncm91bmQtY29sb3I6IzM5ZjtoZWlnaHQ6NXB4O29wYWNpdHk6Ljc1O3dpZHRoOjVweH0uY3JvcHBlci1wb2ludC5wb2ludC1le2N1cnNvcjpldy1yZXNpemU7bWFyZ2luLXRvcDotM3B4O3JpZ2h0Oi0zcHg7dG9wOjUwJX0uY3JvcHBlci1wb2ludC5wb2ludC1ue2N1cnNvcjpucy1yZXNpemU7bGVmdDo1MCU7bWFyZ2luLWxlZnQ6LTNweDt0b3A6LTNweH0uY3JvcHBlci1wb2ludC5wb2ludC13e2N1cnNvcjpldy1yZXNpemU7bGVmdDotM3B4O21hcmdpbi10b3A6LTNweDt0b3A6NTAlfS5jcm9wcGVyLXBvaW50LnBvaW50LXN7Ym90dG9tOi0zcHg7Y3Vyc29yOnMtcmVzaXplO2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi0zcHh9LmNyb3BwZXItcG9pbnQucG9pbnQtbmV7Y3Vyc29yOm5lc3ctcmVzaXplO3JpZ2h0Oi0zcHg7dG9wOi0zcHh9LmNyb3BwZXItcG9pbnQucG9pbnQtbnd7Y3Vyc29yOm53c2UtcmVzaXplO2xlZnQ6LTNweDt0b3A6LTNweH0uY3JvcHBlci1wb2ludC5wb2ludC1zd3tib3R0b206LTNweDtjdXJzb3I6bmVzdy1yZXNpemU7bGVmdDotM3B4fS5jcm9wcGVyLXBvaW50LnBvaW50LXNle2JvdHRvbTotM3B4O2N1cnNvcjpud3NlLXJlc2l6ZTtoZWlnaHQ6MjBweDtvcGFjaXR5OjE7cmlnaHQ6LTNweDt3aWR0aDoyMHB4fUBtZWRpYSAobWluLXdpZHRoOjc2OHB4KXsuY3JvcHBlci1wb2ludC5wb2ludC1zZXtoZWlnaHQ6MTVweDt3aWR0aDoxNXB4fX1AbWVkaWEgKG1pbi13aWR0aDo5OTJweCl7LmNyb3BwZXItcG9pbnQucG9pbnQtc2V7aGVpZ2h0OjEwcHg7d2lkdGg6MTBweH19QG1lZGlhIChtaW4td2lkdGg6MTIwMHB4KXsuY3JvcHBlci1wb2ludC5wb2ludC1zZXtoZWlnaHQ6NXB4O29wYWNpdHk6Ljc1O3dpZHRoOjVweH19LmNyb3BwZXItcG9pbnQucG9pbnQtc2U6YmVmb3Jle2JhY2tncm91bmQtY29sb3I6IzM5Zjtib3R0b206LTUwJTtjb250ZW50OlxcXCIgXFxcIjtkaXNwbGF5OmJsb2NrO2hlaWdodDoyMDAlO29wYWNpdHk6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotNTAlO3dpZHRoOjIwMCV9LmNyb3BwZXItaW52aXNpYmxle29wYWNpdHk6MH0uY3JvcHBlci1iZ3tiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQVFNQUFBQWxQVzBpQUFBQUEzTkNTVlFJQ0FqYjRVL2dBQUFBQmxCTVZFWE16TXovLy8vVGpSVjJBQUFBQ1hCSVdYTUFBQXJyQUFBSzZ3R0NpdzFhQUFBQUhIUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkdhWEpsZDI5eWEzTWdRMU0yNkx5eWpBQUFBQkZKUkVGVUNKbGorTS9BZ0JWaEYvMFBBSDYvRC9Ia0R4T0dBQUFBQUVsRlRrU3VRbUNDXFxcIil9LmNyb3BwZXItaGlkZXtkaXNwbGF5OmJsb2NrO2hlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjB9LmNyb3BwZXItaGlkZGVue2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LmNyb3BwZXItbW92ZXtjdXJzb3I6bW92ZX0uY3JvcHBlci1jcm9we2N1cnNvcjpjcm9zc2hhaXJ9LmNyb3BwZXItZGlzYWJsZWQgLmNyb3BwZXItZHJhZy1ib3gsLmNyb3BwZXItZGlzYWJsZWQgLmNyb3BwZXItZmFjZSwuY3JvcHBlci1kaXNhYmxlZCAuY3JvcHBlci1saW5lLC5jcm9wcGVyLWRpc2FibGVkIC5jcm9wcGVyLXBvaW50e2N1cnNvcjpub3QtYWxsb3dlZH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./node_modules/cropperjs/dist/cropper.min.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx1REFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsS0FBSyxLQUF3QyxFQUFFLEVBRTdDOztBQUVGLFFBQVEsc0JBQWlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./src/puzzle-graphic.js":
/*!*******************************!*\
  !*** ./src/puzzle-graphic.js ***!
  \*******************************/
/*! exports provided: Grid, StartGrid, GoalGrid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Grid\", function() { return Grid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StartGrid\", function() { return StartGrid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GoalGrid\", function() { return GoalGrid; });\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// TODO: consider making Puzzle (driver for both grids) a separate class from script.js to make code cleaner\n// TODO: consider making minimum tile size (based on when hard to click and hard to read number overlay)\n// TODO: move all move related functionality in all files to separate file\nvar Move =\n/*#__PURE__*/\nfunction () {\n  function Move() {\n    _classCallCheck(this, Move);\n  }\n\n  _createClass(Move, null, [{\n    key: \"getFullName\",\n    value: function getFullName(move) {\n      var NAME_MAPPING = {\n        'l': 'left',\n        'r': 'right',\n        'u': 'up',\n        'd': 'down'\n      };\n      return NAME_MAPPING[move];\n    }\n  }]);\n\n  return Move;\n}(); // TODO: consider moving to separate file or algorithms file\n\n\nvar Util =\n/*#__PURE__*/\nfunction () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, null, [{\n    key: \"countInversions\",\n    // counts number inversions in array ignoring emptyPos index\n    // NOTE: # inversions can = 0 without being at goal state because emptyPos not considered\n    value: function countInversions(arr) {\n      return Util.mergeSort(arr);\n    }\n  }, {\n    key: \"mergeSort\",\n    value: function mergeSort(arr) {\n      return Util._mergeSort(Uint16Array.from(arr), new Uint16Array(arr.length), 0, arr.length - 1);\n    } // temp is auxiliary memory for _mergeSort (sorted elements get stored there)\n    // temp passed between calls to reduce memory allocation\n    // (not strictly necessary, could just make new [] in _merge())\n    // WARNING: arr and temp are both modified by _mergeSort()\n\n  }, {\n    key: \"_mergeSort\",\n    value: function _mergeSort(arr, temp, left, right) {\n      var numInversions = 0;\n\n      if (right > left) {\n        var mid = Math.floor((left + right) / 2);\n        numInversions += Util._mergeSort(arr, temp, left, mid);\n        numInversions += Util._mergeSort(arr, temp, mid + 1, right);\n        numInversions += Util._merge(arr, temp, left, mid, right);\n      }\n\n      return numInversions;\n    }\n  }, {\n    key: \"_merge\",\n    value: function _merge(arr, temp, left, mid, right) {\n      var numInversions = 0; // i and j move along 2 sorted arrays\n      // k moves along output array\n\n      var i = left,\n          j = mid + 1,\n          k = left;\n\n      while (i <= mid && j <= right) {\n        if (arr[i] <= arr[j]) {\n          // NOTE: k++ returns k before incrementing, while ++k returns k after incrementing\n          temp[k++] = arr[i++];\n        } else {\n          temp[k++] = arr[j++]; // since left array is sorted, if arr[j] < arr[i], arr[j] < a[i to mid]\n\n          numInversions += mid - i + 1;\n        }\n      } // adds remaining array values into temp (one array could run out before another)\n\n\n      while (i <= mid) {\n        temp[k++] = arr[i++];\n      }\n\n      while (j <= right) {\n        temp[k++] = arr[j++];\n      }\n\n      for (i = left; i <= right; i++) {\n        arr[i] = temp[i];\n      }\n\n      return numInversions;\n    }\n  }]);\n\n  return Util;\n}();\n\nvar Grid =\n/*#__PURE__*/\nfunction () {\n  function Grid(parent, x, y, numRows, numCols) {\n    var _ref = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {},\n        _ref$height = _ref.height,\n        height = _ref$height === void 0 ? 500 : _ref$height,\n        _ref$width = _ref.width,\n        width = _ref$width === void 0 ? 500 : _ref$width,\n        _ref$imageSrc = _ref.imageSrc,\n        imageSrc = _ref$imageSrc === void 0 ? null : _ref$imageSrc,\n        _ref$hasTileUnderlay = _ref.hasTileUnderlay,\n        hasTileUnderlay = _ref$hasTileUnderlay === void 0 ? false : _ref$hasTileUnderlay;\n\n    _classCallCheck(this, Grid);\n\n    // parent svg for Grid to be placed in\n    this.parent = parent instanceof d3.selection ? parent : d3.select(parent);\n    this.x = x;\n    this.y = y;\n    this.numRows = numRows;\n    this.numCols = numCols;\n    this.height = height;\n    this.width = width;\n    this.imageSrc = imageSrc;\n    this.hasTileUnderlay = hasTileUnderlay;\n    this.tileHeight = height / numRows;\n    this.tileWidth = width / numCols; // TODO: consider renaming to _emptyTiles (since contains tileContainer doms)\n\n    this._emptyTiles = new Set(); // NOTE: could be transformed into single variable tracking single selection\n    // set used in case multiple selections are desired later\n\n    this.selectedTiles = new Set();\n    this.container = null;\n    this.outline = null;\n    this.tileContainers = null;\n    this.tileImageContainers = null;\n    this.tileOutlines = null;\n    this.removeIcons = null;\n    this.tileNumbers = null;\n    this.tileOverlays = null;\n    this.tileUnderlays = null;\n    this.numberOverlay = false; // governs whether hovering over tile displays delete overlay option\n\n    this.deleteOverlay = true;\n  } // accepts tileContainer DOM/d3 selection, index \n\n\n  _createClass(Grid, [{\n    key: \"hideTile\",\n    // hides tile EXCEPT for overlay\n    // args = tileContainer DOM Element/d3 selection OR index\n    value: function hideTile() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var tile = this._convertInputFormat(args);\n\n      tile.select('.tile-image-container').style('visibility', 'hidden');\n    } // shows tile EXCEPT for overlay\n    // args = tileContainer DOM Element/d3 selection OR index\n\n  }, {\n    key: \"showTile\",\n    value: function showTile() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var tile = this._convertInputFormat(args);\n\n      tile.select('.tile-image-container').style('visibility', 'visible');\n    } // args = tileContainer DOM Element/d3 selection OR index\n\n  }, {\n    key: \"hideOverlay\",\n    value: function hideOverlay() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var tile = this._convertInputFormat(args);\n\n      tile.select('.tile-overlay').classed('delete-overlay', false).classed('select-overlay', false);\n    } // args = tileContainer DOM Element/d3 selection OR index\n\n  }, {\n    key: \"showOverlay\",\n    value: function showOverlay() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var tile = this._convertInputFormat(args);\n\n      tile.select('.tile-overlay').classed('delete-overlay', this.deleteOverlay).classed('select-overlay', !this.deleteOverlay);\n    }\n  }, {\n    key: \"hideNumberOverlay\",\n    value: function hideNumberOverlay() {\n      this.tileNumberContainers.style('display', 'none');\n      this.numberOverlay = false;\n    }\n  }, {\n    key: \"showNumberOverlay\",\n    value: function showNumberOverlay() {\n      this.tileNumberContainers.style('display', '');\n      this.numberOverlay = true;\n    }\n  }, {\n    key: \"showDeleteOverlay\",\n    value: function showDeleteOverlay() {\n      this.tileOverlays.classed('delete-overlay', true);\n      this.tileOverlays.classed('select-overlay', false);\n      this.deleteOverlay = true;\n    }\n  }, {\n    key: \"hideDeleteOverlay\",\n    value: function hideDeleteOverlay() {\n      this.tileOverlays.classed('delete-overlay', false);\n      this.tileOverlays.classed('select-overlay', true);\n      this.deleteOverlay = false;\n    }\n  }, {\n    key: \"toggleTileOverlay\",\n    value: function toggleTileOverlay() {\n      this.deleteOverlay = !this.deleteOverlay;\n    }\n  }, {\n    key: \"toggleNumberOverlay\",\n    value: function toggleNumberOverlay() {\n      this.numberOverlay ? this.hideNumberOverlay() : this.showNumberOverlay();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var data = this.generateGridData();\n      this.container = this.parent.datum(this).append('g').classed('grid-container', true).attr('tabindex', 0);\n      this.outline = this.container.append('rect').attr('x', this.x).attr('y', this.y).attr('width', this.width).attr('height', this.height).classed('puzzle-outline', true);\n\n      if (this.hasTileUnderlay) {\n        var underlayData = data.map(function (d) {\n          return Object.assign(d.cell);\n        }); // selects null so grid-outline doesn't get discarded in enter and updated with incorrect data\n        // NOTE: not underneath tileContainers as underlay should not move with tile\n        // also NOT underneath a parent <g> container of tileContainer as movement would\n        // make underlay mismatch sibling tileContainer\n\n        this.tileUnderlays = this.container.selectAll(null).data(underlayData).enter().append('rect').attr('x', function (d) {\n          return d.x;\n        }).attr('y', function (d) {\n          return d.y;\n        }).attr('width', this.tileWidth).attr('height', this.tileHeight).classed('tile-underlay', true);\n      }\n\n      this.tileContainers = this.container.selectAll('svg').data(data).enter().append('svg').attr('width', this.tileWidth).attr('height', this.tileHeight).attr('x', function (d) {\n        return d.cell.x;\n      }).attr('y', function (d) {\n        return d.cell.y;\n      }).classed('tile-container', true).datum(function (d) {\n        d.tile = d3.select(this);\n        return d;\n      });\n      this.tileImageContainers = this.tileContainers.append('g').classed('tile-image-container', true);\n\n      if (this.imageSrc) {\n        var images = this.tileImageContainers.append('image').attr('width', this.width).attr('height', this.height).attr('x', function (d) {\n          return d.img.offsetX;\n        }).attr('y', function (d) {\n          return d.img.offsetY;\n        }).attr('xlink:href', this.imageSrc).attr('preserveAspectRatio', 'none');\n      } else {\n        this.tileContainers.each(function (d) {\n          d.grid.hideTile(this);\n        });\n        this._emptyTiles = new Set(this.tileContainers.nodes());\n      }\n\n      this.tileOutlines = this.tileImageContainers.append('rect').attr('width', this.tileWidth).attr('height', this.tileHeight).classed('tile-outline', true); // functionality could be folded into tileOutlines, but distinct to reduce confusion\n      // NOTE: NOT under tileImageContainer as visibility can be independent of tile image visibility\n\n      this.tileOverlays = this.tileContainers.append('rect').attr('width', this.tileWidth).attr('height', this.tileHeight).classed('tile-overlay', true) // NOTE: mouseover used instead of css hover to allow greater control\n      .on('mouseover', function (d) {\n        var overlay = d3.select(this);\n        overlay.classed('delete-overlay', d.grid.deleteOverlay && !d.grid.hasEmptyTile(d.tile));\n        overlay.classed('select-overlay', !d.grid.deleteOverlay);\n      }).on('mouseout', function (d) {\n        var overlay = d3.select(this);\n        overlay.classed('delete-overlay', false); // only remove select-overlay if tile not selected\n\n        if (!d.grid.selectedTiles.has(d.tile.node())) {\n          overlay.classed('select-overlay', false);\n        }\n      }); // number overlay hidden by default\n\n      this.tileNumberContainers = this.tileImageContainers.append('g').classed('tile-number-container', true).style('display', this.numberOverlay ? '' : 'none');\n      this.tileNumberBackground = this.tileNumberContainers.append('rect').attr('width', this.tileWidth).attr('height', this.tileHeight).classed('tile-number-background', true);\n      this.tileNumbers = this.tileNumberContainers.append('text').attr('x', '50%').attr('y', '50%').text(function (d) {\n        return d.cell.ind + 1;\n      }).classed('tile-number', true);\n      return this;\n    } // returns tile that is overlapping, or null if no tile found\n\n  }, {\n    key: \"getOverlappingTile\",\n    value: function getOverlappingTile(x, y) {\n      if (x < this.x || x > this.x + this.width || y < this.y || y > this.y + this.height) {\n        return null;\n      }\n\n      var _ref2 = [this.getRowFromY(y), this.getColumnFromX(x)],\n          row = _ref2[0],\n          col = _ref2[1];\n      var ind = this.getIndexFromTileCoord(row, col);\n      var overlap = this.tileContainers.filter(function (d) {\n        return d.cell.ind === ind;\n      });\n      return overlap.empty() ? null : overlap;\n    } // TODO: consolidate section into Move class\n    // TODO: probably just have each form of data convert to selected intermediary to reduce function bloat\n\n  }, {\n    key: \"getRowFromY\",\n    value: function getRowFromY(y) {\n      return Math.floor((y - this.y) / this.tileHeight);\n    }\n  }, {\n    key: \"getRowFromIndex\",\n    value: function getRowFromIndex(ind) {\n      return Math.floor(ind / this.numCols);\n    }\n  }, {\n    key: \"getColumnFromX\",\n    value: function getColumnFromX(x) {\n      return Math.floor((x - this.x) / this.tileWidth);\n    }\n  }, {\n    key: \"getColumnFromIndex\",\n    value: function getColumnFromIndex(ind) {\n      return ind % this.numCols;\n    }\n  }, {\n    key: \"getTileCoordFromIndex\",\n    value: function getTileCoordFromIndex(ind) {\n      return [this.getRowFromIndex(ind), this.getColumnFromIndex(ind)];\n    }\n  }, {\n    key: \"getIndexFromTileCoord\",\n    value: function getIndexFromTileCoord(row, col) {\n      return row * this.numCols + col;\n    }\n  }, {\n    key: \"getIndexFromCoord\",\n    value: function getIndexFromCoord(x, y) {\n      return this.getRowFromY(y) * this.numCols + this.getColumnFromX(x);\n    }\n  }, {\n    key: \"getXFromColumn\",\n    value: function getXFromColumn(col) {\n      return this.x + col * this.tileWidth;\n    }\n  }, {\n    key: \"getYFromRow\",\n    value: function getYFromRow(row) {\n      return this.y + row * this.tileHeight;\n    }\n  }, {\n    key: \"getXFromIndex\",\n    value: function getXFromIndex(ind) {\n      return this.getColumnFromIndex(ind) * tileWidth;\n    }\n  }, {\n    key: \"getYFromIndex\",\n    value: function getYFromIndex(ind) {\n      return this.getRowFromIndex(ind) * tileHeight;\n    }\n  }, {\n    key: \"getCoordFromIndex\",\n    value: function getCoordFromIndex(ind) {\n      return [this.getXFromIndex(ind), this.getYFromIndex(ind)];\n    }\n  }, {\n    key: \"getCoordFromTileCoord\",\n    value: function getCoordFromTileCoord(row, col) {\n      return [this.getXFromColumn(col), this.getYFromRow(row)];\n    }\n  }, {\n    key: \"swapTileData\",\n    value: function swapTileData(a, b) {\n      var tile1 = this._convertInputFormat([a]);\n\n      var tile2 = this._convertInputFormat([b]);\n\n      var data1 = tile1.datum();\n      var data2 = tile2.datum();\n      var _ref3 = [data2.cell, data1.cell];\n      data1.cell = _ref3[0];\n      data2.cell = _ref3[1];\n    } // WARNING: Only works within same puzzle\n    // swaps tileContainer selections\n    // a, b can be flattened index, tileContainer DOM Element or d3 selection\n\n  }, {\n    key: \"swapTile\",\n    value: function swapTile(a, b) {\n      var tile1 = this._convertInputFormat([a]);\n\n      var tile2 = this._convertInputFormat([b]);\n\n      this.swapTileData(tile1, tile2);\n      tile1.attr('x', function (d) {\n        return d.cell.x;\n      }).attr('y', function (d) {\n        return d.cell.y;\n      });\n      tile2.attr('x', function (d) {\n        return d.cell.x;\n      }).attr('y', function (d) {\n        return d.cell.y;\n      });\n    } // sets goal image to clone of start image\n    // NOTE: duplicate tiles are not allowed in the same grid\n    // if clone would cause duplicate, original tile instead moved to/swapped with goal tile\n    // start, goal = tileContainer (d3.selection or DOM element)\n\n  }, {\n    key: \"dropTile\",\n    value: function dropTile(tileContainerStart, x, y) {\n      var overlap = this.getOverlappingTile(x, y);\n\n      if (overlap) {\n        Grid.cloneTile(tileContainerStart, overlap);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isFull\",\n    value: function isFull() {\n      return this._emptyTiles.size === 1;\n    }\n  }, {\n    key: \"_generateGridDataHelper\",\n    value: function _generateGridDataHelper(row, col) {\n      var _this$getCoordFromTil = this.getCoordFromTileCoord(row, col),\n          _this$getCoordFromTil2 = _slicedToArray(_this$getCoordFromTil, 2),\n          x = _this$getCoordFromTil2[0],\n          y = _this$getCoordFromTil2[1];\n\n      var ind = this.getIndexFromTileCoord(row, col); // (x, y) = coords of grid cell\n\n      var curr = {\n        grid: this,\n        cell: {\n          x: x,\n          y: y,\n          row: row,\n          col: col,\n          ind: ind\n        },\n        start: {\n          x: x,\n          y: y,\n          row: row,\n          col: col,\n          ind: ind\n        }\n      };\n\n      if (this.imageSrc) {\n        // (x, y) = coords of imageContainer\n        curr.img = {\n          // offset so that section of image shown corresponds to tile coordinates\n          offsetX: -(x - this.x),\n          offsetY: -(y - this.y),\n          src: this.imageSrc\n        };\n      }\n\n      return curr;\n    }\n  }, {\n    key: \"generateGridData\",\n    value: function generateGridData() {\n      var data = [];\n\n      for (var row = 0; row < this.numRows; row++) {\n        for (var col = 0; col < this.numCols; col++) {\n          data.push(this._generateGridDataHelper(row, col));\n        }\n      }\n\n      return data;\n    }\n  }, {\n    key: \"getMoveInfo\",\n    value: function getMoveInfo(move) {\n      var moveDict = {\n        l: {\n          delta: -1,\n          dx: -this.tileWidth,\n          dy: 0\n        },\n        r: {\n          delta: 1,\n          dx: this.tileWidth,\n          dy: 0\n        },\n        u: {\n          delta: -this.numCols,\n          dx: 0,\n          dy: -this.tileHeight\n        },\n        d: {\n          delta: this.numCols,\n          dx: 0,\n          dy: this.tileHeight\n        }\n      };\n      return moveDict[move];\n    } // TODO: disable buttons and tile selection/deletion during animation \n    // (and/or make them reset puzzle and stop animateMoves)\n    // WARNING: will not work on incomplete grids (where not all images filled in and emptyPos specified)\n    // moves = array of moves to animate ex: ['l', 'r', 'u', 'd', ...]\n    // parent = optional parent element to insert list of moves in\n    // durationPerMove = milliseconds it takes for single move to be animated\n\n  }, {\n    key: \"animateMoves\",\n    value: function animateMoves(moves) {\n      var _this = this;\n\n      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var durationPerMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      var currPromise = null;\n      var list, listItems, listItemsDOM;\n\n      if (parent) {\n        parent = parent instanceof d3.selection ? parent : d3.select(parent);\n        list = parent.select('ol');\n\n        if (list.empty()) {\n          list = parent.append('ol').classed('list-group', true).classed('move-list', true);\n        } // update data of existing elements\n\n\n        var updateList = list.selectAll('li').data(moves); // enter/append missing list items\n\n        var enterList = updateList.enter().append('li').classed('list-group-item', true).classed('move-list-item', true); // all items in list update text to match new moves\n\n        var _listItems = updateList.merge(enterList).text(function (d, i) {\n          return Move.getFullName(moves[i]);\n        }); // extra list items with no associated moves removed\n\n\n        updateList.exit().remove();\n        listItemsDOM = _listItems.nodes();\n      }\n\n      var _loop = function _loop(i) {\n        var move = moves[i];\n        var params = [move];\n\n        if (parent) {\n          params.push(listItemsDOM[i]);\n        }\n\n        if (currPromise === null) {\n          currPromise = _this.animateMove.apply(_this, params.concat([durationPerMove]));\n        } else {\n          try {\n            currPromise = currPromise.then(function () {\n              return _this.animateMove.apply(_this, params.concat([durationPerMove]));\n            });\n          } catch (error) {\n            // TODO: consider catching error silently to stop errors from piling up in console\n            // since erroneous key presses are expected\n            // alternatively, just return true/false from animateMove and be done with it\n            console.log(error);\n          }\n        }\n      };\n\n      for (var i = 0; i < moves.length; i++) {\n        _loop(i);\n      }\n    } // TODO: consider using d3's transition syntax rather than Promise wrapping\n    // pro: can probably use transition.interrupt for a \"stop\" feature\n    // alternatively, consider using async/await\n    // animates move and returns associated Transition Promise\n    // move within {'l', 'r', 'd', 'u'}\n    // listItem = <li> DOM element containing move string\n    // - listItem highlighted when corresponding move is played\n    // duration = milliseconds it takes to animate move\n\n  }, {\n    key: \"animateMove\",\n    value: function animateMove(move) {\n      var _this2 = this;\n\n      var listItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n\n      if (!this.canMove(move)) {\n        throw new Error(\"Invalid Move: \".concat(move));\n      }\n\n      var moveInfo = this.getMoveInfo(move);\n      return new Promise(function (resolve) {\n        if (listItem) {\n          listItem.classList.add('active-move'); // TODO: reconsider whether to use (might hide tile sliding on certain screen sizes)\n\n          listItem.scrollIntoView();\n        }\n\n        var movedTile = _this2.tileContainers.filter(function (d) {\n          return d.cell.ind === _this2.emptyPos - moveInfo.delta;\n        });\n\n        var emptyTile = _this2.tileContainers.filter(function (d) {\n          return d.cell.ind === _this2.emptyPos;\n        });\n\n        _this2.swapTileData(movedTile, emptyTile);\n\n        emptyTile.attr('x', function (d) {\n          return d.cell.x;\n        }).attr('y', function (d) {\n          return d.cell.y;\n        });\n        movedTile.transition() // TODO: decrease speed after testing\n        .duration(duration).attr('x', function (d) {\n          return d.cell.x;\n        }).attr('y', function (d) {\n          return d.cell.y;\n        }).on('end', function () {\n          if (listItem) listItem.classList.remove('active-move');\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: \"canMove\",\n    value: function canMove(move) {\n      if (this._emptyTiles.size === this.numCells) {\n        return false;\n      } // TODO: consolidate with other move utility functions to separate (nested?) Move class\n\n\n      var moveDict = {\n        l: {\n          dRow: 0,\n          dCol: -1\n        },\n        r: {\n          dRow: 0,\n          dCol: 1\n        },\n        u: {\n          dRow: -1,\n          dCol: 0\n        },\n        d: {\n          dRow: 1,\n          dCol: 0\n        }\n      };\n      var moveInfo = moveDict[move];\n\n      var _this$getTileCoordFro = this.getTileCoordFromIndex(this.emptyPos),\n          _this$getTileCoordFro2 = _slicedToArray(_this$getTileCoordFro, 2),\n          row = _this$getTileCoordFro2[0],\n          col = _this$getTileCoordFro2[1];\n\n      var movedTile = {\n        row: row - moveInfo.dRow,\n        col: col - moveInfo.dCol\n      };\n      return movedTile.row >= 0 && movedTile.row < this.numRows && movedTile.col >= 0 && movedTile.col < this.numCols;\n    } // args = ind or row, col\n\n  }, {\n    key: \"hasTileAt\",\n    value: function hasTileAt() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      if (args.length === 1) {\n        var ind = args[0];\n        return ind !== this.emptyPos && ind >= 0 && ind < this.numCells;\n      }\n\n      if (args.length === 2) {\n        var row = args[0],\n            col = args[1];\n        return row >= 0 && row < this.numRows && col >= 0 && col < this.numCols;\n      }\n    }\n  }, {\n    key: \"selectTile\",\n    value: function selectTile() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      var tile = this._convertInputFormat(args);\n\n      var overlay = tile.select('.tile-overlay');\n      this.selectedTiles.add(tile.node());\n      overlay.classed('select-overlay', true);\n    }\n  }, {\n    key: \"deselectTile\",\n    value: function deselectTile() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      var tile = this._convertInputFormat(args);\n\n      var overlay = tile.select('.tile-overlay');\n      this.selectedTiles.delete(tile.node());\n      overlay.classed('select-overlay', false);\n    }\n  }, {\n    key: \"deselectAll\",\n    value: function deselectAll() {\n      var _this3 = this;\n\n      var that = this;\n      this.tileContainers.each(function (d) {\n        return _this3.deselectTile(d.tile);\n      });\n    } // toggles whether tile is selected or not\n    // returns whether tile is selected or not after toggle\n    // args = tileContainer DOM Element/d3 selection OR index\n\n  }, {\n    key: \"toggleTileSelect\",\n    value: function toggleTileSelect() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      var tile = this._convertInputFormat(args);\n\n      var overlay = tile.select('.tile-overlay');\n      var selected = overlay.classed('select-overlay');\n\n      if (selected) {\n        this.selectedTiles.add(tile.node());\n      } else {\n        this.selectedTiles.delete(tile.node());\n      }\n\n      overlay.classed('select-overlay', !selected);\n      return !selected;\n    } // clicks specified tile\n    // returns object with:\n    // - 'method': delete/swap/deselect/select\n    // - tile (sometimes): tileContainer selection deleted/deselected/selected\n    // - tile1/tile2 (sometimes) : tiles swapped\n    // args = tileContainer DOM Element/d3 selection OR index\n\n  }, {\n    key: \"clickTile\",\n    value: function clickTile() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n\n      var tileContainer = this._convertInputFormat(args);\n\n      if (this.deleteOverlay) {\n        this.deleteTile(tileContainer);\n        this.hideOverlay(tileContainer);\n        return {\n          method: 'delete',\n          tile: tileContainer\n        };\n      }\n\n      var alreadySelectedTile = this.selectedTiles.values().next().value;\n\n      if (alreadySelectedTile) {\n        this.deselectTile(alreadySelectedTile);\n\n        if (alreadySelectedTile !== tileContainer.node()) {\n          this.swapTile(alreadySelectedTile, tileContainer);\n          this.hideOverlay(tileContainer);\n          return {\n            method: 'swap',\n            tile1: tileContainer,\n            tile2: alreadySelectedTile\n          };\n        }\n\n        return {\n          method: 'deselect',\n          tile: tileContainer\n        };\n      } else {\n        this.selectTile(tileContainer);\n        return {\n          method: 'select',\n          tile: tileContainer\n        };\n      }\n    }\n  }, {\n    key: \"hasEmptyTile\",\n    value: function hasEmptyTile() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n\n      return this._emptyTiles.has(this._convertInputFormat(args).node());\n    } // performs somewhat biased shuffle where shuffled state cannot equal original state\n    // NOTE: assumes current state is solvable\n    // see comment on isSolvable() for more explanation on how solvability guaranteed\n\n  }, {\n    key: \"shuffle\",\n    value: function shuffle() {\n      // shuffling for 1D puzzles randomly changes emptyPos and shifts tiles out of the way\n      if (this.numRows === 1 || this.numCols === 1) {\n        var newEmptyPos = this.emptyPos; // NOTE: while could loop infinitely, unlikely unless puzzle is 1x1, which is not allowed\n\n        while (newEmptyPos === this.emptyPos) {\n          newEmptyPos = Math.floor(Math.random() * this.numCells);\n        }\n\n        if (this.emptyPos < newEmptyPos) {\n          for (var i = this.emptyPos; i < newEmptyPos; i++) {\n            this.swapTile(i, i + 1);\n          }\n        } else {\n          for (var _i2 = this.emptyPos; _i2 > newEmptyPos; _i2--) {\n            this.swapTile(_i2, _i2 - 1);\n          }\n        }\n\n        return;\n      } // array representation of puzzle assuming that start is goal state and shuffled state is start state\n\n\n      var arr = this._fisherYatesShuffle(); // if puzzle isn't solvable, a swap of horizontally neighboring tiles increases # inversions by 1\n      // this makes puzzle solvable for all 2D puzzles (both dimensions > 1)\n\n\n      if (!Grid._isSolvable(arr, this.emptyPos, this.numRows, this.numCols)) {\n        var _i3, j;\n\n        if (this.emptyPos < 2) {\n          _i3 = this.numCells - 2;\n          j = this.numCells - 1;\n        } else {\n          _i3 = 0;\n          j = 1;\n        }\n\n        this.swapTile(_i3, j);\n        var _ref4 = [arr[j], arr[_i3]];\n        arr[_i3] = _ref4[0];\n        arr[j] = _ref4[1];\n      } // prevents same initial state from repeating \n      // NOTE: could loop infinitely, but unlikely unless puzzle is 1x1, which should be prevented\n\n\n      if (arr.every(function (goalInd, ind) {\n        return goalInd === ind;\n      })) {\n        this.shuffle();\n        return;\n      }\n    } // shuffles puzzle randomly using the Fisher Yates/Knuth shuffling algorithm\n    // returns array representation of puzzle assuming that starting position is goal state and\n    // shuffled state is start state\n    // WARNING: Is NOT guaranteed to return a solvable state\n\n  }, {\n    key: \"_fisherYatesShuffle\",\n    value: function _fisherYatesShuffle() {\n      // arr becomes array representation of puzzle\n      var arr = d3.range(this.numCells); // swaps each element with itself or an element after it\n\n      for (var i = 0; i < arr.length - 1; i++) {\n        var j = Math.floor(Math.random() * (arr.length - i) + i);\n        var _ref5 = [arr[j], arr[i]];\n        arr[i] = _ref5[0];\n        arr[j] = _ref5[1];\n        // could be made slightly faster by using swapData and only redrawing tiles at the end\n        this.swapTile(i, j);\n      }\n\n      return arr;\n    } // biased shuffle where shuffled state cannot equal original state using Sattolo's algorithm\n    // each arr value will be in a different position than its initial position\n    // WARNING: Is NOT guaranteed to return a solvable state\n\n  }, {\n    key: \"_sattoloShuffle\",\n    value: function _sattoloShuffle() {\n      var arr = d3.range(this.numCells); // swaps each element with an element after it\n\n      for (var i = 0; i < arr.length - 1; i++) {\n        var j = Math.floor(Math.random() * (arr.length - i) + i + 1);\n        var _ref6 = [arr[j], arr[i]];\n        arr[i] = _ref6[0];\n        arr[j] = _ref6[1];\n        this.swapTile(i, j);\n      }\n\n      return arr;\n    } // TODO: modify to support formats other than d3.selection\n\n  }, {\n    key: \"_convertInputFormat\",\n    value: function _convertInputFormat(args) {\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd3.selection';\n\n      if (args.length === 1) {\n        var arg = args[0];\n        if (arg instanceof d3.selection) return arg;\n        if (arg instanceof Element) return d3.select(arg); // converts from index\n\n        if (Number.isInteger(arg)) {\n          var temp = this.tileContainers.filter(function (d) {\n            return d.cell.ind === arg;\n          });\n          return temp.empty() ? null : temp;\n        }\n      }\n\n      return null;\n    } // returns flattened array (left to right, top to bottom) of array indices of tiles in the\n    // goalGrid that correspond to the image ordering in the startGrid\n    // ex: startGrid = [b, a, c], goalGrid = [a, b, c], return = [1, 0, 2]\n    // explanation: b = goalGrid[1], a = goalGrid[0], c = goalGrid[2]\n\n  }, {\n    key: \"cloneTilesTo\",\n    // TODO: consider using custom function instead of cloneTile for better performance\n    value: function cloneTilesTo(goalGrid) {\n      var _this4 = this;\n\n      this.tileContainers.each(function (d) {\n        if (!_this4.hasEmptyTile(d.tile)) {\n          var goalTile = goalGrid.tileContainers.filter(function (goalData) {\n            return goalData.cell.ind === d.cell.ind;\n          });\n          Grid.cloneTile(d.tile, goalTile);\n        }\n      });\n    }\n  }, {\n    key: \"emptyPos\",\n    set: function set(d) {\n      var tile = this._convertInputFormat(arguments);\n\n      this._emptyTiles = new Set([tile.node()]);\n    },\n    get: function get() {\n      return this._emptyTiles.size === 1 ? d3.select(this._emptyTiles.values().next().value).datum().cell.ind : null;\n    }\n  }, {\n    key: \"emptyTile\",\n    get: function get() {\n      return this._emptyTiles.size === 1 ? this._emptyTiles.values().next().value : null;\n    }\n  }, {\n    key: \"numCells\",\n    get: function get() {\n      return this.numRows * this.numCols;\n    }\n  }], [{\n    key: \"cloneTile\",\n    value: function cloneTile(start, goal) {\n      var tileContainerStart = start instanceof d3.selection ? start : d3.select(start),\n          tileContainerGoal = goal instanceof d3.selection ? goal : d3.select(goal);\n      var startData = tileContainerStart.datum(),\n          goalData = tileContainerGoal.datum();\n      var startGrid = startData.grid,\n          goalGrid = goalData.grid;\n      var match = goalGrid.tileContainers.filter(function (d) {\n        return d.img !== undefined && d.img.offsetX === startData.img.offsetX && d.img.offsetY === startData.img.offsetY && d.img.src === startData.img.src;\n      });\n\n      if (!match.empty()) {\n        goalGrid.swapTile(match, tileContainerGoal);\n        return;\n      }\n\n      goalData.startTile = tileContainerStart;\n      goalGrid.showTile(tileContainerGoal);\n      var imageAtGoal = tileContainerGoal.select('image');\n\n      if (imageAtGoal.empty()) {\n        imageAtGoal = tileContainerGoal.insert('image', ':first-child').attr('width', goalGrid.width).attr('height', goalGrid.height);\n      }\n\n      goalData.img = Object.assign({}, startData.img);\n      imageAtGoal.attr('x', function (d) {\n        return d.img.offsetX;\n      }).attr('y', function (d) {\n        return d.img.offsetY;\n      }).attr('xlink:href', function (d) {\n        return d.img.src;\n      }).attr('preserveAspectRatio', 'none');\n      tileContainerGoal.select('.tile-number').text(function (d) {\n        return d.startTile.datum().start.ind + 1;\n      });\n\n      if (goalGrid.numberOverlay) {\n        tileContainerGoal.select('.tile-number-container').style('display', 'visible');\n      }\n\n      goalGrid._emptyTiles.delete(tileContainerGoal.node());\n    }\n  }, {\n    key: \"getArrayRepresentation\",\n    value: function getArrayRepresentation(startGrid, goalGrid) {\n      var output = [];\n      goalGrid.tileContainers.data().filter(function (d) {\n        return d.img !== undefined;\n      }).forEach(function (d, i) {\n        output[d.startTile.datum().cell.ind] = d.cell.ind;\n      });\n      output[startGrid.emptyPos] = goalGrid.emptyPos;\n      return output;\n    } // Explanation: picture puzzle as flattened array\n    // inversion = pair of tiles in incorrect position (arr[i] > arr[j] && i < j)\n    //\n    // ex: [4, 2, 0, 5, 1] has 6 inversions\n    // 4 > [2, 0, 1], 2 > [0, 1], 5 > [1]\n    //\n    // in the goal state, the array would read: [0, 1, 2, 3, 4, ...], with # inversions = 0\n    //\n    // sliding puzzle horizontally doesn't change # inversions\n    // sliding puzzle vertically does\n    //\n    // if # cols = odd, sliding vertically changes # inversions by even number\n    //      (sliding vertically changes relationship of tile with width - 1 tiles)\n    //\n    // therefore, solvable state must have even number of inversions in odd-col-puzzle\n    //\n    // if # cols = even, sliding vertically changes # inversions by odd number\n    //      (width - 1 now odd)\n    //\n    // in goal state, # inversions = 0 and vertical distance between emptyPos's current and goal state = 0\n    // in a vertical move, # inversions becomes odd and distance changes by 1 (becoming odd)\n    // in a second vertical move, # inversions becomes even and distance changes by 1 (becoming even)\n    //\n    // therefore, in solvable state:\n    //      # inversions = even and distance of emptyPos from goal position is even\n    //          OR\n    //      # inversions = odd and distance of emptyPos from goal position is odd\n    //\n    // if sliding puzzle is 1 dimensional (single row or column), only horizontal sliding is possible\n    // therefore, # inversions cannot be changed, so puzzle only solvable if # inversions = 0.\n    // alternatively, just check if array is sorted (excluding emptyPos) to see if solvable\n    //\n    // NOTE: # inversions can = 0 without being at goal state because it doesn't count emptyPos\n\n  }, {\n    key: \"isSolvable\",\n    value: function isSolvable(startGrid, goalGrid) {\n      if (startGrid.emptyPos === null || !goalGrid.isFull()) {\n        return false;\n      }\n\n      var arr = Grid.getArrayRepresentation(startGrid, goalGrid);\n      var emptyPos = startGrid.emptyPos;\n      return Grid._isSolvable(arr, emptyPos, startGrid.numRows, startGrid.numCols);\n    } // arr = array representation from getArrayRepresentation()\n    // emptyPos = index of empty tile\n    // numRows = number of rows of puzzle\n    // numCols = number of columns of puzzle\n\n  }, {\n    key: \"_isSolvable\",\n    value: function _isSolvable(arr, emptyPos, numRows, numCols) {\n      // if array is 1-D, sliding cannot change # inversions, so array must be sorted (excluding emptyPos)\n      if (numCols === 1 || numRows === 1) {\n        for (var i = 1; i < arr.length; i++) {\n          if (i !== emptyPos && i - 1 !== emptyPos && arr[i] < arr[i - 1]) return false;\n        }\n\n        return true;\n      }\n\n      var numInversions = Util.countInversions(arr.filter(function (d, i) {\n        return i != emptyPos;\n      }));\n\n      if (numCols % 2 === 1) {\n        return numInversions % 2 === 0;\n      }\n\n      var row = Math.floor(emptyPos / numCols);\n      var goalRow = Math.floor(arr[emptyPos] / numCols);\n      return numInversions % 2 === 0 === (Math.abs(row - goalRow) % 2 === 0);\n    }\n  }]);\n\n  return Grid;\n}();\n\nvar StartGrid =\n/*#__PURE__*/\nfunction (_Grid) {\n  _inherits(StartGrid, _Grid);\n\n  function StartGrid(parent, x, y, numRows, numCols, imageSrc) {\n    var _ref7 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {},\n        _ref7$height = _ref7.height,\n        height = _ref7$height === void 0 ? 500 : _ref7$height,\n        _ref7$width = _ref7.width,\n        width = _ref7$width === void 0 ? 500 : _ref7$width;\n\n    _classCallCheck(this, StartGrid);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StartGrid).call(this, parent, x, y, numRows, numCols, {\n      height: height,\n      width: width,\n      imageSrc: imageSrc,\n      hasTileUnderlay: true\n    }));\n  }\n\n  _createClass(StartGrid, [{\n    key: \"resetTiles\",\n    value: function resetTiles() {\n      var _this5 = this;\n\n      this.tileContainers.attr('x', function (d) {\n        if (d.cell.ind === _this5.emptyPos) {\n          var tile = _this5._convertInputFormat([d.cell.ind]);\n\n          _this5.showTile(tile);\n        }\n\n        d.cell = Object.assign({}, d.start);\n        return d.start.x;\n      }).attr('y', function (d) {\n        return d.start.y;\n      });\n      this._emptyTiles = new Set();\n    } // args = tileContainer DOM Element/d3 selection OR index\n\n  }, {\n    key: \"deleteTile\",\n    value: function deleteTile() {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n\n      var tile = this._convertInputFormat(args);\n\n      if (this.emptyPos !== null) {\n        this.showTile(this.emptyPos);\n      }\n\n      this.emptyPos = tile;\n      this.hideTile(tile);\n    }\n  }]);\n\n  return StartGrid;\n}(Grid);\n\nvar GoalGrid =\n/*#__PURE__*/\nfunction (_Grid2) {\n  _inherits(GoalGrid, _Grid2);\n\n  function GoalGrid(parent, x, y, numRows, numCols) {\n    var _ref8 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {},\n        _ref8$height = _ref8.height,\n        height = _ref8$height === void 0 ? 500 : _ref8$height,\n        _ref8$width = _ref8.width,\n        width = _ref8$width === void 0 ? 500 : _ref8$width;\n\n    _classCallCheck(this, GoalGrid);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GoalGrid).call(this, parent, x, y, numRows, numCols, {\n      height: height,\n      width: width,\n      hasTileUnderlay: true\n    }));\n  }\n\n  _createClass(GoalGrid, [{\n    key: \"resetTiles\",\n    value: function resetTiles() {\n      var _this6 = this;\n\n      this.tileContainers.attr('x', function (d) {\n        return d.start.x;\n      }).attr('y', function (d) {\n        return d.start.y;\n      }).each(function (d) {\n        return _this6.hideTile(d.tile);\n      }).each(function (d) {\n        d.cell = Object.assign({}, d.start);\n        delete d.img;\n      });\n      this.tileContainers.select('image').remove();\n      this._emptyTiles = new Set(this.tileContainers.nodes());\n    } // args = tileContainer DOM Element/d3 selection OR index\n\n  }, {\n    key: \"deleteTile\",\n    value: function deleteTile() {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n\n      var tile = this._convertInputFormat(args);\n\n      this._emptyTiles.add(tile.node());\n\n      return this.deletetileContainer(tile);\n    } // deletes tile with specified starting tileContainer (d3 selection)\n\n  }, {\n    key: \"deleteTileWithStartingTile\",\n    value: function deleteTileWithStartingTile(tileContainerStart) {\n      tileContainerStart = tileContainerStart instanceof d3.selection ? tileContainerStart : d3.select(tileContainerStart);\n      var tile = this.tileContainers.filter(function (d) {\n        return d.hasOwnProperty('startTile') && d.startTile.node() === tileContainerStart.node();\n      });\n      return this.deletetileContainer(tile);\n    }\n  }, {\n    key: \"deletetileContainer\",\n    value: function deletetileContainer(tileContainer) {\n      if (tileContainer === null || tileContainer.empty()) {\n        return false;\n      }\n\n      var data = tileContainer.datum();\n      delete data.img;\n      tileContainer.select('image').remove();\n      this.hideTile(tileContainer);\n\n      this._emptyTiles.add(tileContainer.node());\n\n      return true;\n    }\n  }]);\n\n  return GoalGrid;\n}(Grid);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHV6emxlLWdyYXBoaWMuanM/MjJhMiJdLCJuYW1lcyI6WyJNb3ZlIiwibW92ZSIsIk5BTUVfTUFQUElORyIsIlV0aWwiLCJhcnIiLCJtZXJnZVNvcnQiLCJfbWVyZ2VTb3J0IiwiVWludDE2QXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwidGVtcCIsImxlZnQiLCJyaWdodCIsIm51bUludmVyc2lvbnMiLCJtaWQiLCJNYXRoIiwiZmxvb3IiLCJfbWVyZ2UiLCJpIiwiaiIsImsiLCJHcmlkIiwicGFyZW50IiwieCIsInkiLCJudW1Sb3dzIiwibnVtQ29scyIsImhlaWdodCIsIndpZHRoIiwiaW1hZ2VTcmMiLCJoYXNUaWxlVW5kZXJsYXkiLCJkMyIsInNlbGVjdGlvbiIsInNlbGVjdCIsInRpbGVIZWlnaHQiLCJ0aWxlV2lkdGgiLCJfZW1wdHlUaWxlcyIsIlNldCIsInNlbGVjdGVkVGlsZXMiLCJjb250YWluZXIiLCJvdXRsaW5lIiwidGlsZUNvbnRhaW5lcnMiLCJ0aWxlSW1hZ2VDb250YWluZXJzIiwidGlsZU91dGxpbmVzIiwicmVtb3ZlSWNvbnMiLCJ0aWxlTnVtYmVycyIsInRpbGVPdmVybGF5cyIsInRpbGVVbmRlcmxheXMiLCJudW1iZXJPdmVybGF5IiwiZGVsZXRlT3ZlcmxheSIsImFyZ3MiLCJ0aWxlIiwiX2NvbnZlcnRJbnB1dEZvcm1hdCIsInN0eWxlIiwiY2xhc3NlZCIsInRpbGVOdW1iZXJDb250YWluZXJzIiwiaGlkZU51bWJlck92ZXJsYXkiLCJzaG93TnVtYmVyT3ZlcmxheSIsImRhdGEiLCJnZW5lcmF0ZUdyaWREYXRhIiwiZGF0dW0iLCJhcHBlbmQiLCJhdHRyIiwidW5kZXJsYXlEYXRhIiwibWFwIiwiZCIsIk9iamVjdCIsImFzc2lnbiIsImNlbGwiLCJzZWxlY3RBbGwiLCJlbnRlciIsImltYWdlcyIsImltZyIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZWFjaCIsImdyaWQiLCJoaWRlVGlsZSIsIm5vZGVzIiwib24iLCJvdmVybGF5IiwiaGFzRW1wdHlUaWxlIiwiaGFzIiwibm9kZSIsInRpbGVOdW1iZXJCYWNrZ3JvdW5kIiwidGV4dCIsImluZCIsImdldFJvd0Zyb21ZIiwiZ2V0Q29sdW1uRnJvbVgiLCJyb3ciLCJjb2wiLCJnZXRJbmRleEZyb21UaWxlQ29vcmQiLCJvdmVybGFwIiwiZmlsdGVyIiwiZW1wdHkiLCJnZXRSb3dGcm9tSW5kZXgiLCJnZXRDb2x1bW5Gcm9tSW5kZXgiLCJnZXRYRnJvbUluZGV4IiwiZ2V0WUZyb21JbmRleCIsImdldFhGcm9tQ29sdW1uIiwiZ2V0WUZyb21Sb3ciLCJhIiwiYiIsInRpbGUxIiwidGlsZTIiLCJkYXRhMSIsImRhdGEyIiwic3dhcFRpbGVEYXRhIiwidGlsZUNvbnRhaW5lclN0YXJ0IiwiZ2V0T3ZlcmxhcHBpbmdUaWxlIiwiY2xvbmVUaWxlIiwic2l6ZSIsImdldENvb3JkRnJvbVRpbGVDb29yZCIsImN1cnIiLCJzdGFydCIsInNyYyIsInB1c2giLCJfZ2VuZXJhdGVHcmlkRGF0YUhlbHBlciIsIm1vdmVEaWN0IiwibCIsImRlbHRhIiwiZHgiLCJkeSIsInIiLCJ1IiwibW92ZXMiLCJkdXJhdGlvblBlck1vdmUiLCJjdXJyUHJvbWlzZSIsImxpc3QiLCJsaXN0SXRlbXMiLCJsaXN0SXRlbXNET00iLCJ1cGRhdGVMaXN0IiwiZW50ZXJMaXN0IiwibWVyZ2UiLCJnZXRGdWxsTmFtZSIsImV4aXQiLCJyZW1vdmUiLCJwYXJhbXMiLCJhbmltYXRlTW92ZSIsInRoZW4iLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJsaXN0SXRlbSIsImR1cmF0aW9uIiwiY2FuTW92ZSIsIkVycm9yIiwibW92ZUluZm8iLCJnZXRNb3ZlSW5mbyIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2xhc3NMaXN0IiwiYWRkIiwic2Nyb2xsSW50b1ZpZXciLCJtb3ZlZFRpbGUiLCJlbXB0eVBvcyIsImVtcHR5VGlsZSIsInRyYW5zaXRpb24iLCJudW1DZWxscyIsImRSb3ciLCJkQ29sIiwiZ2V0VGlsZUNvb3JkRnJvbUluZGV4IiwiZGVsZXRlIiwidGhhdCIsImRlc2VsZWN0VGlsZSIsInNlbGVjdGVkIiwidGlsZUNvbnRhaW5lciIsImRlbGV0ZVRpbGUiLCJoaWRlT3ZlcmxheSIsIm1ldGhvZCIsImFscmVhZHlTZWxlY3RlZFRpbGUiLCJ2YWx1ZXMiLCJuZXh0IiwidmFsdWUiLCJzd2FwVGlsZSIsInNlbGVjdFRpbGUiLCJuZXdFbXB0eVBvcyIsInJhbmRvbSIsIl9maXNoZXJZYXRlc1NodWZmbGUiLCJfaXNTb2x2YWJsZSIsImV2ZXJ5IiwiZ29hbEluZCIsInNodWZmbGUiLCJyYW5nZSIsImZvcm1hdCIsImFyZyIsIkVsZW1lbnQiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJnb2FsR3JpZCIsImdvYWxUaWxlIiwiZ29hbERhdGEiLCJhcmd1bWVudHMiLCJnb2FsIiwidGlsZUNvbnRhaW5lckdvYWwiLCJzdGFydERhdGEiLCJzdGFydEdyaWQiLCJtYXRjaCIsInVuZGVmaW5lZCIsInN0YXJ0VGlsZSIsInNob3dUaWxlIiwiaW1hZ2VBdEdvYWwiLCJpbnNlcnQiLCJvdXRwdXQiLCJmb3JFYWNoIiwiaXNGdWxsIiwiZ2V0QXJyYXlSZXByZXNlbnRhdGlvbiIsImNvdW50SW52ZXJzaW9ucyIsImdvYWxSb3ciLCJhYnMiLCJTdGFydEdyaWQiLCJHb2FsR3JpZCIsImRlbGV0ZXRpbGVDb250YWluZXIiLCJoYXNPd25Qcm9wZXJ0eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQTtBQUVBO0lBQ01BLEk7Ozs7Ozs7OztnQ0FFaUJDLEksRUFBTTtBQUNyQixVQUFNQyxZQUFZLEdBQUc7QUFDakIsYUFBSyxNQURZO0FBRWpCLGFBQUssT0FGWTtBQUdqQixhQUFLLElBSFk7QUFJakIsYUFBSztBQUpZLE9BQXJCO0FBTUEsYUFBT0EsWUFBWSxDQUFDRCxJQUFELENBQW5CO0FBQ0g7Ozs7S0FHTDs7O0lBQ01FLEk7Ozs7Ozs7OztBQUVGO0FBQ0E7b0NBQ3VCQyxH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QUUsQ0FBQ0UsTUFBSCxDQUFVMkUsa0JBQVYsQ0FEekI7QUFFQSxVQUFJekQsSUFBSSxHQUFHLEtBQUtWLGNBQUwsQ0FBb0JvRCxNQUFwQixDQUEyQixVQUFBNUIsQ0FBQztBQUFBLGVBQ25DQSxDQUFDLENBQUNvSixjQUFGLENBQWlCLFdBQWpCLEtBQWlDcEosQ0FBQyxDQUFDc0ksU0FBRixDQUFZcEgsSUFBWixPQUF1QnlCLGtCQUFrQixDQUFDekIsSUFBbkIsRUFEckI7QUFBQSxPQUE1QixDQUFYO0FBR0EsYUFBTyxLQUFLaUksbUJBQUwsQ0FBeUJqSyxJQUF6QixDQUFQO0FBQ0g7Ozt3Q0FFbUJtSCxhLEVBQWU7QUFDL0IsVUFBSUEsYUFBYSxLQUFLLElBQWxCLElBQTBCQSxhQUFhLENBQUN4RSxLQUFkLEVBQTlCLEVBQXFEO0FBQ2pELGVBQU8sS0FBUDtBQUNIOztBQUNELFVBQUlwQyxJQUFJLEdBQUc0RyxhQUFhLENBQUMxRyxLQUFkLEVBQVg7QUFFQSxhQUFPRixJQUFJLENBQUNjLEdBQVo7QUFDQThGLG1CQUFhLENBQUNySSxNQUFkLENBQXFCLE9BQXJCLEVBQThCdUcsTUFBOUI7QUFDQSxXQUFLM0QsUUFBTCxDQUFjeUYsYUFBZDs7QUFDQSxXQUFLbEksV0FBTCxDQUFpQm9ILEdBQWpCLENBQXFCYyxhQUFhLENBQUNuRixJQUFkLEVBQXJCOztBQUNBLGFBQU8sSUFBUDtBQUNIOzs7O0VBbkRrQjlELEkiLCJmaWxlIjoiLi9zcmMvcHV6emxlLWdyYXBoaWMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOiBjb25zaWRlciBtYWtpbmcgUHV6emxlIChkcml2ZXIgZm9yIGJvdGggZ3JpZHMpIGEgc2VwYXJhdGUgY2xhc3MgZnJvbSBzY3JpcHQuanMgdG8gbWFrZSBjb2RlIGNsZWFuZXJcblxuLy8gVE9ETzogY29uc2lkZXIgbWFraW5nIG1pbmltdW0gdGlsZSBzaXplIChiYXNlZCBvbiB3aGVuIGhhcmQgdG8gY2xpY2sgYW5kIGhhcmQgdG8gcmVhZCBudW1iZXIgb3ZlcmxheSlcblxuLy8gVE9ETzogbW92ZSBhbGwgbW92ZSByZWxhdGVkIGZ1bmN0aW9uYWxpdHkgaW4gYWxsIGZpbGVzIHRvIHNlcGFyYXRlIGZpbGVcbmNsYXNzIE1vdmUge1xuXG4gICAgc3RhdGljIGdldEZ1bGxOYW1lKG1vdmUpIHtcbiAgICAgICAgY29uc3QgTkFNRV9NQVBQSU5HID0ge1xuICAgICAgICAgICAgJ2wnOiAnbGVmdCcsXG4gICAgICAgICAgICAncic6ICdyaWdodCcsXG4gICAgICAgICAgICAndSc6ICd1cCcsXG4gICAgICAgICAgICAnZCc6ICdkb3duJ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOQU1FX01BUFBJTkdbbW92ZV07XG4gICAgfVxufVxuXG4vLyBUT0RPOiBjb25zaWRlciBtb3ZpbmcgdG8gc2VwYXJhdGUgZmlsZSBvciBhbGdvcml0aG1zIGZpbGVcbmNsYXNzIFV0aWwge1xuXG4gICAgLy8gY291bnRzIG51bWJlciBpbnZlcnNpb25zIGluIGFycmF5IGlnbm9yaW5nIGVtcHR5UG9zIGluZGV4XG4gICAgLy8gTk9URTogIyBpbnZlcnNpb25zIGNhbiA9IDAgd2l0aG91dCBiZWluZyBhdCBnb2FsIHN0YXRlIGJlY2F1c2UgZW1wdHlQb3Mgbm90IGNvbnNpZGVyZWRcbiAgICBzdGF0aWMgY291bnRJbnZlcnNpb25zKGFycikge1xuXG4gICAgICAgIHJldHVybiBVdGlsLm1lcmdlU29ydChhcnIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBtZXJnZVNvcnQoYXJyKSB7XG4gICAgICAgIHJldHVybiBVdGlsLl9tZXJnZVNvcnQoXG4gICAgICAgICAgICBVaW50MTZBcnJheS5mcm9tKGFyciksIFxuICAgICAgICAgICAgbmV3IFVpbnQxNkFycmF5KGFyci5sZW5ndGgpLFxuICAgICAgICAgICAgMCwgYXJyLmxlbmd0aCAtIDFcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyB0ZW1wIGlzIGF1eGlsaWFyeSBtZW1vcnkgZm9yIF9tZXJnZVNvcnQgKHNvcnRlZCBlbGVtZW50cyBnZXQgc3RvcmVkIHRoZXJlKVxuICAgIC8vIHRlbXAgcGFzc2VkIGJldHdlZW4gY2FsbHMgdG8gcmVkdWNlIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgLy8gKG5vdCBzdHJpY3RseSBuZWNlc3NhcnksIGNvdWxkIGp1c3QgbWFrZSBuZXcgW10gaW4gX21lcmdlKCkpXG4gICAgLy8gV0FSTklORzogYXJyIGFuZCB0ZW1wIGFyZSBib3RoIG1vZGlmaWVkIGJ5IF9tZXJnZVNvcnQoKVxuICAgIHN0YXRpYyBfbWVyZ2VTb3J0KGFyciwgdGVtcCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgbGV0IG51bUludmVyc2lvbnMgPSAwO1xuXG4gICAgICAgIGlmIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG5cbiAgICAgICAgICAgIG51bUludmVyc2lvbnMgKz0gVXRpbC5fbWVyZ2VTb3J0KGFyciwgdGVtcCwgbGVmdCwgbWlkKTtcbiAgICAgICAgICAgIG51bUludmVyc2lvbnMgKz0gVXRpbC5fbWVyZ2VTb3J0KGFyciwgdGVtcCwgbWlkICsgMSwgcmlnaHQpO1xuXG4gICAgICAgICAgICBudW1JbnZlcnNpb25zICs9IFV0aWwuX21lcmdlKGFyciwgdGVtcCwgbGVmdCwgbWlkLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtSW52ZXJzaW9ucztcbiAgICB9XG5cbiAgICBzdGF0aWMgX21lcmdlKGFyciwgdGVtcCwgbGVmdCwgbWlkLCByaWdodCkge1xuICAgICAgICBsZXQgbnVtSW52ZXJzaW9ucyA9IDA7XG5cbiAgICAgICAgLy8gaSBhbmQgaiBtb3ZlIGFsb25nIDIgc29ydGVkIGFycmF5c1xuICAgICAgICAvLyBrIG1vdmVzIGFsb25nIG91dHB1dCBhcnJheVxuICAgICAgICBsZXQgaSA9IGxlZnQsXG4gICAgICAgICAgICBqID0gbWlkICsgMSxcbiAgICAgICAgICAgIGsgPSBsZWZ0O1xuXG4gICAgICAgIHdoaWxlIChpIDw9IG1pZCAmJiBqIDw9IHJpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldIDw9IGFycltqXSkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGsrKyByZXR1cm5zIGsgYmVmb3JlIGluY3JlbWVudGluZywgd2hpbGUgKytrIHJldHVybnMgayBhZnRlciBpbmNyZW1lbnRpbmdcbiAgICAgICAgICAgICAgICB0ZW1wW2srK10gPSBhcnJbaSsrXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcFtrKytdID0gYXJyW2orK107XG5cbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBsZWZ0IGFycmF5IGlzIHNvcnRlZCwgaWYgYXJyW2pdIDwgYXJyW2ldLCBhcnJbal0gPCBhW2kgdG8gbWlkXVxuICAgICAgICAgICAgICAgIG51bUludmVyc2lvbnMgKz0gbWlkIC0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGRzIHJlbWFpbmluZyBhcnJheSB2YWx1ZXMgaW50byB0ZW1wIChvbmUgYXJyYXkgY291bGQgcnVuIG91dCBiZWZvcmUgYW5vdGhlcilcbiAgICAgICAgd2hpbGUgKGkgPD0gbWlkKSB7XG4gICAgICAgICAgICB0ZW1wW2srK10gPSBhcnJbaSsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChqIDw9IHJpZ2h0KSB7XG4gICAgICAgICAgICB0ZW1wW2srK10gPSBhcnJbaisrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gdGVtcFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1JbnZlcnNpb25zO1xuICAgIH1cbn1cblxuY2xhc3MgR3JpZCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB4LCB5LCBudW1Sb3dzLCBudW1Db2xzLFxuICAgICAgICAgICAgICAgIHtoZWlnaHQgPSA1MDAsIHdpZHRoID0gNTAwLCBpbWFnZVNyYyA9IG51bGwsIGhhc1RpbGVVbmRlcmxheSA9IGZhbHNlfSA9IHt9KSB7XG5cbiAgICAgICAgLy8gcGFyZW50IHN2ZyBmb3IgR3JpZCB0byBiZSBwbGFjZWQgaW5cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgaW5zdGFuY2VvZiBkMy5zZWxlY3Rpb24gPyBwYXJlbnQgOiBkMy5zZWxlY3QocGFyZW50KTtcblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHRoaXMubnVtUm93cyA9IG51bVJvd3M7XG4gICAgICAgIHRoaXMubnVtQ29scyA9IG51bUNvbHM7XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgICAgICB0aGlzLmltYWdlU3JjID0gaW1hZ2VTcmM7XG5cbiAgICAgICAgdGhpcy5oYXNUaWxlVW5kZXJsYXkgPSBoYXNUaWxlVW5kZXJsYXk7XG5cbiAgICAgICAgdGhpcy50aWxlSGVpZ2h0ID0gaGVpZ2h0L251bVJvd3M7XG4gICAgICAgIHRoaXMudGlsZVdpZHRoID0gd2lkdGgvbnVtQ29scztcblxuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciByZW5hbWluZyB0byBfZW1wdHlUaWxlcyAoc2luY2UgY29udGFpbnMgdGlsZUNvbnRhaW5lciBkb21zKVxuICAgICAgICB0aGlzLl9lbXB0eVRpbGVzID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBOT1RFOiBjb3VsZCBiZSB0cmFuc2Zvcm1lZCBpbnRvIHNpbmdsZSB2YXJpYWJsZSB0cmFja2luZyBzaW5nbGUgc2VsZWN0aW9uXG4gICAgICAgIC8vIHNldCB1c2VkIGluIGNhc2UgbXVsdGlwbGUgc2VsZWN0aW9ucyBhcmUgZGVzaXJlZCBsYXRlclxuICAgICAgICB0aGlzLnNlbGVjdGVkVGlsZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm91dGxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbGVDb250YWluZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy50aWxlSW1hZ2VDb250YWluZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy50aWxlT3V0bGluZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbW92ZUljb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy50aWxlTnVtYmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudGlsZU92ZXJsYXlzID0gbnVsbDtcbiAgICAgICAgdGhpcy50aWxlVW5kZXJsYXlzID0gbnVsbDtcblxuICAgICAgICB0aGlzLm51bWJlck92ZXJsYXkgPSBmYWxzZTtcbiAgICAgICAgLy8gZ292ZXJucyB3aGV0aGVyIGhvdmVyaW5nIG92ZXIgdGlsZSBkaXNwbGF5cyBkZWxldGUgb3ZlcmxheSBvcHRpb25cbiAgICAgICAgdGhpcy5kZWxldGVPdmVybGF5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBhY2NlcHRzIHRpbGVDb250YWluZXIgRE9NL2QzIHNlbGVjdGlvbiwgaW5kZXggXG4gICAgc2V0IGVtcHR5UG9zKGQpIHtcbiAgICAgICAgbGV0IHRpbGUgPSB0aGlzLl9jb252ZXJ0SW5wdXRGb3JtYXQoYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fZW1wdHlUaWxlcyA9IG5ldyBTZXQoW3RpbGUubm9kZSgpXSk7XG4gICAgfVxuXG4gICAgZ2V0IGVtcHR5UG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1wdHlUaWxlcy5zaXplID09PSAxID8gXG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZW1wdHlUaWxlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpLmRhdHVtKCkuY2VsbC5pbmQgOiBudWxsO1xuICAgIH1cblxuICAgIGdldCBlbXB0eVRpbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbXB0eVRpbGVzLnNpemUgPT09IDEgPyB0aGlzLl9lbXB0eVRpbGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZSA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IG51bUNlbGxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Sb3dzICogdGhpcy5udW1Db2xzO1xuICAgIH1cblxuICAgIC8vIGhpZGVzIHRpbGUgRVhDRVBUIGZvciBvdmVybGF5XG4gICAgLy8gYXJncyA9IHRpbGVDb250YWluZXIgRE9NIEVsZW1lbnQvZDMgc2VsZWN0aW9uIE9SIGluZGV4XG4gICAgaGlkZVRpbGUoLi4uYXJncykge1xuICAgICAgICBsZXQgdGlsZSA9IHRoaXMuX2NvbnZlcnRJbnB1dEZvcm1hdChhcmdzKTtcbiAgICAgICAgdGlsZS5zZWxlY3QoJy50aWxlLWltYWdlLWNvbnRhaW5lcicpLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgIH1cblxuICAgIC8vIHNob3dzIHRpbGUgRVhDRVBUIGZvciBvdmVybGF5XG4gICAgLy8gYXJncyA9IHRpbGVDb250YWluZXIgRE9NIEVsZW1lbnQvZDMgc2VsZWN0aW9uIE9SIGluZGV4XG4gICAgc2hvd1RpbGUoLi4uYXJncykge1xuICAgICAgICBsZXQgdGlsZSA9IHRoaXMuX2NvbnZlcnRJbnB1dEZvcm1hdChhcmdzKTtcbiAgICAgICAgdGlsZS5zZWxlY3QoJy50aWxlLWltYWdlLWNvbnRhaW5lcicpLnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICB9XG5cbiAgICAvLyBhcmdzID0gdGlsZUNvbnRhaW5lciBET00gRWxlbWVudC9kMyBzZWxlY3Rpb24gT1IgaW5kZXhcbiAgICBoaWRlT3ZlcmxheSguLi5hcmdzKSB7XG4gICAgICAgIGxldCB0aWxlID0gdGhpcy5fY29udmVydElucHV0Rm9ybWF0KGFyZ3MpO1xuICAgICAgICB0aWxlLnNlbGVjdCgnLnRpbGUtb3ZlcmxheScpXG4gICAgICAgICAgICAuY2xhc3NlZCgnZGVsZXRlLW92ZXJsYXknLCBmYWxzZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3Qtb3ZlcmxheScsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBhcmdzID0gdGlsZUNvbnRhaW5lciBET00gRWxlbWVudC9kMyBzZWxlY3Rpb24gT1IgaW5kZXhcbiAgICBzaG93T3ZlcmxheSguLi5hcmdzKSB7XG4gICAgICAgIGxldCB0aWxlID0gdGhpcy5fY29udmVydElucHV0Rm9ybWF0KGFyZ3MpO1xuICAgICAgICB0aWxlLnNlbGVjdCgnLnRpbGUtb3ZlcmxheScpXG4gICAgICAgICAgICAuY2xhc3NlZCgnZGVsZXRlLW92ZXJsYXknLCB0aGlzLmRlbGV0ZU92ZXJsYXkpXG4gICAgICAgICAgICAuY2xhc3NlZCgnc2VsZWN0LW92ZXJsYXknLCAhdGhpcy5kZWxldGVPdmVybGF5KTtcbiAgICB9XG5cbiAgICBoaWRlTnVtYmVyT3ZlcmxheSgpIHtcbiAgICAgICAgdGhpcy50aWxlTnVtYmVyQ29udGFpbmVycy5zdHlsZSgnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgIHRoaXMubnVtYmVyT3ZlcmxheSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNob3dOdW1iZXJPdmVybGF5KCkge1xuICAgICAgICB0aGlzLnRpbGVOdW1iZXJDb250YWluZXJzLnN0eWxlKCdkaXNwbGF5JywgJycpO1xuICAgICAgICB0aGlzLm51bWJlck92ZXJsYXkgPSB0cnVlO1xuICAgIH1cblxuICAgIHNob3dEZWxldGVPdmVybGF5KCkge1xuICAgICAgICB0aGlzLnRpbGVPdmVybGF5cy5jbGFzc2VkKCdkZWxldGUtb3ZlcmxheScsIHRydWUpO1xuICAgICAgICB0aGlzLnRpbGVPdmVybGF5cy5jbGFzc2VkKCdzZWxlY3Qtb3ZlcmxheScsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kZWxldGVPdmVybGF5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBoaWRlRGVsZXRlT3ZlcmxheSgpIHtcbiAgICAgICAgdGhpcy50aWxlT3ZlcmxheXMuY2xhc3NlZCgnZGVsZXRlLW92ZXJsYXknLCBmYWxzZSk7XG4gICAgICAgIHRoaXMudGlsZU92ZXJsYXlzLmNsYXNzZWQoJ3NlbGVjdC1vdmVybGF5JywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVsZXRlT3ZlcmxheSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRvZ2dsZVRpbGVPdmVybGF5KCkge1xuICAgICAgICB0aGlzLmRlbGV0ZU92ZXJsYXkgPSAhdGhpcy5kZWxldGVPdmVybGF5O1xuICAgIH1cblxuICAgIHRvZ2dsZU51bWJlck92ZXJsYXkoKSB7XG4gICAgICAgIHRoaXMubnVtYmVyT3ZlcmxheSA/IHRoaXMuaGlkZU51bWJlck92ZXJsYXkoKSA6IHRoaXMuc2hvd051bWJlck92ZXJsYXkoKTtcbiAgICB9XG5cbiAgICBkcmF3KCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZ2VuZXJhdGVHcmlkRGF0YSgpO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5wYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0dW0odGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnZ3JpZC1jb250YWluZXInLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0YWJpbmRleCcsIDApO1xuXG5cbiAgICAgICAgdGhpcy5vdXRsaW5lID0gdGhpcy5jb250YWluZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgIC5hdHRyKCd4JywgdGhpcy54KVxuICAgICAgICAgICAgLmF0dHIoJ3knLCB0aGlzLnkpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLndpZHRoKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3B1enpsZS1vdXRsaW5lJywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzVGlsZVVuZGVybGF5KSB7XG4gICAgICAgICAgICBsZXQgdW5kZXJsYXlEYXRhID0gZGF0YS5tYXAoZCA9PiBPYmplY3QuYXNzaWduKGQuY2VsbCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzZWxlY3RzIG51bGwgc28gZ3JpZC1vdXRsaW5lIGRvZXNuJ3QgZ2V0IGRpc2NhcmRlZCBpbiBlbnRlciBhbmQgdXBkYXRlZCB3aXRoIGluY29ycmVjdCBkYXRhXG4gICAgICAgICAgICAvLyBOT1RFOiBub3QgdW5kZXJuZWF0aCB0aWxlQ29udGFpbmVycyBhcyB1bmRlcmxheSBzaG91bGQgbm90IG1vdmUgd2l0aCB0aWxlXG4gICAgICAgICAgICAvLyBhbHNvIE5PVCB1bmRlcm5lYXRoIGEgcGFyZW50IDxnPiBjb250YWluZXIgb2YgdGlsZUNvbnRhaW5lciBhcyBtb3ZlbWVudCB3b3VsZFxuICAgICAgICAgICAgLy8gbWFrZSB1bmRlcmxheSBtaXNtYXRjaCBzaWJsaW5nIHRpbGVDb250YWluZXJcbiAgICAgICAgICAgIHRoaXMudGlsZVVuZGVybGF5cyA9IHRoaXMuY29udGFpbmVyLnNlbGVjdEFsbChudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEodW5kZXJsYXlEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBkID0+IGQueClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZCA9PiBkLnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnRpbGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLnRpbGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgndGlsZS11bmRlcmxheScsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aWxlQ29udGFpbmVycyA9IHRoaXMuY29udGFpbmVyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy50aWxlV2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy50aWxlSGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBkID0+IGQuY2VsbC54KVxuICAgICAgICAgICAgLmF0dHIoJ3knLCBkID0+IGQuY2VsbC55KVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3RpbGUtY29udGFpbmVyJywgdHJ1ZSlcbiAgICAgICAgICAgIC5kYXR1bShmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZC50aWxlID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50aWxlSW1hZ2VDb250YWluZXJzID0gdGhpcy50aWxlQ29udGFpbmVyc1xuICAgICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuY2xhc3NlZCgndGlsZS1pbWFnZS1jb250YWluZXInLCB0cnVlKTtcblxuICAgICAgICBpZiAodGhpcy5pbWFnZVNyYykge1xuXG4gICAgICAgICAgICBsZXQgaW1hZ2VzID0gdGhpcy50aWxlSW1hZ2VDb250YWluZXJzLmFwcGVuZCgnaW1hZ2UnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMud2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZCA9PiBkLmltZy5vZmZzZXRYKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZCA9PiBkLmltZy5vZmZzZXRZKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4bGluazpocmVmJywgdGhpcy5pbWFnZVNyYylcbiAgICAgICAgICAgICAgICAuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICdub25lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRpbGVDb250YWluZXJzLmVhY2goZnVuY3Rpb24oZCkge2QuZ3JpZC5oaWRlVGlsZSh0aGlzKX0pO1xuICAgICAgICAgICAgdGhpcy5fZW1wdHlUaWxlcyA9IG5ldyBTZXQodGhpcy50aWxlQ29udGFpbmVycy5ub2RlcygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGlsZU91dGxpbmVzID0gdGhpcy50aWxlSW1hZ2VDb250YWluZXJzLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnRpbGVXaWR0aClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLnRpbGVIZWlnaHQpXG4gICAgICAgICAgICAuY2xhc3NlZCgndGlsZS1vdXRsaW5lJywgdHJ1ZSk7XG5cbiAgICAgICAgLy8gZnVuY3Rpb25hbGl0eSBjb3VsZCBiZSBmb2xkZWQgaW50byB0aWxlT3V0bGluZXMsIGJ1dCBkaXN0aW5jdCB0byByZWR1Y2UgY29uZnVzaW9uXG4gICAgICAgIC8vIE5PVEU6IE5PVCB1bmRlciB0aWxlSW1hZ2VDb250YWluZXIgYXMgdmlzaWJpbGl0eSBjYW4gYmUgaW5kZXBlbmRlbnQgb2YgdGlsZSBpbWFnZSB2aXNpYmlsaXR5XG4gICAgICAgIHRoaXMudGlsZU92ZXJsYXlzID0gdGhpcy50aWxlQ29udGFpbmVycy5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy50aWxlV2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy50aWxlSGVpZ2h0KVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3RpbGUtb3ZlcmxheScsIHRydWUpXG4gICAgICAgICAgICAvLyBOT1RFOiBtb3VzZW92ZXIgdXNlZCBpbnN0ZWFkIG9mIGNzcyBob3ZlciB0byBhbGxvdyBncmVhdGVyIGNvbnRyb2xcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxheSA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICBvdmVybGF5LmNsYXNzZWQoJ2RlbGV0ZS1vdmVybGF5JywgZC5ncmlkLmRlbGV0ZU92ZXJsYXkgJiYgIWQuZ3JpZC5oYXNFbXB0eVRpbGUoZC50aWxlKSk7XG4gICAgICAgICAgICAgICAgb3ZlcmxheS5jbGFzc2VkKCdzZWxlY3Qtb3ZlcmxheScsICFkLmdyaWQuZGVsZXRlT3ZlcmxheSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxheSA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICBvdmVybGF5LmNsYXNzZWQoJ2RlbGV0ZS1vdmVybGF5JywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gb25seSByZW1vdmUgc2VsZWN0LW92ZXJsYXkgaWYgdGlsZSBub3Qgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAoIWQuZ3JpZC5zZWxlY3RlZFRpbGVzLmhhcyhkLnRpbGUubm9kZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmNsYXNzZWQoJ3NlbGVjdC1vdmVybGF5JywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG51bWJlciBvdmVybGF5IGhpZGRlbiBieSBkZWZhdWx0XG4gICAgICAgIHRoaXMudGlsZU51bWJlckNvbnRhaW5lcnMgPSB0aGlzLnRpbGVJbWFnZUNvbnRhaW5lcnMuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgndGlsZS1udW1iZXItY29udGFpbmVyJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCB0aGlzLm51bWJlck92ZXJsYXkgPyAnJyA6ICdub25lJyk7XG5cbiAgICAgICAgdGhpcy50aWxlTnVtYmVyQmFja2dyb3VuZCA9IHRoaXMudGlsZU51bWJlckNvbnRhaW5lcnMuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMudGlsZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMudGlsZUhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCd0aWxlLW51bWJlci1iYWNrZ3JvdW5kJywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy50aWxlTnVtYmVycyA9IHRoaXMudGlsZU51bWJlckNvbnRhaW5lcnMuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgIC5hdHRyKCd4JywgJzUwJScpXG4gICAgICAgICAgICAuYXR0cigneScsICc1MCUnKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkLmNlbGwuaW5kICsgMSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCd0aWxlLW51bWJlcicsIHRydWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgdGlsZSB0aGF0IGlzIG92ZXJsYXBwaW5nLCBvciBudWxsIGlmIG5vIHRpbGUgZm91bmRcbiAgICBnZXRPdmVybGFwcGluZ1RpbGUoeCwgeSkge1xuXG4gICAgICAgIGlmICh4IDwgdGhpcy54IHx8IHggPiB0aGlzLnggKyB0aGlzLndpZHRoIHx8IHkgPCB0aGlzLnkgfHwgeSA+IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgW3JvdywgY29sXSA9IFt0aGlzLmdldFJvd0Zyb21ZKHkpLCB0aGlzLmdldENvbHVtbkZyb21YKHgpXTtcblxuICAgICAgICBsZXQgaW5kID0gdGhpcy5nZXRJbmRleEZyb21UaWxlQ29vcmQocm93LCBjb2wpO1xuXG4gICAgICAgIGxldCBvdmVybGFwID0gdGhpcy50aWxlQ29udGFpbmVycy5maWx0ZXIoZCA9PiBkLmNlbGwuaW5kID09PSBpbmQpO1xuICAgICAgICByZXR1cm4gb3ZlcmxhcC5lbXB0eSgpID8gbnVsbCA6IG92ZXJsYXA7XG5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb25zb2xpZGF0ZSBzZWN0aW9uIGludG8gTW92ZSBjbGFzc1xuICAgIC8vIFRPRE86IHByb2JhYmx5IGp1c3QgaGF2ZSBlYWNoIGZvcm0gb2YgZGF0YSBjb252ZXJ0IHRvIHNlbGVjdGVkIGludGVybWVkaWFyeSB0byByZWR1Y2UgZnVuY3Rpb24gYmxvYXRcbiAgICBnZXRSb3dGcm9tWSh5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCh5IC0gdGhpcy55KSAvIHRoaXMudGlsZUhlaWdodCk7XG4gICAgfVxuXG4gICAgZ2V0Um93RnJvbUluZGV4KGluZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihpbmQgLyB0aGlzLm51bUNvbHMpO1xuICAgIH1cblxuICAgIGdldENvbHVtbkZyb21YKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHggLSB0aGlzLngpIC8gdGhpcy50aWxlV2lkdGgpO1xuICAgIH1cblxuICAgIGdldENvbHVtbkZyb21JbmRleChpbmQpIHtcbiAgICAgICAgcmV0dXJuIGluZCAlIHRoaXMubnVtQ29scztcbiAgICB9XG5cbiAgICBnZXRUaWxlQ29vcmRGcm9tSW5kZXgoaW5kKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5nZXRSb3dGcm9tSW5kZXgoaW5kKSwgdGhpcy5nZXRDb2x1bW5Gcm9tSW5kZXgoaW5kKV07XG4gICAgfVxuXG4gICAgZ2V0SW5kZXhGcm9tVGlsZUNvb3JkKHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiByb3cgKiB0aGlzLm51bUNvbHMgKyBjb2w7XG4gICAgfVxuXG4gICAgZ2V0SW5kZXhGcm9tQ29vcmQoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3dGcm9tWSh5KSAqIHRoaXMubnVtQ29scyArIHRoaXMuZ2V0Q29sdW1uRnJvbVgoeCk7XG4gICAgfVxuXG4gICAgZ2V0WEZyb21Db2x1bW4oY29sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyBjb2wgKiB0aGlzLnRpbGVXaWR0aDtcbiAgICB9XG5cbiAgICBnZXRZRnJvbVJvdyhyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueSArIHJvdyAqIHRoaXMudGlsZUhlaWdodDtcbiAgICB9XG5cbiAgICBnZXRYRnJvbUluZGV4KGluZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW5Gcm9tSW5kZXgoaW5kKSAqIHRpbGVXaWR0aDtcbiAgICB9XG5cbiAgICBnZXRZRnJvbUluZGV4KGluZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3dGcm9tSW5kZXgoaW5kKSAqIHRpbGVIZWlnaHQ7XG4gICAgfVxuXG4gICAgZ2V0Q29vcmRGcm9tSW5kZXgoaW5kKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5nZXRYRnJvbUluZGV4KGluZCksIHRoaXMuZ2V0WUZyb21JbmRleChpbmQpXTtcbiAgICB9XG5cbiAgICBnZXRDb29yZEZyb21UaWxlQ29vcmQocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmdldFhGcm9tQ29sdW1uKGNvbCksIHRoaXMuZ2V0WUZyb21Sb3cocm93KV07XG4gICAgfVxuXG5cbiAgICBzd2FwVGlsZURhdGEoYSwgYikge1xuICAgICAgICBsZXQgdGlsZTEgPSB0aGlzLl9jb252ZXJ0SW5wdXRGb3JtYXQoW2FdKTtcbiAgICAgICAgbGV0IHRpbGUyID0gdGhpcy5fY29udmVydElucHV0Rm9ybWF0KFtiXSk7XG5cbiAgICAgICAgbGV0IGRhdGExID0gdGlsZTEuZGF0dW0oKTtcbiAgICAgICAgbGV0IGRhdGEyID0gdGlsZTIuZGF0dW0oKTtcblxuICAgICAgICBbZGF0YTEuY2VsbCwgZGF0YTIuY2VsbF0gPSBbZGF0YTIuY2VsbCwgZGF0YTEuY2VsbF07XG4gICAgfVxuXG4gICAgLy8gV0FSTklORzogT25seSB3b3JrcyB3aXRoaW4gc2FtZSBwdXp6bGVcbiAgICAvLyBzd2FwcyB0aWxlQ29udGFpbmVyIHNlbGVjdGlvbnNcbiAgICAvLyBhLCBiIGNhbiBiZSBmbGF0dGVuZWQgaW5kZXgsIHRpbGVDb250YWluZXIgRE9NIEVsZW1lbnQgb3IgZDMgc2VsZWN0aW9uXG4gICAgc3dhcFRpbGUoYSwgYikge1xuICAgICAgICBsZXQgdGlsZTEgPSB0aGlzLl9jb252ZXJ0SW5wdXRGb3JtYXQoW2FdKTtcbiAgICAgICAgbGV0IHRpbGUyID0gdGhpcy5fY29udmVydElucHV0Rm9ybWF0KFtiXSk7XG5cbiAgICAgICAgdGhpcy5zd2FwVGlsZURhdGEodGlsZTEsIHRpbGUyKTtcblxuICAgICAgICB0aWxlMS5hdHRyKCd4JywgZCA9PiBkLmNlbGwueCkuYXR0cigneScsIGQgPT4gZC5jZWxsLnkpO1xuICAgICAgICB0aWxlMi5hdHRyKCd4JywgZCA9PiBkLmNlbGwueCkuYXR0cigneScsIGQgPT4gZC5jZWxsLnkpO1xuXG4gICAgfVxuXG4gICAgLy8gc2V0cyBnb2FsIGltYWdlIHRvIGNsb25lIG9mIHN0YXJ0IGltYWdlXG4gICAgLy8gTk9URTogZHVwbGljYXRlIHRpbGVzIGFyZSBub3QgYWxsb3dlZCBpbiB0aGUgc2FtZSBncmlkXG4gICAgLy8gaWYgY2xvbmUgd291bGQgY2F1c2UgZHVwbGljYXRlLCBvcmlnaW5hbCB0aWxlIGluc3RlYWQgbW92ZWQgdG8vc3dhcHBlZCB3aXRoIGdvYWwgdGlsZVxuICAgIC8vIHN0YXJ0LCBnb2FsID0gdGlsZUNvbnRhaW5lciAoZDMuc2VsZWN0aW9uIG9yIERPTSBlbGVtZW50KVxuICAgIHN0YXRpYyBjbG9uZVRpbGUoc3RhcnQsIGdvYWwpIHtcblxuICAgICAgICBsZXQgdGlsZUNvbnRhaW5lclN0YXJ0ID0gc3RhcnQgaW5zdGFuY2VvZiBkMy5zZWxlY3Rpb24gPyBzdGFydCA6IGQzLnNlbGVjdChzdGFydCksXG4gICAgICAgICAgICB0aWxlQ29udGFpbmVyR29hbCA9IGdvYWwgaW5zdGFuY2VvZiBkMy5zZWxlY3Rpb24gPyBnb2FsIDogZDMuc2VsZWN0KGdvYWwpO1xuXG4gICAgICAgIGxldCBzdGFydERhdGEgPSB0aWxlQ29udGFpbmVyU3RhcnQuZGF0dW0oKSxcbiAgICAgICAgICAgIGdvYWxEYXRhID0gdGlsZUNvbnRhaW5lckdvYWwuZGF0dW0oKTtcblxuICAgICAgICBsZXQgc3RhcnRHcmlkID0gc3RhcnREYXRhLmdyaWQsXG4gICAgICAgICAgICBnb2FsR3JpZCA9IGdvYWxEYXRhLmdyaWQ7XG5cbiAgICAgICAgbGV0IG1hdGNoID0gZ29hbEdyaWQudGlsZUNvbnRhaW5lcnMuZmlsdGVyKGQgPT4gXG4gICAgICAgICAgICBkLmltZyAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgICAgICAgZC5pbWcub2Zmc2V0WCA9PT0gc3RhcnREYXRhLmltZy5vZmZzZXRYICYmXG4gICAgICAgICAgICBkLmltZy5vZmZzZXRZID09PSBzdGFydERhdGEuaW1nLm9mZnNldFkgJiZcbiAgICAgICAgICAgIGQuaW1nLnNyYyA9PT0gc3RhcnREYXRhLmltZy5zcmNcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIW1hdGNoLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGdvYWxHcmlkLnN3YXBUaWxlKG1hdGNoLCB0aWxlQ29udGFpbmVyR29hbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnb2FsRGF0YS5zdGFydFRpbGUgPSB0aWxlQ29udGFpbmVyU3RhcnQ7XG5cbiAgICAgICAgZ29hbEdyaWQuc2hvd1RpbGUodGlsZUNvbnRhaW5lckdvYWwpO1xuICAgICAgICBsZXQgaW1hZ2VBdEdvYWwgPSB0aWxlQ29udGFpbmVyR29hbC5zZWxlY3QoJ2ltYWdlJyk7XG5cbiAgICAgICAgaWYgKGltYWdlQXRHb2FsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGltYWdlQXRHb2FsID0gdGlsZUNvbnRhaW5lckdvYWwuaW5zZXJ0KCdpbWFnZScsICc6Zmlyc3QtY2hpbGQnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZ29hbEdyaWQud2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZ29hbEdyaWQuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdvYWxEYXRhLmltZyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXJ0RGF0YS5pbWcpO1xuXG4gICAgICAgIGltYWdlQXRHb2FsLmF0dHIoJ3gnLCBkID0+IGQuaW1nLm9mZnNldFgpXG4gICAgICAgICAgICAuYXR0cigneScsIGQgPT4gZC5pbWcub2Zmc2V0WSlcbiAgICAgICAgICAgIC5hdHRyKCd4bGluazpocmVmJywgZCA9PiBkLmltZy5zcmMpXG4gICAgICAgICAgICAuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICdub25lJyk7XG5cbiAgICAgICAgdGlsZUNvbnRhaW5lckdvYWxcbiAgICAgICAgICAgIC5zZWxlY3QoJy50aWxlLW51bWJlcicpXG4gICAgICAgICAgICAudGV4dChkID0+IGQuc3RhcnRUaWxlLmRhdHVtKCkuc3RhcnQuaW5kICsgMSk7XG5cbiAgICAgICAgaWYgKGdvYWxHcmlkLm51bWJlck92ZXJsYXkpIHtcbiAgICAgICAgICAgIHRpbGVDb250YWluZXJHb2FsLnNlbGVjdCgnLnRpbGUtbnVtYmVyLWNvbnRhaW5lcicpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICBnb2FsR3JpZC5fZW1wdHlUaWxlcy5kZWxldGUodGlsZUNvbnRhaW5lckdvYWwubm9kZSgpKTtcbiAgICB9XG5cbiAgICBkcm9wVGlsZSh0aWxlQ29udGFpbmVyU3RhcnQsIHgsIHkpIHtcbiAgICAgICAgbGV0IG92ZXJsYXAgPSB0aGlzLmdldE92ZXJsYXBwaW5nVGlsZSh4LCB5KTtcblxuICAgICAgICBpZiAob3ZlcmxhcCkge1xuICAgICAgICAgICAgR3JpZC5jbG9uZVRpbGUodGlsZUNvbnRhaW5lclN0YXJ0LCBvdmVybGFwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpc0Z1bGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbXB0eVRpbGVzLnNpemUgPT09IDE7XG4gICAgfVxuXG4gICAgX2dlbmVyYXRlR3JpZERhdGFIZWxwZXIocm93LCBjb2wpIHtcbiAgICAgICAgbGV0IFt4LCB5XSA9IHRoaXMuZ2V0Q29vcmRGcm9tVGlsZUNvb3JkKHJvdywgY29sKTtcbiAgICAgICAgbGV0IGluZCA9IHRoaXMuZ2V0SW5kZXhGcm9tVGlsZUNvb3JkKHJvdywgY29sKTtcbiAgICAgICAgLy8gKHgsIHkpID0gY29vcmRzIG9mIGdyaWQgY2VsbFxuICAgICAgICBsZXQgY3VyciA9IHtcbiAgICAgICAgICAgIGdyaWQ6IHRoaXMsXG4gICAgICAgICAgICBjZWxsIDoge1xuICAgICAgICAgICAgICAgIHgsIFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgICAgICBpbmRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgeDogeCwgXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgIGluZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5pbWFnZVNyYykge1xuICAgICAgICAgICAgLy8gKHgsIHkpID0gY29vcmRzIG9mIGltYWdlQ29udGFpbmVyXG4gICAgICAgICAgICBjdXJyLmltZyA9IHtcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQgc28gdGhhdCBzZWN0aW9uIG9mIGltYWdlIHNob3duIGNvcnJlc3BvbmRzIHRvIHRpbGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICBvZmZzZXRYOiAtKHggLSB0aGlzLngpLFxuICAgICAgICAgICAgICAgIG9mZnNldFk6IC0oeSAtIHRoaXMueSksXG4gICAgICAgICAgICAgICAgc3JjOiB0aGlzLmltYWdlU3JjLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycjtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZUdyaWREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLm51bVJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLm51bUNvbHM7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHRoaXMuX2dlbmVyYXRlR3JpZERhdGFIZWxwZXIocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cblxuICAgIGdldE1vdmVJbmZvKG1vdmUpIHtcbiAgICAgICAgY29uc3QgbW92ZURpY3QgPSB7XG4gICAgICAgICAgICBsOiB7ZGVsdGE6IC0xLCBkeDogLXRoaXMudGlsZVdpZHRoLCBkeTogMH0sXG4gICAgICAgICAgICByOiB7ZGVsdGE6IDEsIGR4OiB0aGlzLnRpbGVXaWR0aCwgZHk6IDB9LFxuICAgICAgICAgICAgdToge2RlbHRhOiAtdGhpcy5udW1Db2xzLCBkeDogMCwgZHk6IC10aGlzLnRpbGVIZWlnaHR9LFxuICAgICAgICAgICAgZDoge2RlbHRhOiB0aGlzLm51bUNvbHMsIGR4OiAwLCBkeTogdGhpcy50aWxlSGVpZ2h0fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3ZlRGljdFttb3ZlXTtcblxuICAgIH1cblxuICAgIC8vIFRPRE86IGRpc2FibGUgYnV0dG9ucyBhbmQgdGlsZSBzZWxlY3Rpb24vZGVsZXRpb24gZHVyaW5nIGFuaW1hdGlvbiBcbiAgICAvLyAoYW5kL29yIG1ha2UgdGhlbSByZXNldCBwdXp6bGUgYW5kIHN0b3AgYW5pbWF0ZU1vdmVzKVxuICAgIC8vIFdBUk5JTkc6IHdpbGwgbm90IHdvcmsgb24gaW5jb21wbGV0ZSBncmlkcyAod2hlcmUgbm90IGFsbCBpbWFnZXMgZmlsbGVkIGluIGFuZCBlbXB0eVBvcyBzcGVjaWZpZWQpXG4gICAgLy8gbW92ZXMgPSBhcnJheSBvZiBtb3ZlcyB0byBhbmltYXRlIGV4OiBbJ2wnLCAncicsICd1JywgJ2QnLCAuLi5dXG4gICAgLy8gcGFyZW50ID0gb3B0aW9uYWwgcGFyZW50IGVsZW1lbnQgdG8gaW5zZXJ0IGxpc3Qgb2YgbW92ZXMgaW5cbiAgICAvLyBkdXJhdGlvblBlck1vdmUgPSBtaWxsaXNlY29uZHMgaXQgdGFrZXMgZm9yIHNpbmdsZSBtb3ZlIHRvIGJlIGFuaW1hdGVkXG4gICAgYW5pbWF0ZU1vdmVzKG1vdmVzLCBwYXJlbnQgPSBudWxsLCBkdXJhdGlvblBlck1vdmU9MTApIHtcbiAgICAgICAgbGV0IGN1cnJQcm9taXNlID0gbnVsbDtcblxuICAgICAgICBsZXQgbGlzdCwgbGlzdEl0ZW1zLCBsaXN0SXRlbXNET007XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudCBpbnN0YW5jZW9mIGQzLnNlbGVjdGlvbiA/IHBhcmVudCA6IGQzLnNlbGVjdChwYXJlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsaXN0ID0gcGFyZW50LnNlbGVjdCgnb2wnKTtcbiAgICAgICAgICAgIGlmIChsaXN0LmVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBsaXN0ID0gcGFyZW50LmFwcGVuZCgnb2wnKVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnbGlzdC1ncm91cCcsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdtb3ZlLWxpc3QnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gdXBkYXRlIGRhdGEgb2YgZXhpc3RpbmcgZWxlbWVudHNcbiAgICAgICAgICAgIGxldCB1cGRhdGVMaXN0ID0gbGlzdC5zZWxlY3RBbGwoJ2xpJykuZGF0YShtb3Zlcyk7XG5cbiAgICAgICAgICAgIC8vIGVudGVyL2FwcGVuZCBtaXNzaW5nIGxpc3QgaXRlbXNcbiAgICAgICAgICAgIGxldCBlbnRlckxpc3QgPSB1cGRhdGVMaXN0LmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaScpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2xpc3QtZ3JvdXAtaXRlbScsIHRydWUpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ21vdmUtbGlzdC1pdGVtJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIGFsbCBpdGVtcyBpbiBsaXN0IHVwZGF0ZSB0ZXh0IHRvIG1hdGNoIG5ldyBtb3Zlc1xuICAgICAgICAgICAgbGV0IGxpc3RJdGVtcyA9IHVwZGF0ZUxpc3QubWVyZ2UoZW50ZXJMaXN0KVxuICAgICAgICAgICAgICAgIC50ZXh0KChkLCBpKSA9PiBNb3ZlLmdldEZ1bGxOYW1lKG1vdmVzW2ldKSk7XG5cbiAgICAgICAgICAgIC8vIGV4dHJhIGxpc3QgaXRlbXMgd2l0aCBubyBhc3NvY2lhdGVkIG1vdmVzIHJlbW92ZWRcbiAgICAgICAgICAgIHVwZGF0ZUxpc3QuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBsaXN0SXRlbXNET00gPSBsaXN0SXRlbXMubm9kZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtb3ZlID0gbW92ZXNbaV07XG4gICAgICAgICAgICBsZXQgcGFyYW1zID0gW21vdmVdO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gobGlzdEl0ZW1zRE9NW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJQcm9taXNlID0gdGhpcy5hbmltYXRlTW92ZSguLi5wYXJhbXMsIGR1cmF0aW9uUGVyTW92ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJQcm9taXNlID0gY3VyclByb21pc2UudGhlbigoKSA9PiB0aGlzLmFuaW1hdGVNb3ZlKC4uLnBhcmFtcywgZHVyYXRpb25QZXJNb3ZlKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgY2F0Y2hpbmcgZXJyb3Igc2lsZW50bHkgdG8gc3RvcCBlcnJvcnMgZnJvbSBwaWxpbmcgdXAgaW4gY29uc29sZVxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBlcnJvbmVvdXMga2V5IHByZXNzZXMgYXJlIGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsdGVybmF0aXZlbHksIGp1c3QgcmV0dXJuIHRydWUvZmFsc2UgZnJvbSBhbmltYXRlTW92ZSBhbmQgYmUgZG9uZSB3aXRoIGl0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIFRPRE86IGNvbnNpZGVyIHVzaW5nIGQzJ3MgdHJhbnNpdGlvbiBzeW50YXggcmF0aGVyIHRoYW4gUHJvbWlzZSB3cmFwcGluZ1xuICAgIC8vIHBybzogY2FuIHByb2JhYmx5IHVzZSB0cmFuc2l0aW9uLmludGVycnVwdCBmb3IgYSBcInN0b3BcIiBmZWF0dXJlXG4gICAgLy8gYWx0ZXJuYXRpdmVseSwgY29uc2lkZXIgdXNpbmcgYXN5bmMvYXdhaXRcblxuICAgIC8vIGFuaW1hdGVzIG1vdmUgYW5kIHJldHVybnMgYXNzb2NpYXRlZCBUcmFuc2l0aW9uIFByb21pc2VcbiAgICAvLyBtb3ZlIHdpdGhpbiB7J2wnLCAncicsICdkJywgJ3UnfVxuICAgIC8vIGxpc3RJdGVtID0gPGxpPiBET00gZWxlbWVudCBjb250YWluaW5nIG1vdmUgc3RyaW5nXG4gICAgLy8gLSBsaXN0SXRlbSBoaWdobGlnaHRlZCB3aGVuIGNvcnJlc3BvbmRpbmcgbW92ZSBpcyBwbGF5ZWRcbiAgICAvLyBkdXJhdGlvbiA9IG1pbGxpc2Vjb25kcyBpdCB0YWtlcyB0byBhbmltYXRlIG1vdmVcbiAgICBhbmltYXRlTW92ZShtb3ZlLCBsaXN0SXRlbSA9IG51bGwsIGR1cmF0aW9uPTEwKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5Nb3ZlKG1vdmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTW92ZTogJHttb3ZlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1vdmVJbmZvID0gdGhpcy5nZXRNb3ZlSW5mbyhtb3ZlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAobGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBsaXN0SXRlbS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUtbW92ZScpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlY29uc2lkZXIgd2hldGhlciB0byB1c2UgKG1pZ2h0IGhpZGUgdGlsZSBzbGlkaW5nIG9uIGNlcnRhaW4gc2NyZWVuIHNpemVzKVxuICAgICAgICAgICAgICAgIGxpc3RJdGVtLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW92ZWRUaWxlID0gdGhpcy50aWxlQ29udGFpbmVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZCA9PiBkLmNlbGwuaW5kID09PSB0aGlzLmVtcHR5UG9zIC0gbW92ZUluZm8uZGVsdGEpO1xuICAgICAgICAgICAgbGV0IGVtcHR5VGlsZSA9IHRoaXMudGlsZUNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGQgPT4gZC5jZWxsLmluZCA9PT0gdGhpcy5lbXB0eVBvcyk7XG5cbiAgICAgICAgICAgIHRoaXMuc3dhcFRpbGVEYXRhKG1vdmVkVGlsZSwgZW1wdHlUaWxlKTtcbiAgICAgICAgICAgIGVtcHR5VGlsZVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZCA9PiBkLmNlbGwueClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGQgPT4gZC5jZWxsLnkpO1xuXG4gICAgICAgICAgICBtb3ZlZFRpbGVcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZGVjcmVhc2Ugc3BlZWQgYWZ0ZXIgdGVzdGluZ1xuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGQgPT4gZC5jZWxsLngpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBkID0+IGQuY2VsbC55KVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdEl0ZW0pIGxpc3RJdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZS1tb3ZlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjYW5Nb3ZlKG1vdmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtcHR5VGlsZXMuc2l6ZSA9PT0gdGhpcy5udW1DZWxscykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGNvbnNvbGlkYXRlIHdpdGggb3RoZXIgbW92ZSB1dGlsaXR5IGZ1bmN0aW9ucyB0byBzZXBhcmF0ZSAobmVzdGVkPykgTW92ZSBjbGFzc1xuICAgICAgICBjb25zdCBtb3ZlRGljdCA9IHtcbiAgICAgICAgICAgIGw6IHtkUm93OiAwLCBkQ29sOiAtMX0sXG4gICAgICAgICAgICByOiB7ZFJvdzogMCwgZENvbDogMX0sXG4gICAgICAgICAgICB1OiB7ZFJvdzogLTEsIGRDb2w6IDB9LFxuICAgICAgICAgICAgZDoge2RSb3c6IDEsIGRDb2w6IDB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbW92ZUluZm8gPSBtb3ZlRGljdFttb3ZlXTtcblxuICAgICAgICBsZXQgW3JvdywgY29sXSA9IHRoaXMuZ2V0VGlsZUNvb3JkRnJvbUluZGV4KHRoaXMuZW1wdHlQb3MpO1xuXG4gICAgICAgIGxldCBtb3ZlZFRpbGUgPSB7cm93OiByb3cgLSBtb3ZlSW5mby5kUm93LCBjb2w6IGNvbCAtIG1vdmVJbmZvLmRDb2x9O1xuXG4gICAgICAgIHJldHVybiBtb3ZlZFRpbGUucm93ID49IDAgJiYgbW92ZWRUaWxlLnJvdyA8IHRoaXMubnVtUm93c1xuICAgICAgICAgICAgJiYgbW92ZWRUaWxlLmNvbCA+PSAwICYmIG1vdmVkVGlsZS5jb2wgPCB0aGlzLm51bUNvbHM7XG4gICAgfVxuXG4gICAgLy8gYXJncyA9IGluZCBvciByb3csIGNvbFxuICAgIGhhc1RpbGVBdCguLi5hcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbGV0IGluZCA9IGFyZ3NbMF07XG4gICAgICAgICAgICByZXR1cm4gaW5kICE9PSB0aGlzLmVtcHR5UG9zICYmIGluZCA+PSAwICYmIGluZCA8IHRoaXMubnVtQ2VsbHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGxldCBbcm93LCBjb2xdID0gYXJncztcbiAgICAgICAgICAgIHJldHVybiByb3cgPj0gMCAmJiByb3cgPCB0aGlzLm51bVJvd3MgJiYgY29sID49IDAgJiYgY29sIDwgdGhpcy5udW1Db2xzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0VGlsZSguLi5hcmdzKSB7XG4gICAgICAgIGxldCB0aWxlID0gdGhpcy5fY29udmVydElucHV0Rm9ybWF0KGFyZ3MpO1xuICAgICAgICBsZXQgb3ZlcmxheSA9IHRpbGUuc2VsZWN0KCcudGlsZS1vdmVybGF5Jyk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZFRpbGVzLmFkZCh0aWxlLm5vZGUoKSk7XG4gICAgICAgIG92ZXJsYXkuY2xhc3NlZCgnc2VsZWN0LW92ZXJsYXknLCB0cnVlKTtcbiAgICB9XG5cbiAgICBkZXNlbGVjdFRpbGUoLi4uYXJncykge1xuICAgICAgICBsZXQgdGlsZSA9IHRoaXMuX2NvbnZlcnRJbnB1dEZvcm1hdChhcmdzKTtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSB0aWxlLnNlbGVjdCgnLnRpbGUtb3ZlcmxheScpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUaWxlcy5kZWxldGUodGlsZS5ub2RlKCkpO1xuICAgICAgICBvdmVybGF5LmNsYXNzZWQoJ3NlbGVjdC1vdmVybGF5JywgZmFsc2UpO1xuICAgIH1cblxuICAgIGRlc2VsZWN0QWxsKCkge1xuICAgICAgICBsZXQgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMudGlsZUNvbnRhaW5lcnMuZWFjaChkID0+IHRoaXMuZGVzZWxlY3RUaWxlKGQudGlsZSkpO1xuICAgIH1cblxuICAgIC8vIHRvZ2dsZXMgd2hldGhlciB0aWxlIGlzIHNlbGVjdGVkIG9yIG5vdFxuICAgIC8vIHJldHVybnMgd2hldGhlciB0aWxlIGlzIHNlbGVjdGVkIG9yIG5vdCBhZnRlciB0b2dnbGVcbiAgICAvLyBhcmdzID0gdGlsZUNvbnRhaW5lciBET00gRWxlbWVudC9kMyBzZWxlY3Rpb24gT1IgaW5kZXhcbiAgICB0b2dnbGVUaWxlU2VsZWN0KC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHRpbGUgPSB0aGlzLl9jb252ZXJ0SW5wdXRGb3JtYXQoYXJncyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gdGlsZS5zZWxlY3QoJy50aWxlLW92ZXJsYXknKTtcblxuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBvdmVybGF5LmNsYXNzZWQoJ3NlbGVjdC1vdmVybGF5Jyk7XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRpbGVzLmFkZCh0aWxlLm5vZGUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkVGlsZXMuZGVsZXRlKHRpbGUubm9kZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG92ZXJsYXkuY2xhc3NlZCgnc2VsZWN0LW92ZXJsYXknLCAhc2VsZWN0ZWQpO1xuXG4gICAgICAgIHJldHVybiAhc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgLy8gY2xpY2tzIHNwZWNpZmllZCB0aWxlXG4gICAgLy8gcmV0dXJucyBvYmplY3Qgd2l0aDpcbiAgICAvLyAtICdtZXRob2QnOiBkZWxldGUvc3dhcC9kZXNlbGVjdC9zZWxlY3RcbiAgICAvLyAtIHRpbGUgKHNvbWV0aW1lcyk6IHRpbGVDb250YWluZXIgc2VsZWN0aW9uIGRlbGV0ZWQvZGVzZWxlY3RlZC9zZWxlY3RlZFxuICAgIC8vIC0gdGlsZTEvdGlsZTIgKHNvbWV0aW1lcykgOiB0aWxlcyBzd2FwcGVkXG4gICAgLy8gYXJncyA9IHRpbGVDb250YWluZXIgRE9NIEVsZW1lbnQvZDMgc2VsZWN0aW9uIE9SIGluZGV4XG4gICAgY2xpY2tUaWxlKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHRpbGVDb250YWluZXIgPSB0aGlzLl9jb252ZXJ0SW5wdXRGb3JtYXQoYXJncyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVsZXRlT3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGVUaWxlKHRpbGVDb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSh0aWxlQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHJldHVybiB7bWV0aG9kOiAnZGVsZXRlJywgdGlsZTogdGlsZUNvbnRhaW5lcn07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYWxyZWFkeVNlbGVjdGVkVGlsZSA9IHRoaXMuc2VsZWN0ZWRUaWxlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgIGlmIChhbHJlYWR5U2VsZWN0ZWRUaWxlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0VGlsZShhbHJlYWR5U2VsZWN0ZWRUaWxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGFscmVhZHlTZWxlY3RlZFRpbGUgIT09IHRpbGVDb250YWluZXIubm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2FwVGlsZShhbHJlYWR5U2VsZWN0ZWRUaWxlLCB0aWxlQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KHRpbGVDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7bWV0aG9kOiAnc3dhcCcsIHRpbGUxOiB0aWxlQ29udGFpbmVyLCB0aWxlMjogYWxyZWFkeVNlbGVjdGVkVGlsZX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge21ldGhvZDogJ2Rlc2VsZWN0JywgdGlsZTogdGlsZUNvbnRhaW5lcn07XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0VGlsZSh0aWxlQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHJldHVybiB7bWV0aG9kOiAnc2VsZWN0JywgdGlsZTogdGlsZUNvbnRhaW5lcn07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgaGFzRW1wdHlUaWxlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtcHR5VGlsZXMuaGFzKHRoaXMuX2NvbnZlcnRJbnB1dEZvcm1hdChhcmdzKS5ub2RlKCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBwZXJmb3JtcyBzb21ld2hhdCBiaWFzZWQgc2h1ZmZsZSB3aGVyZSBzaHVmZmxlZCBzdGF0ZSBjYW5ub3QgZXF1YWwgb3JpZ2luYWwgc3RhdGVcbiAgICAvLyBOT1RFOiBhc3N1bWVzIGN1cnJlbnQgc3RhdGUgaXMgc29sdmFibGVcbiAgICAvLyBzZWUgY29tbWVudCBvbiBpc1NvbHZhYmxlKCkgZm9yIG1vcmUgZXhwbGFuYXRpb24gb24gaG93IHNvbHZhYmlsaXR5IGd1YXJhbnRlZWRcbiAgICBzaHVmZmxlKCkge1xuICAgICAgICBcbiAgICAgICAgLy8gc2h1ZmZsaW5nIGZvciAxRCBwdXp6bGVzIHJhbmRvbWx5IGNoYW5nZXMgZW1wdHlQb3MgYW5kIHNoaWZ0cyB0aWxlcyBvdXQgb2YgdGhlIHdheVxuICAgICAgICBpZiAodGhpcy5udW1Sb3dzID09PSAxIHx8IHRoaXMubnVtQ29scyA9PT0gMSkge1xuXG4gICAgICAgICAgICBsZXQgbmV3RW1wdHlQb3MgPSB0aGlzLmVtcHR5UG9zO1xuICAgICAgICAgICAgLy8gTk9URTogd2hpbGUgY291bGQgbG9vcCBpbmZpbml0ZWx5LCB1bmxpa2VseSB1bmxlc3MgcHV6emxlIGlzIDF4MSwgd2hpY2ggaXMgbm90IGFsbG93ZWRcbiAgICAgICAgICAgIHdoaWxlIChuZXdFbXB0eVBvcyA9PT0gdGhpcy5lbXB0eVBvcykge1xuICAgICAgICAgICAgICAgIG5ld0VtcHR5UG9zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5udW1DZWxscyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmVtcHR5UG9zIDwgbmV3RW1wdHlQb3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5lbXB0eVBvczsgaSA8IG5ld0VtcHR5UG9zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2FwVGlsZShpLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5lbXB0eVBvczsgaSA+IG5ld0VtcHR5UG9zOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2FwVGlsZShpLCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcnJheSByZXByZXNlbnRhdGlvbiBvZiBwdXp6bGUgYXNzdW1pbmcgdGhhdCBzdGFydCBpcyBnb2FsIHN0YXRlIGFuZCBzaHVmZmxlZCBzdGF0ZSBpcyBzdGFydCBzdGF0ZVxuICAgICAgICBsZXQgYXJyID0gdGhpcy5fZmlzaGVyWWF0ZXNTaHVmZmxlKCk7XG5cbiAgICAgICAgLy8gaWYgcHV6emxlIGlzbid0IHNvbHZhYmxlLCBhIHN3YXAgb2YgaG9yaXpvbnRhbGx5IG5laWdoYm9yaW5nIHRpbGVzIGluY3JlYXNlcyAjIGludmVyc2lvbnMgYnkgMVxuICAgICAgICAvLyB0aGlzIG1ha2VzIHB1enpsZSBzb2x2YWJsZSBmb3IgYWxsIDJEIHB1enpsZXMgKGJvdGggZGltZW5zaW9ucyA+IDEpXG4gICAgICAgIGlmICghR3JpZC5faXNTb2x2YWJsZShhcnIsIHRoaXMuZW1wdHlQb3MsIHRoaXMubnVtUm93cywgdGhpcy5udW1Db2xzKSkge1xuICAgICAgICAgICAgbGV0IGksIGo7XG4gICAgICAgICAgICBpZiAodGhpcy5lbXB0eVBvcyA8IDIpIHtcbiAgICAgICAgICAgICAgICBpID0gdGhpcy5udW1DZWxscyAtIDI7XG4gICAgICAgICAgICAgICAgaiA9IHRoaXMubnVtQ2VsbHMgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBqID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3dhcFRpbGUoaSwgaik7XG4gICAgICAgICAgICBbYXJyW2ldLCBhcnJbal1dID0gW2FycltqXSwgYXJyW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnRzIHNhbWUgaW5pdGlhbCBzdGF0ZSBmcm9tIHJlcGVhdGluZyBcbiAgICAgICAgLy8gTk9URTogY291bGQgbG9vcCBpbmZpbml0ZWx5LCBidXQgdW5saWtlbHkgdW5sZXNzIHB1enpsZSBpcyAxeDEsIHdoaWNoIHNob3VsZCBiZSBwcmV2ZW50ZWRcbiAgICAgICAgaWYgKGFyci5ldmVyeSgoZ29hbEluZCwgaW5kKSA9PiBnb2FsSW5kID09PSBpbmQpKSB7XG4gICAgICAgICAgICB0aGlzLnNodWZmbGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNodWZmbGVzIHB1enpsZSByYW5kb21seSB1c2luZyB0aGUgRmlzaGVyIFlhdGVzL0tudXRoIHNodWZmbGluZyBhbGdvcml0aG1cbiAgICAvLyByZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHB1enpsZSBhc3N1bWluZyB0aGF0IHN0YXJ0aW5nIHBvc2l0aW9uIGlzIGdvYWwgc3RhdGUgYW5kXG4gICAgLy8gc2h1ZmZsZWQgc3RhdGUgaXMgc3RhcnQgc3RhdGVcbiAgICAvLyBXQVJOSU5HOiBJcyBOT1QgZ3VhcmFudGVlZCB0byByZXR1cm4gYSBzb2x2YWJsZSBzdGF0ZVxuICAgIF9maXNoZXJZYXRlc1NodWZmbGUoKSB7XG5cbiAgICAgICAgLy8gYXJyIGJlY29tZXMgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgcHV6emxlXG4gICAgICAgIGxldCBhcnIgPSBkMy5yYW5nZSh0aGlzLm51bUNlbGxzKTtcbiAgICAgICAgLy8gc3dhcHMgZWFjaCBlbGVtZW50IHdpdGggaXRzZWxmIG9yIGFuIGVsZW1lbnQgYWZ0ZXIgaXRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChhcnIubGVuZ3RoIC0gaSkgKyBpKTtcblxuICAgICAgICAgICAgW2FycltpXSwgYXJyW2pdXSA9IFthcnJbal0sIGFycltpXV07XG4gICAgICAgICAgICAvLyBjb3VsZCBiZSBtYWRlIHNsaWdodGx5IGZhc3RlciBieSB1c2luZyBzd2FwRGF0YSBhbmQgb25seSByZWRyYXdpbmcgdGlsZXMgYXQgdGhlIGVuZFxuICAgICAgICAgICAgdGhpcy5zd2FwVGlsZShpLCBqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIC8vIGJpYXNlZCBzaHVmZmxlIHdoZXJlIHNodWZmbGVkIHN0YXRlIGNhbm5vdCBlcXVhbCBvcmlnaW5hbCBzdGF0ZSB1c2luZyBTYXR0b2xvJ3MgYWxnb3JpdGhtXG4gICAgLy8gZWFjaCBhcnIgdmFsdWUgd2lsbCBiZSBpbiBhIGRpZmZlcmVudCBwb3NpdGlvbiB0aGFuIGl0cyBpbml0aWFsIHBvc2l0aW9uXG4gICAgLy8gV0FSTklORzogSXMgTk9UIGd1YXJhbnRlZWQgdG8gcmV0dXJuIGEgc29sdmFibGUgc3RhdGVcbiAgICBfc2F0dG9sb1NodWZmbGUoKSB7XG4gICAgICAgIGxldCBhcnIgPSBkMy5yYW5nZSh0aGlzLm51bUNlbGxzKTtcbiAgICAgICAgLy8gc3dhcHMgZWFjaCBlbGVtZW50IHdpdGggYW4gZWxlbWVudCBhZnRlciBpdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGFyci5sZW5ndGggLSBpKSArIGkgKyAxKTtcbiAgICAgICAgICAgIFthcnJbaV0sIGFycltqXV0gPSBbYXJyW2pdLCBhcnJbaV1dO1xuICAgICAgICAgICAgdGhpcy5zd2FwVGlsZShpLCBqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIC8vIFRPRE86IG1vZGlmeSB0byBzdXBwb3J0IGZvcm1hdHMgb3RoZXIgdGhhbiBkMy5zZWxlY3Rpb25cbiAgICBfY29udmVydElucHV0Rm9ybWF0KGFyZ3MsIGZvcm1hdD0nZDMuc2VsZWN0aW9uJykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBhcmcgPSBhcmdzWzBdO1xuICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIGQzLnNlbGVjdGlvbikgcmV0dXJuIGFyZztcbiAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBFbGVtZW50KSByZXR1cm4gZDMuc2VsZWN0KGFyZyk7XG4gICAgICAgICAgICAvLyBjb252ZXJ0cyBmcm9tIGluZGV4XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmcpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSB0aGlzLnRpbGVDb250YWluZXJzLmZpbHRlcihkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY2VsbC5pbmQgPT09IGFyZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcC5lbXB0eSgpID8gbnVsbCA6IHRlbXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGZsYXR0ZW5lZCBhcnJheSAobGVmdCB0byByaWdodCwgdG9wIHRvIGJvdHRvbSkgb2YgYXJyYXkgaW5kaWNlcyBvZiB0aWxlcyBpbiB0aGVcbiAgICAvLyBnb2FsR3JpZCB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGltYWdlIG9yZGVyaW5nIGluIHRoZSBzdGFydEdyaWRcbiAgICAvLyBleDogc3RhcnRHcmlkID0gW2IsIGEsIGNdLCBnb2FsR3JpZCA9IFthLCBiLCBjXSwgcmV0dXJuID0gWzEsIDAsIDJdXG4gICAgLy8gZXhwbGFuYXRpb246IGIgPSBnb2FsR3JpZFsxXSwgYSA9IGdvYWxHcmlkWzBdLCBjID0gZ29hbEdyaWRbMl1cbiAgICBzdGF0aWMgZ2V0QXJyYXlSZXByZXNlbnRhdGlvbihzdGFydEdyaWQsIGdvYWxHcmlkKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBbXTtcbiAgICAgICAgZ29hbEdyaWQudGlsZUNvbnRhaW5lcnMuZGF0YSgpXG4gICAgICAgICAgICAuZmlsdGVyKGQgPT4gZC5pbWcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2Quc3RhcnRUaWxlLmRhdHVtKCkuY2VsbC5pbmRdID0gZC5jZWxsLmluZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBvdXRwdXRbc3RhcnRHcmlkLmVtcHR5UG9zXSA9IGdvYWxHcmlkLmVtcHR5UG9zO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLy8gRXhwbGFuYXRpb246IHBpY3R1cmUgcHV6emxlIGFzIGZsYXR0ZW5lZCBhcnJheVxuICAgIC8vIGludmVyc2lvbiA9IHBhaXIgb2YgdGlsZXMgaW4gaW5jb3JyZWN0IHBvc2l0aW9uIChhcnJbaV0gPiBhcnJbal0gJiYgaSA8IGopXG4gICAgLy9cbiAgICAvLyBleDogWzQsIDIsIDAsIDUsIDFdIGhhcyA2IGludmVyc2lvbnNcbiAgICAvLyA0ID4gWzIsIDAsIDFdLCAyID4gWzAsIDFdLCA1ID4gWzFdXG4gICAgLy9cbiAgICAvLyBpbiB0aGUgZ29hbCBzdGF0ZSwgdGhlIGFycmF5IHdvdWxkIHJlYWQ6IFswLCAxLCAyLCAzLCA0LCAuLi5dLCB3aXRoICMgaW52ZXJzaW9ucyA9IDBcbiAgICAvL1xuICAgIC8vIHNsaWRpbmcgcHV6emxlIGhvcml6b250YWxseSBkb2Vzbid0IGNoYW5nZSAjIGludmVyc2lvbnNcbiAgICAvLyBzbGlkaW5nIHB1enpsZSB2ZXJ0aWNhbGx5IGRvZXNcbiAgICAvL1xuICAgIC8vIGlmICMgY29scyA9IG9kZCwgc2xpZGluZyB2ZXJ0aWNhbGx5IGNoYW5nZXMgIyBpbnZlcnNpb25zIGJ5IGV2ZW4gbnVtYmVyXG4gICAgLy8gICAgICAoc2xpZGluZyB2ZXJ0aWNhbGx5IGNoYW5nZXMgcmVsYXRpb25zaGlwIG9mIHRpbGUgd2l0aCB3aWR0aCAtIDEgdGlsZXMpXG4gICAgLy9cbiAgICAvLyB0aGVyZWZvcmUsIHNvbHZhYmxlIHN0YXRlIG11c3QgaGF2ZSBldmVuIG51bWJlciBvZiBpbnZlcnNpb25zIGluIG9kZC1jb2wtcHV6emxlXG4gICAgLy9cbiAgICAvLyBpZiAjIGNvbHMgPSBldmVuLCBzbGlkaW5nIHZlcnRpY2FsbHkgY2hhbmdlcyAjIGludmVyc2lvbnMgYnkgb2RkIG51bWJlclxuICAgIC8vICAgICAgKHdpZHRoIC0gMSBub3cgb2RkKVxuICAgIC8vXG4gICAgLy8gaW4gZ29hbCBzdGF0ZSwgIyBpbnZlcnNpb25zID0gMCBhbmQgdmVydGljYWwgZGlzdGFuY2UgYmV0d2VlbiBlbXB0eVBvcydzIGN1cnJlbnQgYW5kIGdvYWwgc3RhdGUgPSAwXG4gICAgLy8gaW4gYSB2ZXJ0aWNhbCBtb3ZlLCAjIGludmVyc2lvbnMgYmVjb21lcyBvZGQgYW5kIGRpc3RhbmNlIGNoYW5nZXMgYnkgMSAoYmVjb21pbmcgb2RkKVxuICAgIC8vIGluIGEgc2Vjb25kIHZlcnRpY2FsIG1vdmUsICMgaW52ZXJzaW9ucyBiZWNvbWVzIGV2ZW4gYW5kIGRpc3RhbmNlIGNoYW5nZXMgYnkgMSAoYmVjb21pbmcgZXZlbilcbiAgICAvL1xuICAgIC8vIHRoZXJlZm9yZSwgaW4gc29sdmFibGUgc3RhdGU6XG4gICAgLy8gICAgICAjIGludmVyc2lvbnMgPSBldmVuIGFuZCBkaXN0YW5jZSBvZiBlbXB0eVBvcyBmcm9tIGdvYWwgcG9zaXRpb24gaXMgZXZlblxuICAgIC8vICAgICAgICAgIE9SXG4gICAgLy8gICAgICAjIGludmVyc2lvbnMgPSBvZGQgYW5kIGRpc3RhbmNlIG9mIGVtcHR5UG9zIGZyb20gZ29hbCBwb3NpdGlvbiBpcyBvZGRcbiAgICAvL1xuICAgIC8vIGlmIHNsaWRpbmcgcHV6emxlIGlzIDEgZGltZW5zaW9uYWwgKHNpbmdsZSByb3cgb3IgY29sdW1uKSwgb25seSBob3Jpem9udGFsIHNsaWRpbmcgaXMgcG9zc2libGVcbiAgICAvLyB0aGVyZWZvcmUsICMgaW52ZXJzaW9ucyBjYW5ub3QgYmUgY2hhbmdlZCwgc28gcHV6emxlIG9ubHkgc29sdmFibGUgaWYgIyBpbnZlcnNpb25zID0gMC5cbiAgICAvLyBhbHRlcm5hdGl2ZWx5LCBqdXN0IGNoZWNrIGlmIGFycmF5IGlzIHNvcnRlZCAoZXhjbHVkaW5nIGVtcHR5UG9zKSB0byBzZWUgaWYgc29sdmFibGVcbiAgICAvL1xuICAgIC8vIE5PVEU6ICMgaW52ZXJzaW9ucyBjYW4gPSAwIHdpdGhvdXQgYmVpbmcgYXQgZ29hbCBzdGF0ZSBiZWNhdXNlIGl0IGRvZXNuJ3QgY291bnQgZW1wdHlQb3NcbiAgICBzdGF0aWMgaXNTb2x2YWJsZShzdGFydEdyaWQsIGdvYWxHcmlkKSB7XG4gICAgICAgIGlmIChzdGFydEdyaWQuZW1wdHlQb3MgPT09IG51bGwgfHwgIWdvYWxHcmlkLmlzRnVsbCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYXJyID0gR3JpZC5nZXRBcnJheVJlcHJlc2VudGF0aW9uKHN0YXJ0R3JpZCwgZ29hbEdyaWQpO1xuICAgICAgICBsZXQgZW1wdHlQb3MgPSBzdGFydEdyaWQuZW1wdHlQb3M7XG5cbiAgICAgICAgcmV0dXJuIEdyaWQuX2lzU29sdmFibGUoYXJyLCBlbXB0eVBvcywgc3RhcnRHcmlkLm51bVJvd3MsIHN0YXJ0R3JpZC5udW1Db2xzKTtcbiAgICB9XG5cbiAgICAvLyBhcnIgPSBhcnJheSByZXByZXNlbnRhdGlvbiBmcm9tIGdldEFycmF5UmVwcmVzZW50YXRpb24oKVxuICAgIC8vIGVtcHR5UG9zID0gaW5kZXggb2YgZW1wdHkgdGlsZVxuICAgIC8vIG51bVJvd3MgPSBudW1iZXIgb2Ygcm93cyBvZiBwdXp6bGVcbiAgICAvLyBudW1Db2xzID0gbnVtYmVyIG9mIGNvbHVtbnMgb2YgcHV6emxlXG4gICAgc3RhdGljIF9pc1NvbHZhYmxlKGFyciwgZW1wdHlQb3MsIG51bVJvd3MsIG51bUNvbHMpIHtcbiAgICAgICAgLy8gaWYgYXJyYXkgaXMgMS1ELCBzbGlkaW5nIGNhbm5vdCBjaGFuZ2UgIyBpbnZlcnNpb25zLCBzbyBhcnJheSBtdXN0IGJlIHNvcnRlZCAoZXhjbHVkaW5nIGVtcHR5UG9zKVxuICAgICAgICBpZiAobnVtQ29scyA9PT0gMSB8fCBudW1Sb3dzID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpICE9PSBlbXB0eVBvcyAmJiAoaSAtIDEpICE9PSBlbXB0eVBvcyAmJiBhcnJbaV0gPCBhcnJbaSAtIDFdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBudW1JbnZlcnNpb25zID0gVXRpbC5jb3VudEludmVyc2lvbnMoYXJyLmZpbHRlcigoZCwgaSkgPT4gaSAhPSBlbXB0eVBvcykpO1xuXG4gICAgICAgIGlmIChudW1Db2xzICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bUludmVyc2lvbnMgJSAyID09PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoZW1wdHlQb3MgLyBudW1Db2xzKTtcbiAgICAgICAgbGV0IGdvYWxSb3cgPSBNYXRoLmZsb29yKGFycltlbXB0eVBvc10gLyBudW1Db2xzKTtcblxuICAgICAgICByZXR1cm4gKG51bUludmVyc2lvbnMgJSAyID09PSAwKSA9PT0gKE1hdGguYWJzKHJvdyAtIGdvYWxSb3cpICUgMiA9PT0gMCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgY3VzdG9tIGZ1bmN0aW9uIGluc3RlYWQgb2YgY2xvbmVUaWxlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICBjbG9uZVRpbGVzVG8oZ29hbEdyaWQpIHtcbiAgICAgICAgdGhpcy50aWxlQ29udGFpbmVyc1xuICAgICAgICAgICAgLmVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0VtcHR5VGlsZShkLnRpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBnb2FsVGlsZSA9IGdvYWxHcmlkLnRpbGVDb250YWluZXJzLmZpbHRlcihnb2FsRGF0YSA9PiBnb2FsRGF0YS5jZWxsLmluZCA9PT0gZC5jZWxsLmluZCk7XG4gICAgICAgICAgICAgICAgICAgIEdyaWQuY2xvbmVUaWxlKGQudGlsZSwgZ29hbFRpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU3RhcnRHcmlkIGV4dGVuZHMgR3JpZCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB4LCB5LCBudW1Sb3dzLCBudW1Db2xzLCBpbWFnZVNyYywge2hlaWdodCA9IDUwMCwgd2lkdGggPSA1MDB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCB4LCB5LCBudW1Sb3dzLCBudW1Db2xzLCB7XG4gICAgICAgICAgICBoZWlnaHQsIHdpZHRoLCBpbWFnZVNyYywgaGFzVGlsZVVuZGVybGF5OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgcmVzZXRUaWxlcygpIHtcblxuICAgICAgICB0aGlzLnRpbGVDb250YWluZXJzXG4gICAgICAgICAgICAuYXR0cigneCcsIGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkLmNlbGwuaW5kID09PSB0aGlzLmVtcHR5UG9zKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLl9jb252ZXJ0SW5wdXRGb3JtYXQoW2QuY2VsbC5pbmRdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93VGlsZSh0aWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZC5jZWxsID0gT2JqZWN0LmFzc2lnbih7fSwgZC5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuc3RhcnQueDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cigneScsIGQgPT4gZC5zdGFydC55KTtcbiAgICAgICAgdGhpcy5fZW1wdHlUaWxlcyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICAvLyBhcmdzID0gdGlsZUNvbnRhaW5lciBET00gRWxlbWVudC9kMyBzZWxlY3Rpb24gT1IgaW5kZXhcbiAgICBkZWxldGVUaWxlKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHRpbGUgPSB0aGlzLl9jb252ZXJ0SW5wdXRGb3JtYXQoYXJncyk7XG4gICAgICAgIGlmICh0aGlzLmVtcHR5UG9zICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dUaWxlKHRoaXMuZW1wdHlQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1wdHlQb3MgPSB0aWxlO1xuICAgICAgICB0aGlzLmhpZGVUaWxlKHRpbGUpO1xuICAgIH1cblxufVxuXG5jbGFzcyBHb2FsR3JpZCBleHRlbmRzIEdyaWQge1xuXG4gICAgY29uc3RydWN0b3IocGFyZW50LCB4LCB5LCBudW1Sb3dzLCBudW1Db2xzLCB7aGVpZ2h0ID0gNTAwLCB3aWR0aCA9IDUwMH0gPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIHgsIHksIG51bVJvd3MsIG51bUNvbHMsIHtcbiAgICAgICAgICAgIGhlaWdodCwgd2lkdGgsIGhhc1RpbGVVbmRlcmxheTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXNldFRpbGVzKCkge1xuICAgICAgICB0aGlzLnRpbGVDb250YWluZXJzXG4gICAgICAgICAgICAuYXR0cigneCcsIGQgPT4gZC5zdGFydC54KVxuICAgICAgICAgICAgLmF0dHIoJ3knLCBkID0+IGQuc3RhcnQueSlcbiAgICAgICAgICAgIC5lYWNoKGQgPT4gdGhpcy5oaWRlVGlsZShkLnRpbGUpKVxuICAgICAgICAgICAgLmVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5jZWxsID0gT2JqZWN0LmFzc2lnbih7fSwgZC5zdGFydCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGQuaW1nO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50aWxlQ29udGFpbmVycy5zZWxlY3QoJ2ltYWdlJykucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuX2VtcHR5VGlsZXMgPSBuZXcgU2V0KHRoaXMudGlsZUNvbnRhaW5lcnMubm9kZXMoKSk7XG4gICAgfVxuXG4gICAgLy8gYXJncyA9IHRpbGVDb250YWluZXIgRE9NIEVsZW1lbnQvZDMgc2VsZWN0aW9uIE9SIGluZGV4XG4gICAgZGVsZXRlVGlsZSguLi5hcmdzKSB7XG4gICAgICAgIGxldCB0aWxlID0gdGhpcy5fY29udmVydElucHV0Rm9ybWF0KGFyZ3MpO1xuICAgICAgICB0aGlzLl9lbXB0eVRpbGVzLmFkZCh0aWxlLm5vZGUoKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRldGlsZUNvbnRhaW5lcih0aWxlKTtcbiAgICB9XG5cbiAgICAvLyBkZWxldGVzIHRpbGUgd2l0aCBzcGVjaWZpZWQgc3RhcnRpbmcgdGlsZUNvbnRhaW5lciAoZDMgc2VsZWN0aW9uKVxuICAgIGRlbGV0ZVRpbGVXaXRoU3RhcnRpbmdUaWxlKHRpbGVDb250YWluZXJTdGFydCkge1xuICAgICAgICB0aWxlQ29udGFpbmVyU3RhcnQgPSB0aWxlQ29udGFpbmVyU3RhcnQgaW5zdGFuY2VvZiBkMy5zZWxlY3Rpb24gPyBcbiAgICAgICAgICAgIHRpbGVDb250YWluZXJTdGFydCA6IGQzLnNlbGVjdCh0aWxlQ29udGFpbmVyU3RhcnQpO1xuICAgICAgICBsZXQgdGlsZSA9IHRoaXMudGlsZUNvbnRhaW5lcnMuZmlsdGVyKGQgPT4gXG4gICAgICAgICAgICBkLmhhc093blByb3BlcnR5KCdzdGFydFRpbGUnKSAmJiBkLnN0YXJ0VGlsZS5ub2RlKCkgPT09IHRpbGVDb250YWluZXJTdGFydC5ub2RlKClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRldGlsZUNvbnRhaW5lcih0aWxlKTtcbiAgICB9XG5cbiAgICBkZWxldGV0aWxlQ29udGFpbmVyKHRpbGVDb250YWluZXIpIHtcbiAgICAgICAgaWYgKHRpbGVDb250YWluZXIgPT09IG51bGwgfHwgdGlsZUNvbnRhaW5lci5lbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSB0aWxlQ29udGFpbmVyLmRhdHVtKCk7XG5cbiAgICAgICAgZGVsZXRlIGRhdGEuaW1nO1xuICAgICAgICB0aWxlQ29udGFpbmVyLnNlbGVjdCgnaW1hZ2UnKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5oaWRlVGlsZSh0aWxlQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fZW1wdHlUaWxlcy5hZGQodGlsZUNvbnRhaW5lci5ub2RlKCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHtHcmlkLCBTdGFydEdyaWQsIEdvYWxHcmlkfVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/puzzle-graphic.js\n");

/***/ }),

/***/ "./src/puzzle-solver.worker.js":
/*!*************************************!*\
  !*** ./src/puzzle-solver.worker.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function() {\n  return new Worker(__webpack_require__.p + \"puzzle-solver.worker.js\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHV6emxlLXNvbHZlci53b3JrZXIuanM/MjYyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG9CQUFvQixxQkFBdUI7QUFDM0MiLCJmaWxlIjoiLi9zcmMvcHV6emxlLXNvbHZlci53b3JrZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFdvcmtlcihfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwicHV6emxlLXNvbHZlci53b3JrZXIuanNcIik7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/puzzle-solver.worker.js\n");

/***/ }),

/***/ "./src/script.js":
/*!***********************!*\
  !*** ./src/script.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_cropperjs_dist_cropper_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/cropperjs/dist/cropper.min.js */ \"./node_modules/cropperjs/dist/cropper.min.js\");\n/* harmony import */ var _node_modules_cropperjs_dist_cropper_min_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_cropperjs_dist_cropper_min_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _puzzle_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./puzzle-graphic.js */ \"./src/puzzle-graphic.js\");\n/* harmony import */ var _node_modules_cropperjs_dist_cropper_min_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/cropperjs/dist/cropper.min.css */ \"./node_modules/cropperjs/dist/cropper.min.css\");\n/* harmony import */ var _node_modules_cropperjs_dist_cropper_min_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_cropperjs_dist_cropper_min_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _puzzle_solver_worker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./puzzle-solver.worker */ \"./src/puzzle-solver.worker.js\");\n/* harmony import */ var _puzzle_solver_worker__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_puzzle_solver_worker__WEBPACK_IMPORTED_MODULE_3__);\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// TODO: consider adding compression plugin to webpack\n// TODO: consider changing to vertical orientation if screen too narrow or input images are landscape orientation\n// TODO: decrease resolution of pictures to make cropping and moving tiles faster\n// TODO: consider cropping images and getting rid of svg-limit cropping for performance\n// TODO: implement IDA* to solve 4x4 puzzles\n// TODO: implement non-optimal solver for puzzles 4x4 and larger\n// TODO: consider moving all node_modules into dev dependencies since they are bundled\n// TODO: consider implementing \"play\" button disabling drag/select and only allowing arrow key movement and change drag/click to animate moves to neighboring tiles\n// just importing from cropperjs uses un-minified version\n\n\n\n // TODO: uglify+minify re-enable after finish\n// TODO: reorganize: validation functions separate js file\n// TODO: consider moving each page to separate js file, with page manager switching between them\n\n(function () {\n  var Util =\n  /*#__PURE__*/\n  function () {\n    function Util() {\n      _classCallCheck(this, Util);\n    }\n\n    _createClass(Util, null, [{\n      key: \"hide\",\n      value: function hide(e) {\n        e = e instanceof d3.selection ? e : d3.select(e);\n        e.style('display', 'none');\n      }\n    }, {\n      key: \"show\",\n      value: function show(e) {\n        e = e instanceof d3.selection ? e : d3.select(e);\n        e.style('display', '');\n      }\n    }, {\n      key: \"toggle\",\n      value: function toggle(e) {\n        e = e instanceof d3.selection ? e : d3.select(e);\n        e.style('display', e.style('display') === 'none' ? '' : 'none');\n      }\n    }]);\n\n    return Util;\n  }();\n\n  ;\n  var container = d3.select('.container-fluid');\n  var messages = container.select('#messages'),\n      instructionDiv = messages.select('#instructions'),\n      warningDiv = messages.select('#warning'),\n      warningMessage = messages.select('#warning-message'),\n      errorDiv = messages.select('#error'),\n      errorMessage = messages.select('#error-message');\n  var imageUploadPage = d3.select('#image-upload-page'),\n      imageContainer = d3.select('#image-upload-container'),\n      imageRow = d3.select('#image-row'),\n      instructions = d3.select('#instructions');\n  var puzzlePage = d3.select('#puzzle-page'),\n      puzzleContainer = d3.select('#puzzle-container'); //--------------------------------------------------------------------------------------------------------\n  // IMAGE UPLOAD PAGE\n  //--------------------------------------------------------------------------------------------------------\n\n  var imageForm = d3.select('#image-form');\n  var imgUrlInput = d3.select('#image-url'),\n      imgFileInput = d3.select('#upload-img-input'),\n      imgFeedback = d3.select('#image-url ~ .invalid-feedback');\n  var img = d3.select('#uploaded-image');\n  var cropper = new _node_modules_cropperjs_dist_cropper_min_js__WEBPACK_IMPORTED_MODULE_0___default.a(img.node(), {\n    viewMode: 2,\n    guides: false,\n    center: false,\n    autoCropArea: 1,\n    dragMode: 'move'\n  });\n  var puzzleConfigForm = d3.select('#puzzle-config-form');\n  var rowSubmit = true,\n      colSubmit = true;\n  var rowInput = d3.select('#num-rows'),\n      rowFeedback = d3.select('#num-rows ~ .invalid-feedback');\n  var colInput = d3.select('#num-cols'),\n      colFeedback = d3.select('#num-cols ~ .invalid-feedback');\n  var cropButton = d3.select('#crop-image-button');\n  rowInput.on('input', validateRows);\n  colInput.on('input', validateColumns);\n  imageForm.on('submit', function () {\n    d3.event.stopPropagation();\n    d3.event.preventDefault();\n  });\n\n  function validateRows() {\n    // would be better if execution short-circuited but OK given low complexity of validation\n    // possible implementation: function as class instead, with params in constructor\n    // and execute() function to actually validate, called in processResponses()\n    rowSubmit = processResponses([numberValidation(rowInput, rowFeedback), twoInputValidation()], rowInput, rowFeedback);\n    cropButton.property('disabled', !rowSubmit || !colSubmit);\n  }\n\n  function validateColumns() {\n    colSubmit = processResponses([numberValidation(colInput, colFeedback)], colInput, colFeedback); // called separately as change in status of twoInputValidation means numberValidation\n    // needs to be checked to see what is displayed on row feedback\n\n    validateRows();\n  } // shows feedback for input based on responses [{status: 'valid'/'invalid'/'warning', message: '...'}, ...]\n  // returns whether input validation allows submission\n\n\n  function processResponses(responses, input, feedback) {\n    var warning;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = responses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _step$value = _step.value,\n            status = _step$value.status,\n            message = _step$value.message;\n\n        if (status === 'invalid') {\n          showError(input, feedback, message);\n          return false;\n        } else if (status === 'warning') {\n          // store instead of showing immediately to allow detection of errors in next responses\n          warning = message;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (warning) {\n      showWarning(input, feedback, warning);\n      return true;\n    }\n\n    hideMessages(input, feedback);\n    return true;\n  }\n\n  function showError(input, feedback, message) {\n    input.classed('has-warning', false);\n    input.classed('is-invalid', true);\n    feedback.classed('warning-feedback', false);\n    feedback.classed('invalid-feedback', true);\n    feedback.text(message);\n  }\n\n  function showWarning(input, feedback, message) {\n    input.classed('has-warning', true);\n    input.classed('is-invalid', false);\n    feedback.classed('warning-feedback', true);\n    feedback.classed('invalid-feedback', false);\n    feedback.text(message);\n  }\n\n  function hideMessages(input, feedback) {\n    input.classed('is-invalid', false);\n    input.classed('has-warning', false);\n    feedback.classed('invalid-feedback', false);\n    feedback.classed('warning-feedback', false);\n    feedback.text('');\n  }\n\n  function twoInputValidation() {\n    var numRows = +rowInput.property('value');\n    var numCols = +colInput.property('value');\n\n    if (numRows === numCols && numRows === 1) {\n      return {\n        status: 'invalid',\n        message: 'Cannot create 1x1 puzzles'\n      };\n    }\n\n    var numTiles = numCols * numRows;\n\n    if (numTiles > 400) {\n      return {\n        status: 'invalid',\n        message: 'Cannot create puzzle with more than 400 tiles (may crash your browser)'\n      };\n    }\n\n    if (numTiles > 12) {\n      return {\n        status: 'warning',\n        message: 'Caution: this site may not be able to optimally solve puzzles with more than 12 tiles'\n      };\n    }\n\n    if (numRows > 1 && numCols > 5 || numCols > 1 && numRows > 5) {\n      return {\n        status: 'warning',\n        message: 'Caution: this site may not be able to optimally solve 2D puzzles with a dimension\\\n                > 5'\n      };\n    }\n\n    return {\n      status: 'valid'\n    };\n  }\n\n  function numberValidation(input, feedback) {\n    var val = +input.property('value');\n\n    if (!Number.isInteger(val) || val < 1) {\n      return {\n        status: 'invalid',\n        message: 'Number must be positive integer'\n      };\n    }\n\n    return {\n      status: 'valid'\n    };\n  }\n\n  imgUrlInput.on('input', function () {\n    var _this = this;\n\n    var url = this.value;\n\n    if (url === '') {\n      hideMessages(imgUrlInput, imgFeedback);\n      return;\n    }\n\n    var img = new Image();\n\n    img.onerror = function () {\n      showError(imgUrlInput, imgFeedback, 'Image could not be loaded');\n    };\n\n    img.onload = function () {\n      cropper.replace(_this.value);\n      hideMessages(imgUrlInput, imgFeedback);\n    };\n\n    img.src = url;\n  });\n  imgFileInput.on('change', function () {\n    imgUrlInput.property('value', '');\n    var imgUpload = imgFileInput.property('files')[0];\n\n    if (imgUpload.type.includes('image')) {\n      var reader = new FileReader();\n\n      reader.onload = function (e) {\n        cropper.replace(e.target.result);\n      };\n\n      reader.readAsDataURL(imgUpload);\n      hideMessages(imgUrlInput, imgFeedback);\n    } else {\n      showError(imgUrlInput, imgFeedback, 'Uploaded file must be an image');\n    }\n  });\n  puzzleConfigForm.on('submit', function () {\n    d3.event.preventDefault();\n    d3.event.stopPropagation();\n\n    if (rowSubmit && colSubmit) {\n      imageContainer.remove();\n      var numRows = +rowInput.property('value');\n      var numCols = +colInput.property('value');\n      Util.hide(imageUploadPage);\n      Util.show(puzzlePage);\n\n      var _cropper$getCropBoxDa = cropper.getCropBoxData(),\n          width = _cropper$getCropBoxDa.width,\n          height = _cropper$getCropBoxDa.height;\n\n      splitImage(cropper.getCroppedCanvas().toDataURL(), width, height, numRows, numCols);\n    }\n  }); //--------------------------------------------------------------------------------------------------------\n  // PUZZLE PAGE\n  //--------------------------------------------------------------------------------------------------------\n\n  function splitImage(src, width, height, numRows, numCols) {\n    // TODO: stop relying on iteration limit and use memory/time limit instead\n    // (since larger puzzles make iterations take longer)\n    var strings = {\n      errors: {\n        unsolvable: 'Puzzle is unsolvable. Try swapping tiles in your goal and/or start state;\\\n                        simply sliding tiles around will not affect puzzle solvability.',\n        iterationLimit: 'Puzzle took too long to solve; further solve-time could crash your browser.'\n      },\n      warnings: {\n        solvability: 'Be careful when swapping and deleting tiles; not all puzzle-states are solvable.'\n      }\n    };\n    Util.show(warningDiv);\n    warningMessage.text(strings.warnings.solvability);\n    var maxGridHeight = 110;\n    var maxGridWidth = 110;\n    var gridWidth, gridHeight; // preserves aspect ratio of cropped image, with largest dim set to max dim above\n\n    if (width > height) {\n      gridWidth = maxGridWidth;\n      gridHeight = maxGridHeight * height / width;\n    } else {\n      gridHeight = maxGridHeight;\n      gridWidth = maxGridWidth * width / height;\n    }\n\n    var viewBox = {\n      x: 0,\n      y: 0,\n      width: 300,\n      height: gridHeight + 30\n    }; // NOTE: height not set in svg as overwritten by viewBox height scaling to width\n\n    var svg = puzzleContainer.append('svg').attr('width', '100%').attr('viewBox', \"\".concat(viewBox.x, \" \").concat(viewBox.y, \" \").concat(viewBox.width, \" \").concat(viewBox.height));\n    svg.append('defs').append('filter').attr('id', 'shadow').append('feDropShadow').attr('dx', 0).attr('dy', 0).attr('stdDeviation', 3);\n    var gridPadding = (300 - gridWidth * 2) / 3; // NOTE: 0.5 positioning helps make outlines crisper (as coords map to pixel square intersections)\n    // - also helps prevent noticeable outline darkening in outline coord overlap for same reason\n    // - difference can be seen more easily when strokeWidth increased\n\n    var startGrid = new _puzzle_graphic_js__WEBPACK_IMPORTED_MODULE_1__[\"StartGrid\"](svg, gridPadding, 20.5, numRows, numCols, src, {\n      height: gridHeight,\n      width: gridWidth\n    }).draw();\n    var goalGrid = new _puzzle_graphic_js__WEBPACK_IMPORTED_MODULE_1__[\"GoalGrid\"](svg, viewBox.width - gridPadding - gridWidth, 20.5, numRows, numCols, {\n      height: gridHeight,\n      width: gridWidth\n    }).draw();\n    var tileNumberSize = Math.min(gridHeight / numRows / 2, gridWidth / numCols / 2);\n    startGrid.tileNumbers.style('font-size', \"\".concat(tileNumberSize, \"px\"));\n    goalGrid.tileNumbers.style('font-size', \"\".concat(tileNumberSize, \"px\")); // NOTE: not inside Grid as not sure if want to display label\n    // Adding label would make tile coords a little more confusing\n\n    var startLabel = startGrid.container.append('text').attr('x', startGrid.x + startGrid.width / 2).attr('y', startGrid.y - 5).text('Start').classed('grid-title', true);\n    var goalLabel = goalGrid.container.append('text').attr('x', goalGrid.x + goalGrid.width / 2).attr('y', goalGrid.y - 5).text('Goal').classed('grid-title', true);\n    var buttonRight = svg.append('image').attr('x', startGrid.x + gridWidth + gridPadding / 2 - 8).attr('y', '50%').attr('width', 16).attr('height', 16).attr('href', 'icons/right-chevron.svg').classed('puzzle-arrow', true).on('click', function () {\n      startGrid.cloneTilesTo(goalGrid);\n      Util.hide(errorDiv);\n      checkSolvability();\n    });\n    var buttonToolbar = puzzlePage.append('div').attr('class', 'btn-toolbar mb-2 justify-content-center');\n    var puzzleButtons = buttonToolbar.append('div').attr('class', 'btn-group mr-2 my-1');\n    var overlayButtons = buttonToolbar.append('div').attr('class', 'btn-group my-1');\n    var solutionPanel = puzzlePage.append('div').attr('class', 'card').style('display', 'none');\n    var solutionPanelHeading = solutionPanel.append('div').attr('class', 'card-header').text('Solution');\n    var solutionPanelBody = solutionPanel.append('div').attr('class', 'card-body').style('max-height', '100px').style('overflow-y', 'scroll'); // NOTE: assumes starting state is solvable\n\n    var shuffleButton = puzzleButtons.append('button').attr('class', 'btn btn-secondary').attr('id', 'shuffle-button').property('disabled', true).text('Shuffle') // don't want to pass in \"this\" from click\n    .on('click', function () {\n      startGrid.shuffle();\n      Util.hide(errorDiv);\n    }); // TODO: consider having animations return promise that resolves after everything animated\n    // that way, can disable and enable solve/shuffle after promise resolves\n    // also add loading indication (at minimum, show loading cursor)\n\n    var solveButton = puzzleButtons.append('button').property('disabled', true).attr('class', 'btn btn-secondary').attr('id', 'solve-button').text('Solve').on('click', function () {\n      // let puzzle = new Puzzle(numRows, numCols, Grid.getArrayRepresentation(startGrid, goalGrid),\n      //     startGrid.emptyPos);\n      // allows solving of puzzle in separate thread to prevent blocking of UI\n      var worker = new _puzzle_solver_worker__WEBPACK_IMPORTED_MODULE_3___default.a();\n\n      worker.onmessage = function (e) {\n        var ans = e.data;\n\n        if (Array.isArray(ans)) {\n          Util.show(solutionPanel);\n          startGrid.animateMoves(ans, solutionPanelBody);\n        } else {\n          // solver could not find solution\n          Util.show(errorDiv);\n          errorDiv.node().scrollIntoView();\n\n          if (ans === -1) {\n            // TODO: modify when IDA* time/iteration limit implemented\n            errorMessage.text(strings.errors.iterationLimit);\n          } else {\n            errorMessage.text(strings.errors.unsolvable);\n          }\n        }\n      };\n\n      worker.postMessage([numRows, numCols, _puzzle_graphic_js__WEBPACK_IMPORTED_MODULE_1__[\"Grid\"].getArrayRepresentation(startGrid, goalGrid), startGrid.emptyPos]);\n    });\n    var resetPuzzleButton = puzzleButtons.append('button').attr('class', 'btn btn-secondary').attr('id', 'reset-puzzle-button').text('Reset').on('click', function () {\n      startGrid.resetTiles();\n      goalGrid.resetTiles();\n      Util.hide(solutionPanel);\n      solveButton.property('disabled', true); // switches mode to tile deletion mode\n\n      if (toggleMouseModeButton.text() === 'Tile Deletion Mode') {\n        toggleMouseModeButton.node().click();\n      }\n\n      toggleMouseModeButton.property('disabled', true);\n      shuffleButton.property('disabled', true);\n      Util.hide(errorDiv);\n    });\n    var numberOverlayButton = overlayButtons.append('button').attr('class', 'btn btn-secondary').attr('id', 'number-overlay-button').text('Show Number Overlay').on('click', function () {\n      startGrid.toggleNumberOverlay();\n      goalGrid.toggleNumberOverlay();\n      var text = numberOverlayButton.text() === 'Show Number Overlay' ? 'Hide Number Overlay' : 'Show Number Overlay';\n      numberOverlayButton.text(text);\n    });\n    var toggleMouseModeButton = overlayButtons.append('button') // cannot start moving tiles until one is deleted (empty position chosen)\n    .property('disabled', true).attr('class', 'btn btn-secondary').attr('id', 'toggle-mouse-mode-button').text('Tile Selection Mode').on('click', function () {\n      startGrid.toggleTileOverlay();\n      goalGrid.toggleTileOverlay();\n      var button = d3.select(this);\n      var text = button.text() === 'Tile Deletion Mode' ? 'Tile Selection Mode' : 'Tile Deletion Mode';\n      button.text(text);\n      startGrid.deselectAll();\n      goalGrid.deselectAll();\n    }); // TODO: consider looking into drop handler instead of getting tile from (x, y) in Grid\n\n    var dragHandler = d3.drag().subject(function (d) {\n      return {\n        x: d.cell.x,\n        y: d.cell.y\n      };\n    }) // don't drag tile if in delete mode or tile is empty\n    .filter(function (d) {\n      return !d.grid.deleteOverlay && !d.grid.hasEmptyTile(d.tile);\n    }).on('drag', function (d) {\n      // console.log('dragging');\n      d3.select(this).classed('dragging', true); // NOTE: raise() executes in 'drag' rather than 'start' as appendChild (called by raise())\n      // prevents call of click handler (undesirable, since 'start' is called on clicks)\n      // NOTE: not as inefficient as it may seem, as function only moves container\n      // if it is not last element in parent\n      // moves container of tile to front so that dragged tile drawn above other puzzle\n\n      d.grid.container.raise(); // moves tile to front so drawn in front of other tiles\n\n      d.tile.raise();\n      d.grid.container.node().focus();\n      d3.select(this).attr('x', d3.event.x).attr('y', d3.event.y);\n    }) // NOTE: d3 still calls start and end on click (fires before click handler)\n    .on('end', function (d) {\n      // console.log('drag end');\n      d3.select(this).classed('dragging', false); // return original image to starting position on release\n\n      var tileContainer = d3.select(this).attr('x', d.cell.x).attr('y', d.cell.y);\n\n      var _d3$mouse = d3.mouse(svg.node()),\n          _d3$mouse2 = _slicedToArray(_d3$mouse, 2),\n          mouseX = _d3$mouse2[0],\n          mouseY = _d3$mouse2[1];\n\n      if (!goalGrid.dropTile(tileContainer, mouseX, mouseY)) {\n        startGrid.dropTile(tileContainer, mouseX, mouseY);\n        checkSolvability();\n      }\n\n      checkSolvability();\n    });\n    startGrid.tileContainers.call(dragHandler);\n    goalGrid.tileContainers.call(dragHandler);\n    startGrid.tileContainers.on('click', function (d) {\n      var result = startGrid.clickTile(this);\n\n      if (result.method === 'delete') {\n        goalGrid.deleteTileWithStartingTile(result.tile);\n        toggleMouseModeButton.property('disabled', false);\n        shuffleButton.property('disabled', false);\n      } else if (result.method === 'select' && goalGrid.selectedTiles.size === 1) {\n        var goalTile = goalGrid.selectedTiles.values().next().value; // empty tiles cannot be cloned to goal Tile\n\n        if (!startGrid.hasEmptyTile(result.tile)) {\n          _puzzle_graphic_js__WEBPACK_IMPORTED_MODULE_1__[\"Grid\"].cloneTile(result.tile, goalTile);\n          goalGrid.deselectTile(goalTile);\n          startGrid.deselectTile(result.tile);\n        }\n      }\n\n      checkSolvability();\n    });\n    goalGrid.tileContainers.on('click', function (d) {\n      var result = goalGrid.clickTile(this);\n\n      if (result.method === 'select' && startGrid.selectedTiles.size === 1) {\n        var startTile = startGrid.selectedTiles.values().next().value; // empty tiles cannot be cloned to goal Tile\n\n        if (!startGrid.hasEmptyTile(startTile)) {\n          _puzzle_graphic_js__WEBPACK_IMPORTED_MODULE_1__[\"Grid\"].cloneTile(startTile, result.tile);\n          goalGrid.deselectTile(result.tile);\n          startGrid.deselectTile(startTile);\n        }\n      }\n\n      checkSolvability();\n    }); // TODO: consider allowing movement of selected tile (mainly for moving tiles in partially assigned goal)\n    // TODO: consider deselecting tile if it's dragged or dropped onto\n    // TODO: consider overwriting tile rather than swapping them when a tile with match is dragged to an occupied tile\n\n    var arrowMovementHandler = function arrowMovementHandler(selectedGrid) {\n      var key = d3.event.key;\n      var KEY_MAPPING = {\n        'ArrowLeft': 'l',\n        'ArrowRight': 'r',\n        'ArrowUp': 'u',\n        'ArrowDown': 'd',\n        'w': 'u',\n        'a': 'l',\n        's': 'd',\n        'd': 'r'\n      };\n      var move = KEY_MAPPING[key];\n\n      if (move) {\n        // prevents arrow keys from scrolling screen\n        d3.event.preventDefault();\n        selectedGrid.animateMove(move);\n      }\n    };\n\n    startGrid.container.on('keydown', arrowMovementHandler);\n    goalGrid.container.on('keydown', arrowMovementHandler);\n\n    function checkSolvability() {\n      if (startGrid.emptyPos !== null && goalGrid.isFull()) {\n        if (_puzzle_graphic_js__WEBPACK_IMPORTED_MODULE_1__[\"Grid\"].isSolvable(startGrid, goalGrid)) {\n          Util.hide(errorDiv);\n          solveButton.property('disabled', false);\n          return true;\n        }\n\n        errorMessage.text(strings.errors.unsolvable);\n        Util.show(errorDiv);\n        errorDiv.node().scrollIntoView();\n      }\n\n      solveButton.property('disabled', true);\n      return false;\n    } //--------------------------------------------------------------------------------------------------------\n\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0LmpzPzY4YjAiXSwibmFtZXMiOlsiVXRpbCIsImUiLCJkMyIsInNlbGVjdGlvbiIsInNlbGVjdCIsInN0eWxlIiwiY29udGFpbmVyIiwibWVzc2FnZXMiLCJpbnN0cnVjdGlvbkRpdiIsIndhcm5pbmdEaXYiLCJ3YXJuaW5nTWVzc2FnZSIsImVycm9yRGl2IiwiZXJyb3JNZXNzYWdlIiwiaW1hZ2VVcGxvYWRQYWdlIiwiaW1hZ2VDb250YWluZXIiLCJpbWFnZVJvdyIsImluc3RydWN0aW9ucyIsInB1enpsZVBhZ2UiLCJwdXp6bGVDb250YWluZXIiLCJpbWFnZUZvcm0iLCJpbWdVcmxJbnB1dCIsImltZ0ZpbGVJbnB1dCIsImltZ0ZlZWRiYWNrIiwiaW1nIiwiY3JvcHBlciIsIkNyb3BwZXIiLCJub2RlIiwidmlld01vZGUiLCJndWlkZXMiLCJjZW50ZXIiLCJhdXRvQ3JvcEFyZWEiLCJkcmFnTW9kZSIsInB1enpsZUNvbmZpZ0Zvcm0iLCJyb3dTdWJtaXQiLCJjb2xTdWJtaXQiLCJyb3dJbnB1dCIsInJvd0ZlZWRiYWNrIiwiY29sSW5wdXQiLCJjb2xGZWVkYmFjayIsImNyb3BCdXR0b24iLCJvbiIsInZhbGlkYXRlUm93cyIsInZhbGlkYXRlQ29sdW1ucyIsImV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJwcm9jZXNzUmVzcG9uc2VzIiwibnVtYmVyVmFsaWRhdGlvbiIsInR3b0lucHV0VmFsaWRhdGlvbiIsInByb3BlcnR5IiwicmVzcG9uc2VzIiwiaW5wdXQiLCJmZWVkYmFjayIsIndhcm5pbmciLCJzdGF0dXMiLCJtZXNzYWdlIiwic2hvd0Vycm9yIiwic2hvd1dhcm5pbmciLCJoaWRlTWVzc2FnZXMiLCJjbGFzc2VkIiwidGV4dCIsIm51bVJvd3MiLCJudW1Db2xzIiwibnVtVGlsZXMiLCJ2YWwiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ1cmwiLCJ2YWx1ZSIsIkltYWdlIiwib25lcnJvciIsIm9ubG9hZCIsInJlcGxhY2UiLCJzcmMiLCJpbWdVcGxvYWQiLCJ0eXBlIiwiaW5jbHVkZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwidGFyZ2V0IiwicmVzdWx0IiwicmVhZEFzRGF0YVVSTCIsInJlbW92ZSIsImhpZGUiLCJzaG93IiwiZ2V0Q3JvcEJveERhdGEiLCJ3aWR0aCIsImhlaWdodCIsInNwbGl0SW1hZ2UiLCJnZXRDcm9wcGVkQ2FudmFzIiwidG9EYXRhVVJMIiwic3RyaW5ncyIsImVycm9ycyIsInVuc29sdmFibGUiLCJpdGVyYXRpb25MaW1pdCIsIndhcm5pbmdzIiwic29sdmFiaWxpdHkiLCJtYXhHcmlkSGVpZ2h0IiwibWF4R3JpZFdpZHRoIiwiZ3JpZFdpZHRoIiwiZ3JpZEhlaWdodCIsInZpZXdCb3giLCJ4IiwieSIsInN2ZyIsImFwcGVuZCIsImF0dHIiLCJncmlkUGFkZGluZyIsInN0YXJ0R3JpZCIsIlN0YXJ0R3JpZCIsImRyYXciLCJnb2FsR3JpZCIsIkdvYWxHcmlkIiwidGlsZU51bWJlclNpemUiLCJNYXRoIiwibWluIiwidGlsZU51bWJlcnMiLCJzdGFydExhYmVsIiwiZ29hbExhYmVsIiwiYnV0dG9uUmlnaHQiLCJjbG9uZVRpbGVzVG8iLCJjaGVja1NvbHZhYmlsaXR5IiwiYnV0dG9uVG9vbGJhciIsInB1enpsZUJ1dHRvbnMiLCJvdmVybGF5QnV0dG9ucyIsInNvbHV0aW9uUGFuZWwiLCJzb2x1dGlvblBhbmVsSGVhZGluZyIsInNvbHV0aW9uUGFuZWxCb2R5Iiwic2h1ZmZsZUJ1dHRvbiIsInNodWZmbGUiLCJzb2x2ZUJ1dHRvbiIsIndvcmtlciIsIlB1enpsZVNvbHZlcldvcmtlciIsIm9ubWVzc2FnZSIsImFucyIsImRhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJhbmltYXRlTW92ZXMiLCJzY3JvbGxJbnRvVmlldyIsInBvc3RNZXNzYWdlIiwiR3JpZCIsImdldEFycmF5UmVwcmVzZW50YXRpb24iLCJlbXB0eVBvcyIsInJlc2V0UHV6emxlQnV0dG9uIiwicmVzZXRUaWxlcyIsInRvZ2dsZU1vdXNlTW9kZUJ1dHRvbiIsImNsaWNrIiwibnVtYmVyT3ZlcmxheUJ1dHRvbiIsInRvZ2dsZU51bWJlck92ZXJsYXkiLCJ0b2dnbGVUaWxlT3ZlcmxheSIsImJ1dHRvbiIsImRlc2VsZWN0QWxsIiwiZHJhZ0hhbmRsZXIiLCJkcmFnIiwic3ViamVjdCIsImQiLCJjZWxsIiwiZmlsdGVyIiwiZ3JpZCIsImRlbGV0ZU92ZXJsYXkiLCJoYXNFbXB0eVRpbGUiLCJ0aWxlIiwicmFpc2UiLCJmb2N1cyIsInRpbGVDb250YWluZXIiLCJtb3VzZSIsIm1vdXNlWCIsIm1vdXNlWSIsImRyb3BUaWxlIiwidGlsZUNvbnRhaW5lcnMiLCJjYWxsIiwiY2xpY2tUaWxlIiwibWV0aG9kIiwiZGVsZXRlVGlsZVdpdGhTdGFydGluZ1RpbGUiLCJzZWxlY3RlZFRpbGVzIiwic2l6ZSIsImdvYWxUaWxlIiwidmFsdWVzIiwibmV4dCIsImNsb25lVGlsZSIsImRlc2VsZWN0VGlsZSIsInN0YXJ0VGlsZSIsImFycm93TW92ZW1lbnRIYW5kbGVyIiwic2VsZWN0ZWRHcmlkIiwia2V5IiwiS0VZX01BUFBJTkciLCJtb3ZlIiwiYW5pbWF0ZU1vdmUiLCJpc0Z1bGwiLCJpc1NvbHZhYmxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0NBR0E7QUFFQTtBQUVBOztBQUNBLENBQUMsWUFBTTtBQUFBLE1BQ0dBLElBREg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSwyQkFFYUMsQ0FGYixFQUVnQjtBQUNYQSxTQUFDLEdBQUdBLENBQUMsWUFBWUMsRUFBRSxDQUFDQyxTQUFoQixHQUE0QkYsQ0FBNUIsR0FBZ0NDLEVBQUUsQ0FBQ0UsTUFBSCxDQUFVSCxDQUFWLENBQXBDO0FBQ0FBLFNBQUMsQ0FBQ0ksS0FBRixDQUFRLFNBQVIsRUFB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VUFBckIsRUFBaUMsSUFBakM7QUFDQSxhQUFPLEtBQVA7QUFDSCxLQTlXcUQsQ0FnWDFEOztBQUNDO0FBQ0osQ0F2bUJEIiwiZmlsZSI6Ii4vc3JjL3NjcmlwdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE86IGNvbnNpZGVyIGFkZGluZyBjb21wcmVzc2lvbiBwbHVnaW4gdG8gd2VicGFja1xuXG4vLyBUT0RPOiBjb25zaWRlciBjaGFuZ2luZyB0byB2ZXJ0aWNhbCBvcmllbnRhdGlvbiBpZiBzY3JlZW4gdG9vIG5hcnJvdyBvciBpbnB1dCBpbWFnZXMgYXJlIGxhbmRzY2FwZSBvcmllbnRhdGlvblxuXG4vLyBUT0RPOiBkZWNyZWFzZSByZXNvbHV0aW9uIG9mIHBpY3R1cmVzIHRvIG1ha2UgY3JvcHBpbmcgYW5kIG1vdmluZyB0aWxlcyBmYXN0ZXJcbi8vIFRPRE86IGNvbnNpZGVyIGNyb3BwaW5nIGltYWdlcyBhbmQgZ2V0dGluZyByaWQgb2Ygc3ZnLWxpbWl0IGNyb3BwaW5nIGZvciBwZXJmb3JtYW5jZVxuXG4vLyBUT0RPOiBpbXBsZW1lbnQgSURBKiB0byBzb2x2ZSA0eDQgcHV6emxlc1xuLy8gVE9ETzogaW1wbGVtZW50IG5vbi1vcHRpbWFsIHNvbHZlciBmb3IgcHV6emxlcyA0eDQgYW5kIGxhcmdlclxuLy8gVE9ETzogY29uc2lkZXIgbW92aW5nIGFsbCBub2RlX21vZHVsZXMgaW50byBkZXYgZGVwZW5kZW5jaWVzIHNpbmNlIHRoZXkgYXJlIGJ1bmRsZWRcblxuLy8gVE9ETzogY29uc2lkZXIgaW1wbGVtZW50aW5nIFwicGxheVwiIGJ1dHRvbiBkaXNhYmxpbmcgZHJhZy9zZWxlY3QgYW5kIG9ubHkgYWxsb3dpbmcgYXJyb3cga2V5IG1vdmVtZW50IGFuZCBjaGFuZ2UgZHJhZy9jbGljayB0byBhbmltYXRlIG1vdmVzIHRvIG5laWdoYm9yaW5nIHRpbGVzXG5cbi8vIGp1c3QgaW1wb3J0aW5nIGZyb20gY3JvcHBlcmpzIHVzZXMgdW4tbWluaWZpZWQgdmVyc2lvblxuaW1wb3J0IENyb3BwZXIgZnJvbSAnLi4vbm9kZV9tb2R1bGVzL2Nyb3BwZXJqcy9kaXN0L2Nyb3BwZXIubWluLmpzJ1xuaW1wb3J0IHtHcmlkLCBTdGFydEdyaWQsIEdvYWxHcmlkfSBmcm9tICcuL3B1enpsZS1ncmFwaGljLmpzJ1xuaW1wb3J0ICcuLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5taW4uY3NzJ1xuaW1wb3J0IFB1enpsZVNvbHZlcldvcmtlciBmcm9tICcuL3B1enpsZS1zb2x2ZXIud29ya2VyJ1xuXG4vLyBUT0RPOiB1Z2xpZnkrbWluaWZ5IHJlLWVuYWJsZSBhZnRlciBmaW5pc2hcblxuLy8gVE9ETzogcmVvcmdhbml6ZTogdmFsaWRhdGlvbiBmdW5jdGlvbnMgc2VwYXJhdGUganMgZmlsZVxuXG4vLyBUT0RPOiBjb25zaWRlciBtb3ZpbmcgZWFjaCBwYWdlIHRvIHNlcGFyYXRlIGpzIGZpbGUsIHdpdGggcGFnZSBtYW5hZ2VyIHN3aXRjaGluZyBiZXR3ZWVuIHRoZW1cbigoKSA9PiB7XG4gICAgY2xhc3MgVXRpbCB7XG4gICAgICAgIHN0YXRpYyBoaWRlKGUpIHtcbiAgICAgICAgICAgIGUgPSBlIGluc3RhbmNlb2YgZDMuc2VsZWN0aW9uID8gZSA6IGQzLnNlbGVjdChlKTtcbiAgICAgICAgICAgIGUuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGljIHNob3coZSkge1xuICAgICAgICAgICAgZSA9IGUgaW5zdGFuY2VvZiBkMy5zZWxlY3Rpb24gPyBlIDogZDMuc2VsZWN0KGUpO1xuICAgICAgICAgICAgZS5zdHlsZSgnZGlzcGxheScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyB0b2dnbGUoZSkge1xuICAgICAgICAgICAgZSA9IGUgaW5zdGFuY2VvZiBkMy5zZWxlY3Rpb24gPyBlIDogZDMuc2VsZWN0KGUpO1xuICAgICAgICAgICAgZS5zdHlsZSgnZGlzcGxheScsIGUuc3R5bGUoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnID8gJycgOiAnbm9uZScpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGQzLnNlbGVjdCgnLmNvbnRhaW5lci1mbHVpZCcpO1xuXG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb250YWluZXIuc2VsZWN0KCcjbWVzc2FnZXMnKSxcbiAgICAgICAgICBpbnN0cnVjdGlvbkRpdiA9IG1lc3NhZ2VzLnNlbGVjdCgnI2luc3RydWN0aW9ucycpLFxuICAgICAgICAgIHdhcm5pbmdEaXYgPSBtZXNzYWdlcy5zZWxlY3QoJyN3YXJuaW5nJyksXG4gICAgICAgICAgd2FybmluZ01lc3NhZ2UgPSBtZXNzYWdlcy5zZWxlY3QoJyN3YXJuaW5nLW1lc3NhZ2UnKSxcbiAgICAgICAgICBlcnJvckRpdiA9IG1lc3NhZ2VzLnNlbGVjdCgnI2Vycm9yJyksXG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gbWVzc2FnZXMuc2VsZWN0KCcjZXJyb3ItbWVzc2FnZScpO1xuXG4gICAgY29uc3QgaW1hZ2VVcGxvYWRQYWdlID0gZDMuc2VsZWN0KCcjaW1hZ2UtdXBsb2FkLXBhZ2UnKSxcbiAgICAgICAgICBpbWFnZUNvbnRhaW5lciA9IGQzLnNlbGVjdCgnI2ltYWdlLXVwbG9hZC1jb250YWluZXInKSxcbiAgICAgICAgICBpbWFnZVJvdyA9IGQzLnNlbGVjdCgnI2ltYWdlLXJvdycpLFxuICAgICAgICAgIGluc3RydWN0aW9ucyA9IGQzLnNlbGVjdCgnI2luc3RydWN0aW9ucycpO1xuXG4gICAgY29uc3QgcHV6emxlUGFnZSA9IGQzLnNlbGVjdCgnI3B1enpsZS1wYWdlJyksXG4gICAgICAgICAgcHV6emxlQ29udGFpbmVyID0gZDMuc2VsZWN0KCcjcHV6emxlLWNvbnRhaW5lcicpO1xuXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gSU1BR0UgVVBMT0FEIFBBR0VcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb25zdCBpbWFnZUZvcm0gPSBkMy5zZWxlY3QoJyNpbWFnZS1mb3JtJyk7XG4gICAgY29uc3QgaW1nVXJsSW5wdXQgPSBkMy5zZWxlY3QoJyNpbWFnZS11cmwnKSxcbiAgICAgICAgICBpbWdGaWxlSW5wdXQgPSBkMy5zZWxlY3QoJyN1cGxvYWQtaW1nLWlucHV0JyksXG4gICAgICAgICAgaW1nRmVlZGJhY2sgPSBkMy5zZWxlY3QoJyNpbWFnZS11cmwgfiAuaW52YWxpZC1mZWVkYmFjaycpO1xuXG4gICAgY29uc3QgaW1nID0gZDMuc2VsZWN0KCcjdXBsb2FkZWQtaW1hZ2UnKTtcblxuICAgIGNvbnN0IGNyb3BwZXIgPSBuZXcgQ3JvcHBlcihpbWcubm9kZSgpLCB7XG4gICAgICAgIHZpZXdNb2RlOiAyLFxuICAgICAgICBndWlkZXM6IGZhbHNlLFxuICAgICAgICBjZW50ZXI6IGZhbHNlLFxuICAgICAgICBhdXRvQ3JvcEFyZWE6IDEsXG4gICAgICAgIGRyYWdNb2RlOiAnbW92ZSdcbiAgICB9KTtcblxuICAgIGNvbnN0IHB1enpsZUNvbmZpZ0Zvcm0gPSBkMy5zZWxlY3QoJyNwdXp6bGUtY29uZmlnLWZvcm0nKTtcblxuICAgIGxldCByb3dTdWJtaXQgPSB0cnVlLFxuICAgICAgICBjb2xTdWJtaXQgPSB0cnVlO1xuXG4gICAgY29uc3Qgcm93SW5wdXQgPSBkMy5zZWxlY3QoJyNudW0tcm93cycpLFxuICAgICAgICAgIHJvd0ZlZWRiYWNrID0gZDMuc2VsZWN0KCcjbnVtLXJvd3MgfiAuaW52YWxpZC1mZWVkYmFjaycpO1xuXG4gICAgY29uc3QgY29sSW5wdXQgPSBkMy5zZWxlY3QoJyNudW0tY29scycpLFxuICAgICAgICAgIGNvbEZlZWRiYWNrID0gZDMuc2VsZWN0KCcjbnVtLWNvbHMgfiAuaW52YWxpZC1mZWVkYmFjaycpO1xuXG4gICAgY29uc3QgY3JvcEJ1dHRvbiA9IGQzLnNlbGVjdCgnI2Nyb3AtaW1hZ2UtYnV0dG9uJyk7XG5cbiAgICByb3dJbnB1dC5vbignaW5wdXQnLCB2YWxpZGF0ZVJvd3MpO1xuICAgIGNvbElucHV0Lm9uKCdpbnB1dCcsIHZhbGlkYXRlQ29sdW1ucyk7XG5cbiAgICBpbWFnZUZvcm0ub24oJ3N1Ym1pdCcsICgpID0+IHtcbiAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVJvd3MoKSB7XG4gICAgICAgIC8vIHdvdWxkIGJlIGJldHRlciBpZiBleGVjdXRpb24gc2hvcnQtY2lyY3VpdGVkIGJ1dCBPSyBnaXZlbiBsb3cgY29tcGxleGl0eSBvZiB2YWxpZGF0aW9uXG4gICAgICAgIC8vIHBvc3NpYmxlIGltcGxlbWVudGF0aW9uOiBmdW5jdGlvbiBhcyBjbGFzcyBpbnN0ZWFkLCB3aXRoIHBhcmFtcyBpbiBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBhbmQgZXhlY3V0ZSgpIGZ1bmN0aW9uIHRvIGFjdHVhbGx5IHZhbGlkYXRlLCBjYWxsZWQgaW4gcHJvY2Vzc1Jlc3BvbnNlcygpXG4gICAgICAgIHJvd1N1Ym1pdCA9IHByb2Nlc3NSZXNwb25zZXMoW251bWJlclZhbGlkYXRpb24ocm93SW5wdXQsIHJvd0ZlZWRiYWNrKSwgdHdvSW5wdXRWYWxpZGF0aW9uKCldLFxuICAgICAgICAgICAgcm93SW5wdXQsIHJvd0ZlZWRiYWNrKTtcblxuICAgICAgICBjcm9wQnV0dG9uLnByb3BlcnR5KCdkaXNhYmxlZCcsICFyb3dTdWJtaXQgfHwgIWNvbFN1Ym1pdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDb2x1bW5zKCkge1xuICAgICAgICBjb2xTdWJtaXQgPSBwcm9jZXNzUmVzcG9uc2VzKFtudW1iZXJWYWxpZGF0aW9uKGNvbElucHV0LCBjb2xGZWVkYmFjayldLCBjb2xJbnB1dCwgY29sRmVlZGJhY2spO1xuXG4gICAgICAgIC8vIGNhbGxlZCBzZXBhcmF0ZWx5IGFzIGNoYW5nZSBpbiBzdGF0dXMgb2YgdHdvSW5wdXRWYWxpZGF0aW9uIG1lYW5zIG51bWJlclZhbGlkYXRpb25cbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgY2hlY2tlZCB0byBzZWUgd2hhdCBpcyBkaXNwbGF5ZWQgb24gcm93IGZlZWRiYWNrXG4gICAgICAgIHZhbGlkYXRlUm93cygpO1xuICAgIH1cblxuICAgIC8vIHNob3dzIGZlZWRiYWNrIGZvciBpbnB1dCBiYXNlZCBvbiByZXNwb25zZXMgW3tzdGF0dXM6ICd2YWxpZCcvJ2ludmFsaWQnLyd3YXJuaW5nJywgbWVzc2FnZTogJy4uLid9LCAuLi5dXG4gICAgLy8gcmV0dXJucyB3aGV0aGVyIGlucHV0IHZhbGlkYXRpb24gYWxsb3dzIHN1Ym1pc3Npb25cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2VzKHJlc3BvbnNlcywgaW5wdXQsIGZlZWRiYWNrKSB7XG4gICAgICAgIGxldCB3YXJuaW5nO1xuICAgICAgICBmb3IgKGxldCB7c3RhdHVzLCBtZXNzYWdlfSBvZiByZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdpbnZhbGlkJykge1xuICAgICAgICAgICAgICAgIHNob3dFcnJvcihpbnB1dCwgZmVlZGJhY2ssIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnd2FybmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSBpbnN0ZWFkIG9mIHNob3dpbmcgaW1tZWRpYXRlbHkgdG8gYWxsb3cgZGV0ZWN0aW9uIG9mIGVycm9ycyBpbiBuZXh0IHJlc3BvbnNlc1xuICAgICAgICAgICAgICAgIHdhcm5pbmcgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3YXJuaW5nKSB7XG4gICAgICAgICAgICBzaG93V2FybmluZyhpbnB1dCwgZmVlZGJhY2ssIHdhcm5pbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZU1lc3NhZ2VzKGlucHV0LCBmZWVkYmFjayk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dFcnJvcihpbnB1dCwgZmVlZGJhY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgaW5wdXQuY2xhc3NlZCgnaGFzLXdhcm5pbmcnLCBmYWxzZSk7XG4gICAgICAgIGlucHV0LmNsYXNzZWQoJ2lzLWludmFsaWQnLCB0cnVlKTtcblxuICAgICAgICBmZWVkYmFjay5jbGFzc2VkKCd3YXJuaW5nLWZlZWRiYWNrJywgZmFsc2UpO1xuICAgICAgICBmZWVkYmFjay5jbGFzc2VkKCdpbnZhbGlkLWZlZWRiYWNrJywgdHJ1ZSk7XG4gICAgICAgIGZlZWRiYWNrLnRleHQobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd1dhcm5pbmcoaW5wdXQsIGZlZWRiYWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGlucHV0LmNsYXNzZWQoJ2hhcy13YXJuaW5nJywgdHJ1ZSk7XG4gICAgICAgIGlucHV0LmNsYXNzZWQoJ2lzLWludmFsaWQnLCBmYWxzZSk7XG5cbiAgICAgICAgZmVlZGJhY2suY2xhc3NlZCgnd2FybmluZy1mZWVkYmFjaycsIHRydWUpO1xuICAgICAgICBmZWVkYmFjay5jbGFzc2VkKCdpbnZhbGlkLWZlZWRiYWNrJywgZmFsc2UpO1xuICAgICAgICBmZWVkYmFjay50ZXh0KG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhpZGVNZXNzYWdlcyhpbnB1dCwgZmVlZGJhY2spIHtcbiAgICAgICAgaW5wdXQuY2xhc3NlZCgnaXMtaW52YWxpZCcsIGZhbHNlKTtcbiAgICAgICAgaW5wdXQuY2xhc3NlZCgnaGFzLXdhcm5pbmcnLCBmYWxzZSk7XG5cbiAgICAgICAgZmVlZGJhY2suY2xhc3NlZCgnaW52YWxpZC1mZWVkYmFjaycsIGZhbHNlKTtcbiAgICAgICAgZmVlZGJhY2suY2xhc3NlZCgnd2FybmluZy1mZWVkYmFjaycsIGZhbHNlKTtcbiAgICAgICAgZmVlZGJhY2sudGV4dCgnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHdvSW5wdXRWYWxpZGF0aW9uKCkge1xuICAgICAgICBsZXQgbnVtUm93cyA9ICtyb3dJbnB1dC5wcm9wZXJ0eSgndmFsdWUnKTtcbiAgICAgICAgbGV0IG51bUNvbHMgPSArY29sSW5wdXQucHJvcGVydHkoJ3ZhbHVlJyk7XG5cbiAgICAgICAgaWYgKG51bVJvd3MgPT09IG51bUNvbHMgJiYgbnVtUm93cyA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1czogJ2ludmFsaWQnLCBtZXNzYWdlOiAnQ2Fubm90IGNyZWF0ZSAxeDEgcHV6emxlcyd9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG51bVRpbGVzID0gbnVtQ29scyAqIG51bVJvd3M7XG4gICAgICAgIGlmIChudW1UaWxlcyA+IDQwMCkge1xuXG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1czogJ2ludmFsaWQnLCBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICdDYW5ub3QgY3JlYXRlIHB1enpsZSB3aXRoIG1vcmUgdGhhbiA0MDAgdGlsZXMgKG1heSBjcmFzaCB5b3VyIGJyb3dzZXIpJ307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtVGlsZXMgPiAxMikge1xuXG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1czogJ3dhcm5pbmcnLCBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICdDYXV0aW9uOiB0aGlzIHNpdGUgbWF5IG5vdCBiZSBhYmxlIHRvIG9wdGltYWxseSBzb2x2ZSBwdXp6bGVzIHdpdGggbW9yZSB0aGFuIDEyIHRpbGVzJ307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG51bVJvd3MgPiAxICYmIG51bUNvbHMgPiA1KSB8fCAobnVtQ29scyA+IDEgJiYgbnVtUm93cyA+IDUpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzOiAnd2FybmluZycsIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgJ0NhdXRpb246IHRoaXMgc2l0ZSBtYXkgbm90IGJlIGFibGUgdG8gb3B0aW1hbGx5IHNvbHZlIDJEIHB1enpsZXMgd2l0aCBhIGRpbWVuc2lvblxcXG4gICAgICAgICAgICAgICAgPiA1J307XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7c3RhdHVzOiAndmFsaWQnfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBudW1iZXJWYWxpZGF0aW9uKGlucHV0LCBmZWVkYmFjaykge1xuICAgICAgICBsZXQgdmFsID0gK2lucHV0LnByb3BlcnR5KCd2YWx1ZScpO1xuXG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWwpIHx8IHZhbCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzOiAnaW52YWxpZCcsIG1lc3NhZ2U6ICdOdW1iZXIgbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyJ307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtzdGF0dXM6ICd2YWxpZCd9O1xuICAgIH1cblxuXG4gICAgaW1nVXJsSW5wdXQub24oJ2lucHV0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnZhbHVlO1xuXG4gICAgICAgIGlmICh1cmwgPT09ICcnKSB7XG4gICAgICAgICAgICBoaWRlTWVzc2FnZXMoaW1nVXJsSW5wdXQsIGltZ0ZlZWRiYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHNob3dFcnJvcihpbWdVcmxJbnB1dCwgaW1nRmVlZGJhY2ssICdJbWFnZSBjb3VsZCBub3QgYmUgbG9hZGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgY3JvcHBlci5yZXBsYWNlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgaGlkZU1lc3NhZ2VzKGltZ1VybElucHV0LCBpbWdGZWVkYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0pO1xuXG4gICAgaW1nRmlsZUlucHV0Lm9uKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGltZ1VybElucHV0LnByb3BlcnR5KCd2YWx1ZScsICcnKTtcblxuICAgICAgICBjb25zdCBpbWdVcGxvYWQgPSBpbWdGaWxlSW5wdXQucHJvcGVydHkoJ2ZpbGVzJylbMF07XG4gICAgICAgIGlmIChpbWdVcGxvYWQudHlwZS5pbmNsdWRlcygnaW1hZ2UnKSkge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGUgPT4ge1xuICAgICAgICAgICAgICAgIGNyb3BwZXIucmVwbGFjZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGltZ1VwbG9hZCk7XG5cbiAgICAgICAgICAgIGhpZGVNZXNzYWdlcyhpbWdVcmxJbnB1dCwgaW1nRmVlZGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hvd0Vycm9yKGltZ1VybElucHV0LCBpbWdGZWVkYmFjaywgJ1VwbG9hZGVkIGZpbGUgbXVzdCBiZSBhbiBpbWFnZScpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwdXp6bGVDb25maWdGb3JtLm9uKCdzdWJtaXQnLCAoKSA9PiB7XG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmIChyb3dTdWJtaXQgJiYgY29sU3VibWl0KSB7XG4gICAgICAgICAgICBpbWFnZUNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIGxldCBudW1Sb3dzID0gK3Jvd0lucHV0LnByb3BlcnR5KCd2YWx1ZScpO1xuICAgICAgICAgICAgbGV0IG51bUNvbHMgPSArY29sSW5wdXQucHJvcGVydHkoJ3ZhbHVlJyk7XG5cbiAgICAgICAgICAgIFV0aWwuaGlkZShpbWFnZVVwbG9hZFBhZ2UpO1xuICAgICAgICAgICAgVXRpbC5zaG93KHB1enpsZVBhZ2UpO1xuXG4gICAgICAgICAgICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY3JvcHBlci5nZXRDcm9wQm94RGF0YSgpO1xuICAgICAgICAgICAgc3BsaXRJbWFnZShjcm9wcGVyLmdldENyb3BwZWRDYW52YXMoKS50b0RhdGFVUkwoKSwgd2lkdGgsIGhlaWdodCwgbnVtUm93cywgbnVtQ29scyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQVVpaTEUgUEFHRVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZ1bmN0aW9uIHNwbGl0SW1hZ2Uoc3JjLCB3aWR0aCwgaGVpZ2h0LCBudW1Sb3dzLCBudW1Db2xzKSB7XG5cbiAgICAgICAgLy8gVE9ETzogc3RvcCByZWx5aW5nIG9uIGl0ZXJhdGlvbiBsaW1pdCBhbmQgdXNlIG1lbW9yeS90aW1lIGxpbWl0IGluc3RlYWRcbiAgICAgICAgLy8gKHNpbmNlIGxhcmdlciBwdXp6bGVzIG1ha2UgaXRlcmF0aW9ucyB0YWtlIGxvbmdlcilcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IHtcbiAgICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgICAgIHVuc29sdmFibGU6ICdQdXp6bGUgaXMgdW5zb2x2YWJsZS4gVHJ5IHN3YXBwaW5nIHRpbGVzIGluIHlvdXIgZ29hbCBhbmQvb3Igc3RhcnQgc3RhdGU7XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBseSBzbGlkaW5nIHRpbGVzIGFyb3VuZCB3aWxsIG5vdCBhZmZlY3QgcHV6emxlIHNvbHZhYmlsaXR5LicsXG4gICAgICAgICAgICAgICAgaXRlcmF0aW9uTGltaXQ6ICdQdXp6bGUgdG9vayB0b28gbG9uZyB0byBzb2x2ZTsgZnVydGhlciBzb2x2ZS10aW1lIGNvdWxkIGNyYXNoIHlvdXIgYnJvd3Nlci4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FybmluZ3M6IHtcbiAgICAgICAgICAgICAgICBzb2x2YWJpbGl0eTogJ0JlIGNhcmVmdWwgd2hlbiBzd2FwcGluZyBhbmQgZGVsZXRpbmcgdGlsZXM7IG5vdCBhbGwgcHV6emxlLXN0YXRlcyBhcmUgc29sdmFibGUuJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgVXRpbC5zaG93KHdhcm5pbmdEaXYpO1xuICAgICAgICB3YXJuaW5nTWVzc2FnZS50ZXh0KHN0cmluZ3Mud2FybmluZ3Muc29sdmFiaWxpdHkpO1xuXG4gICAgICAgIGNvbnN0IG1heEdyaWRIZWlnaHQgPSAxMTA7XG4gICAgICAgIGNvbnN0IG1heEdyaWRXaWR0aCA9IDExMDtcblxuICAgICAgICBsZXQgZ3JpZFdpZHRoLCBncmlkSGVpZ2h0O1xuXG4gICAgICAgIC8vIHByZXNlcnZlcyBhc3BlY3QgcmF0aW8gb2YgY3JvcHBlZCBpbWFnZSwgd2l0aCBsYXJnZXN0IGRpbSBzZXQgdG8gbWF4IGRpbSBhYm92ZVxuICAgICAgICBpZiAod2lkdGggPiBoZWlnaHQpIHtcbiAgICAgICAgICAgIGdyaWRXaWR0aCA9IG1heEdyaWRXaWR0aDtcbiAgICAgICAgICAgIGdyaWRIZWlnaHQgPSBtYXhHcmlkSGVpZ2h0ICogaGVpZ2h0L3dpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZEhlaWdodCA9IG1heEdyaWRIZWlnaHQ7XG4gICAgICAgICAgICBncmlkV2lkdGggPSBtYXhHcmlkV2lkdGggKiB3aWR0aC9oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2aWV3Qm94ID0ge3g6IDAsIHk6IDAsIHdpZHRoOiAzMDAsIGhlaWdodDogZ3JpZEhlaWdodCArIDMwfTtcblxuICAgICAgICAvLyBOT1RFOiBoZWlnaHQgbm90IHNldCBpbiBzdmcgYXMgb3ZlcndyaXR0ZW4gYnkgdmlld0JveCBoZWlnaHQgc2NhbGluZyB0byB3aWR0aFxuICAgICAgICBjb25zdCBzdmcgPSBwdXp6bGVDb250YWluZXIuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzEwMCUnKVxuICAgICAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCBgJHt2aWV3Qm94Lnh9ICR7dmlld0JveC55fSAke3ZpZXdCb3gud2lkdGh9ICR7dmlld0JveC5oZWlnaHR9YCk7XG5cbiAgICAgICAgc3ZnLmFwcGVuZCgnZGVmcycpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZmlsdGVyJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnc2hhZG93JylcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZmVEcm9wU2hhZG93JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R4JywgMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0ZERldmlhdGlvbicsIDMpO1xuXG4gICAgICAgIGNvbnN0IGdyaWRQYWRkaW5nID0gKDMwMCAtIGdyaWRXaWR0aCAqIDIpIC8gMztcblxuICAgICAgICAvLyBOT1RFOiAwLjUgcG9zaXRpb25pbmcgaGVscHMgbWFrZSBvdXRsaW5lcyBjcmlzcGVyIChhcyBjb29yZHMgbWFwIHRvIHBpeGVsIHNxdWFyZSBpbnRlcnNlY3Rpb25zKVxuICAgICAgICAvLyAtIGFsc28gaGVscHMgcHJldmVudCBub3RpY2VhYmxlIG91dGxpbmUgZGFya2VuaW5nIGluIG91dGxpbmUgY29vcmQgb3ZlcmxhcCBmb3Igc2FtZSByZWFzb25cbiAgICAgICAgLy8gLSBkaWZmZXJlbmNlIGNhbiBiZSBzZWVuIG1vcmUgZWFzaWx5IHdoZW4gc3Ryb2tlV2lkdGggaW5jcmVhc2VkXG4gICAgICAgIGNvbnN0IHN0YXJ0R3JpZCA9IG5ldyBTdGFydEdyaWQoc3ZnLCBncmlkUGFkZGluZywgMjAuNSwgbnVtUm93cywgbnVtQ29scywgc3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGdyaWRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZ3JpZFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmRyYXcoKTtcblxuICAgICAgICBjb25zdCBnb2FsR3JpZCA9IG5ldyBHb2FsR3JpZChzdmcsIHZpZXdCb3gud2lkdGggLSBncmlkUGFkZGluZyAtIGdyaWRXaWR0aCwgMjAuNSwgbnVtUm93cywgbnVtQ29scywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZ3JpZEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBncmlkV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZHJhdygpO1xuXG4gICAgICAgIGNvbnN0IHRpbGVOdW1iZXJTaXplID0gTWF0aC5taW4oZ3JpZEhlaWdodCAvIG51bVJvd3MgLyAyLCBncmlkV2lkdGggLyBudW1Db2xzIC8gMik7XG5cbiAgICAgICAgc3RhcnRHcmlkLnRpbGVOdW1iZXJzLnN0eWxlKCdmb250LXNpemUnLCBgJHt0aWxlTnVtYmVyU2l6ZX1weGApO1xuICAgICAgICBnb2FsR3JpZC50aWxlTnVtYmVycy5zdHlsZSgnZm9udC1zaXplJywgYCR7dGlsZU51bWJlclNpemV9cHhgKTtcblxuICAgICAgICAvLyBOT1RFOiBub3QgaW5zaWRlIEdyaWQgYXMgbm90IHN1cmUgaWYgd2FudCB0byBkaXNwbGF5IGxhYmVsXG4gICAgICAgIC8vIEFkZGluZyBsYWJlbCB3b3VsZCBtYWtlIHRpbGUgY29vcmRzIGEgbGl0dGxlIG1vcmUgY29uZnVzaW5nXG4gICAgICAgIGNvbnN0IHN0YXJ0TGFiZWwgPSBzdGFydEdyaWQuY29udGFpbmVyLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAuYXR0cigneCcsIHN0YXJ0R3JpZC54ICsgc3RhcnRHcmlkLndpZHRoIC8gMilcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgc3RhcnRHcmlkLnkgLSA1KVxuICAgICAgICAgICAgLnRleHQoJ1N0YXJ0JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdncmlkLXRpdGxlJywgdHJ1ZSk7XG5cbiAgICAgICAgY29uc3QgZ29hbExhYmVsID0gZ29hbEdyaWQuY29udGFpbmVyLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAuYXR0cigneCcsIGdvYWxHcmlkLnggKyBnb2FsR3JpZC53aWR0aCAvIDIpXG4gICAgICAgICAgICAuYXR0cigneScsIGdvYWxHcmlkLnkgLSA1KVxuICAgICAgICAgICAgLnRleHQoJ0dvYWwnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2dyaWQtdGl0bGUnLCB0cnVlKTtcblxuICAgICAgICBjb25zdCBidXR0b25SaWdodCA9IHN2Zy5hcHBlbmQoJ2ltYWdlJylcbiAgICAgICAgICAgIC5hdHRyKCd4Jywgc3RhcnRHcmlkLnggKyBncmlkV2lkdGggKyBncmlkUGFkZGluZyAvIDIgLSA4KVxuICAgICAgICAgICAgLmF0dHIoJ3knLCAnNTAlJylcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDE2KVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDE2KVxuICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLCAnaWNvbnMvcmlnaHQtY2hldnJvbi5zdmcnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3B1enpsZS1hcnJvdycsIHRydWUpXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0R3JpZC5jbG9uZVRpbGVzVG8oZ29hbEdyaWQpO1xuICAgICAgICAgICAgICAgIFV0aWwuaGlkZShlcnJvckRpdik7XG4gICAgICAgICAgICAgICAgY2hlY2tTb2x2YWJpbGl0eSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYnV0dG9uVG9vbGJhciA9IHB1enpsZVBhZ2UuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnRuLXRvb2xiYXIgbWItMiBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyJyk7XG5cbiAgICAgICAgY29uc3QgcHV6emxlQnV0dG9ucyA9IGJ1dHRvblRvb2xiYXIuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnRuLWdyb3VwIG1yLTIgbXktMScpO1xuXG4gICAgICAgIGNvbnN0IG92ZXJsYXlCdXR0b25zID0gYnV0dG9uVG9vbGJhci5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdidG4tZ3JvdXAgbXktMScpO1xuXG4gICAgICAgIGNvbnN0IHNvbHV0aW9uUGFuZWwgPSBwdXp6bGVQYWdlLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjYXJkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgICAgY29uc3Qgc29sdXRpb25QYW5lbEhlYWRpbmcgPSBzb2x1dGlvblBhbmVsLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnY2FyZC1oZWFkZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KCdTb2x1dGlvbicpO1xuXG4gICAgICAgIGNvbnN0IHNvbHV0aW9uUGFuZWxCb2R5ID0gc29sdXRpb25QYW5lbC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnY2FyZC1ib2R5JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWF4LWhlaWdodCcsICcxMDBweCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ292ZXJmbG93LXknLCAnc2Nyb2xsJyk7XG5cbiAgICAgICAgLy8gTk9URTogYXNzdW1lcyBzdGFydGluZyBzdGF0ZSBpcyBzb2x2YWJsZVxuICAgICAgICBjb25zdCBzaHVmZmxlQnV0dG9uID0gcHV6emxlQnV0dG9ucy5hcHBlbmQoJ2J1dHRvbicpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnRuIGJ0bi1zZWNvbmRhcnknKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3NodWZmbGUtYnV0dG9uJylcbiAgICAgICAgICAgIC5wcm9wZXJ0eSgnZGlzYWJsZWQnLCB0cnVlKVxuICAgICAgICAgICAgLnRleHQoJ1NodWZmbGUnKVxuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byBwYXNzIGluIFwidGhpc1wiIGZyb20gY2xpY2tcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhcnRHcmlkLnNodWZmbGUoKTtcbiAgICAgICAgICAgICAgICBVdGlsLmhpZGUoZXJyb3JEaXYpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgaGF2aW5nIGFuaW1hdGlvbnMgcmV0dXJuIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBldmVyeXRoaW5nIGFuaW1hdGVkXG4gICAgICAgIC8vIHRoYXQgd2F5LCBjYW4gZGlzYWJsZSBhbmQgZW5hYmxlIHNvbHZlL3NodWZmbGUgYWZ0ZXIgcHJvbWlzZSByZXNvbHZlc1xuICAgICAgICAvLyBhbHNvIGFkZCBsb2FkaW5nIGluZGljYXRpb24gKGF0IG1pbmltdW0sIHNob3cgbG9hZGluZyBjdXJzb3IpXG4gICAgICAgIGNvbnN0IHNvbHZlQnV0dG9uID0gcHV6emxlQnV0dG9ucy5hcHBlbmQoJ2J1dHRvbicpXG4gICAgICAgICAgICAucHJvcGVydHkoJ2Rpc2FibGVkJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdidG4gYnRuLXNlY29uZGFyeScpXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnc29sdmUtYnV0dG9uJylcbiAgICAgICAgICAgIC50ZXh0KCdTb2x2ZScpXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBsZXQgcHV6emxlID0gbmV3IFB1enpsZShudW1Sb3dzLCBudW1Db2xzLCBHcmlkLmdldEFycmF5UmVwcmVzZW50YXRpb24oc3RhcnRHcmlkLCBnb2FsR3JpZCksXG4gICAgICAgICAgICAvLyAgICAgc3RhcnRHcmlkLmVtcHR5UG9zKTtcblxuICAgICAgICAgICAgLy8gYWxsb3dzIHNvbHZpbmcgb2YgcHV6emxlIGluIHNlcGFyYXRlIHRocmVhZCB0byBwcmV2ZW50IGJsb2NraW5nIG9mIFVJXG4gICAgICAgICAgICBsZXQgd29ya2VyID0gbmV3IFB1enpsZVNvbHZlcldvcmtlcigpO1xuXG4gICAgICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGFucyA9IGUuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWwuc2hvdyhzb2x1dGlvblBhbmVsKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRHcmlkLmFuaW1hdGVNb3ZlcyhhbnMsIHNvbHV0aW9uUGFuZWxCb2R5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzb2x2ZXIgY291bGQgbm90IGZpbmQgc29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgVXRpbC5zaG93KGVycm9yRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEaXYubm9kZSgpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbnMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtb2RpZnkgd2hlbiBJREEqIHRpbWUvaXRlcmF0aW9uIGxpbWl0IGltcGxlbWVudGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UudGV4dChzdHJpbmdzLmVycm9ycy5pdGVyYXRpb25MaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UudGV4dChzdHJpbmdzLmVycm9ycy51bnNvbHZhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKFtudW1Sb3dzLCBudW1Db2xzLCBHcmlkLmdldEFycmF5UmVwcmVzZW50YXRpb24oc3RhcnRHcmlkLCBnb2FsR3JpZCksXG4gICAgICAgICAgICAgICAgc3RhcnRHcmlkLmVtcHR5UG9zXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc2V0UHV6emxlQnV0dG9uID0gcHV6emxlQnV0dG9ucy5hcHBlbmQoJ2J1dHRvbicpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnRuIGJ0bi1zZWNvbmRhcnknKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3Jlc2V0LXB1enpsZS1idXR0b24nKVxuICAgICAgICAgICAgLnRleHQoJ1Jlc2V0JylcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhcnRHcmlkLnJlc2V0VGlsZXMoKTtcbiAgICAgICAgICAgICAgICBnb2FsR3JpZC5yZXNldFRpbGVzKCk7XG4gICAgICAgICAgICAgICAgVXRpbC5oaWRlKHNvbHV0aW9uUGFuZWwpO1xuICAgICAgICAgICAgICAgIHNvbHZlQnV0dG9uLnByb3BlcnR5KCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGVzIG1vZGUgdG8gdGlsZSBkZWxldGlvbiBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZU1vdXNlTW9kZUJ1dHRvbi50ZXh0KCkgPT09ICdUaWxlIERlbGV0aW9uIE1vZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZU1vdXNlTW9kZUJ1dHRvbi5ub2RlKCkuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9nZ2xlTW91c2VNb2RlQnV0dG9uLnByb3BlcnR5KCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNodWZmbGVCdXR0b24ucHJvcGVydHkoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgVXRpbC5oaWRlKGVycm9yRGl2KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG51bWJlck92ZXJsYXlCdXR0b24gPSBvdmVybGF5QnV0dG9ucy5hcHBlbmQoJ2J1dHRvbicpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnRuIGJ0bi1zZWNvbmRhcnknKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ251bWJlci1vdmVybGF5LWJ1dHRvbicpXG4gICAgICAgICAgICAudGV4dCgnU2hvdyBOdW1iZXIgT3ZlcmxheScpXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0R3JpZC50b2dnbGVOdW1iZXJPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgZ29hbEdyaWQudG9nZ2xlTnVtYmVyT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbnVtYmVyT3ZlcmxheUJ1dHRvbi50ZXh0KCkgPT09ICdTaG93IE51bWJlciBPdmVybGF5JyA/XG4gICAgICAgICAgICAgICAgICAgICdIaWRlIE51bWJlciBPdmVybGF5JyA6ICdTaG93IE51bWJlciBPdmVybGF5JztcbiAgICAgICAgICAgICAgICBudW1iZXJPdmVybGF5QnV0dG9uLnRleHQodGV4dCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0b2dnbGVNb3VzZU1vZGVCdXR0b24gPSBvdmVybGF5QnV0dG9ucy5hcHBlbmQoJ2J1dHRvbicpXG4gICAgICAgICAgICAvLyBjYW5ub3Qgc3RhcnQgbW92aW5nIHRpbGVzIHVudGlsIG9uZSBpcyBkZWxldGVkIChlbXB0eSBwb3NpdGlvbiBjaG9zZW4pXG4gICAgICAgICAgICAucHJvcGVydHkoJ2Rpc2FibGVkJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdidG4gYnRuLXNlY29uZGFyeScpXG4gICAgICAgICAgICAuYXR0cignaWQnLCAndG9nZ2xlLW1vdXNlLW1vZGUtYnV0dG9uJylcbiAgICAgICAgICAgIC50ZXh0KCdUaWxlIFNlbGVjdGlvbiBNb2RlJylcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRHcmlkLnRvZ2dsZVRpbGVPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgZ29hbEdyaWQudG9nZ2xlVGlsZU92ZXJsYXkoKTtcblxuICAgICAgICAgICAgICAgIGxldCBidXR0b24gPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSBidXR0b24udGV4dCgpID09PSAnVGlsZSBEZWxldGlvbiBNb2RlJyA/XG4gICAgICAgICAgICAgICAgICAgICAnVGlsZSBTZWxlY3Rpb24gTW9kZScgOiAnVGlsZSBEZWxldGlvbiBNb2RlJztcblxuICAgICAgICAgICAgICAgIGJ1dHRvbi50ZXh0KHRleHQpO1xuXG4gICAgICAgICAgICAgICAgc3RhcnRHcmlkLmRlc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgZ29hbEdyaWQuZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGxvb2tpbmcgaW50byBkcm9wIGhhbmRsZXIgaW5zdGVhZCBvZiBnZXR0aW5nIHRpbGUgZnJvbSAoeCwgeSkgaW4gR3JpZFxuICAgICAgICBjb25zdCBkcmFnSGFuZGxlciA9IGQzLmRyYWcoKVxuICAgICAgICAgICAgLnN1YmplY3QoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7eDogZC5jZWxsLngsIHk6IGQuY2VsbC55fVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIGRvbid0IGRyYWcgdGlsZSBpZiBpbiBkZWxldGUgbW9kZSBvciB0aWxlIGlzIGVtcHR5XG4gICAgICAgICAgICAuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhZC5ncmlkLmRlbGV0ZU92ZXJsYXkgJiYgIWQuZ3JpZC5oYXNFbXB0eVRpbGUoZC50aWxlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkcmFnZ2luZycpO1xuXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2RyYWdnaW5nJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiByYWlzZSgpIGV4ZWN1dGVzIGluICdkcmFnJyByYXRoZXIgdGhhbiAnc3RhcnQnIGFzIGFwcGVuZENoaWxkIChjYWxsZWQgYnkgcmFpc2UoKSlcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50cyBjYWxsIG9mIGNsaWNrIGhhbmRsZXIgKHVuZGVzaXJhYmxlLCBzaW5jZSAnc3RhcnQnIGlzIGNhbGxlZCBvbiBjbGlja3MpXG5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBub3QgYXMgaW5lZmZpY2llbnQgYXMgaXQgbWF5IHNlZW0sIGFzIGZ1bmN0aW9uIG9ubHkgbW92ZXMgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgbm90IGxhc3QgZWxlbWVudCBpbiBwYXJlbnRcblxuICAgICAgICAgICAgICAgIC8vIG1vdmVzIGNvbnRhaW5lciBvZiB0aWxlIHRvIGZyb250IHNvIHRoYXQgZHJhZ2dlZCB0aWxlIGRyYXduIGFib3ZlIG90aGVyIHB1enpsZVxuICAgICAgICAgICAgICAgIGQuZ3JpZC5jb250YWluZXIucmFpc2UoKTtcblxuICAgICAgICAgICAgICAgIC8vIG1vdmVzIHRpbGUgdG8gZnJvbnQgc28gZHJhd24gaW4gZnJvbnQgb2Ygb3RoZXIgdGlsZXNcbiAgICAgICAgICAgICAgICBkLnRpbGUucmFpc2UoKTtcblxuICAgICAgICAgICAgICAgIGQuZ3JpZC5jb250YWluZXIubm9kZSgpLmZvY3VzKCk7XG5cbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBkMy5ldmVudC54KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGQzLmV2ZW50LnkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIE5PVEU6IGQzIHN0aWxsIGNhbGxzIHN0YXJ0IGFuZCBlbmQgb24gY2xpY2sgKGZpcmVzIGJlZm9yZSBjbGljayBoYW5kbGVyKVxuICAgICAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkcmFnIGVuZCcpO1xuXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2RyYWdnaW5nJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG9yaWdpbmFsIGltYWdlIHRvIHN0YXJ0aW5nIHBvc2l0aW9uIG9uIHJlbGVhc2VcbiAgICAgICAgICAgICAgICBsZXQgdGlsZUNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGQuY2VsbC54KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGQuY2VsbC55KTtcblxuICAgICAgICAgICAgICAgIGxldCBbbW91c2VYLCBtb3VzZVldID0gZDMubW91c2Uoc3ZnLm5vZGUoKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWdvYWxHcmlkLmRyb3BUaWxlKHRpbGVDb250YWluZXIsIG1vdXNlWCwgbW91c2VZKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydEdyaWQuZHJvcFRpbGUodGlsZUNvbnRhaW5lciwgbW91c2VYLCBtb3VzZVkpO1xuICAgICAgICAgICAgICAgICAgICBjaGVja1NvbHZhYmlsaXR5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hlY2tTb2x2YWJpbGl0eSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhcnRHcmlkLnRpbGVDb250YWluZXJzLmNhbGwoZHJhZ0hhbmRsZXIpO1xuICAgICAgICBnb2FsR3JpZC50aWxlQ29udGFpbmVycy5jYWxsKGRyYWdIYW5kbGVyKTtcblxuICAgICAgICBzdGFydEdyaWQudGlsZUNvbnRhaW5lcnMub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXJ0R3JpZC5jbGlja1RpbGUodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQubWV0aG9kID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgIGdvYWxHcmlkLmRlbGV0ZVRpbGVXaXRoU3RhcnRpbmdUaWxlKHJlc3VsdC50aWxlKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVNb3VzZU1vZGVCdXR0b24ucHJvcGVydHkoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNodWZmbGVCdXR0b24ucHJvcGVydHkoJ2Rpc2FibGVkJywgZmFsc2UpO1xuXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lm1ldGhvZCA9PT0gJ3NlbGVjdCcgJiYgZ29hbEdyaWQuc2VsZWN0ZWRUaWxlcy5zaXplID09PSAxKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgZ29hbFRpbGUgPSBnb2FsR3JpZC5zZWxlY3RlZFRpbGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHRpbGVzIGNhbm5vdCBiZSBjbG9uZWQgdG8gZ29hbCBUaWxlXG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydEdyaWQuaGFzRW1wdHlUaWxlKHJlc3VsdC50aWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBHcmlkLmNsb25lVGlsZShyZXN1bHQudGlsZSwgZ29hbFRpbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdvYWxHcmlkLmRlc2VsZWN0VGlsZShnb2FsVGlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0R3JpZC5kZXNlbGVjdFRpbGUocmVzdWx0LnRpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hlY2tTb2x2YWJpbGl0eSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBnb2FsR3JpZC50aWxlQ29udGFpbmVycy5vbignY2xpY2snLCBmdW5jdGlvbihkKSB7XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBnb2FsR3JpZC5jbGlja1RpbGUodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQubWV0aG9kID09PSAnc2VsZWN0JyAmJiBzdGFydEdyaWQuc2VsZWN0ZWRUaWxlcy5zaXplID09PSAxKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRUaWxlID0gc3RhcnRHcmlkLnNlbGVjdGVkVGlsZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgdGlsZXMgY2Fubm90IGJlIGNsb25lZCB0byBnb2FsIFRpbGVcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0R3JpZC5oYXNFbXB0eVRpbGUoc3RhcnRUaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBHcmlkLmNsb25lVGlsZShzdGFydFRpbGUsIHJlc3VsdC50aWxlKTtcblxuICAgICAgICAgICAgICAgICAgICBnb2FsR3JpZC5kZXNlbGVjdFRpbGUocmVzdWx0LnRpbGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydEdyaWQuZGVzZWxlY3RUaWxlKHN0YXJ0VGlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGVja1NvbHZhYmlsaXR5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGFsbG93aW5nIG1vdmVtZW50IG9mIHNlbGVjdGVkIHRpbGUgKG1haW5seSBmb3IgbW92aW5nIHRpbGVzIGluIHBhcnRpYWxseSBhc3NpZ25lZCBnb2FsKVxuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGRlc2VsZWN0aW5nIHRpbGUgaWYgaXQncyBkcmFnZ2VkIG9yIGRyb3BwZWQgb250b1xuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIG92ZXJ3cml0aW5nIHRpbGUgcmF0aGVyIHRoYW4gc3dhcHBpbmcgdGhlbSB3aGVuIGEgdGlsZSB3aXRoIG1hdGNoIGlzIGRyYWdnZWQgdG8gYW4gb2NjdXBpZWQgdGlsZVxuXG4gICAgICAgIGNvbnN0IGFycm93TW92ZW1lbnRIYW5kbGVyID0gZnVuY3Rpb24oc2VsZWN0ZWRHcmlkKSB7XG5cbiAgICAgICAgICAgIGxldCBrZXkgPSBkMy5ldmVudC5rZXk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IEtFWV9NQVBQSU5HID0ge1xuICAgICAgICAgICAgICAgICdBcnJvd0xlZnQnOiAnbCcsXG4gICAgICAgICAgICAgICAgJ0Fycm93UmlnaHQnOiAncicsXG4gICAgICAgICAgICAgICAgJ0Fycm93VXAnOiAndScsXG4gICAgICAgICAgICAgICAgJ0Fycm93RG93bic6ICdkJyxcbiAgICAgICAgICAgICAgICAndycgOiAndScsXG4gICAgICAgICAgICAgICAgJ2EnOiAnbCcsXG4gICAgICAgICAgICAgICAgJ3MnOiAnZCcsXG4gICAgICAgICAgICAgICAgJ2QnOiAncidcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1vdmUgPSBLRVlfTUFQUElOR1trZXldO1xuICAgICAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50cyBhcnJvdyBrZXlzIGZyb20gc2Nyb2xsaW5nIHNjcmVlblxuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RlZEdyaWQuYW5pbWF0ZU1vdmUobW92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydEdyaWQuY29udGFpbmVyLm9uKCdrZXlkb3duJywgYXJyb3dNb3ZlbWVudEhhbmRsZXIpO1xuICAgICAgICBnb2FsR3JpZC5jb250YWluZXIub24oJ2tleWRvd24nLCBhcnJvd01vdmVtZW50SGFuZGxlcik7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tTb2x2YWJpbGl0eSgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydEdyaWQuZW1wdHlQb3MgIT09IG51bGwgJiYgZ29hbEdyaWQuaXNGdWxsKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoR3JpZC5pc1NvbHZhYmxlKHN0YXJ0R3JpZCwgZ29hbEdyaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWwuaGlkZShlcnJvckRpdik7XG4gICAgICAgICAgICAgICAgICAgIHNvbHZlQnV0dG9uLnByb3BlcnR5KCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZS50ZXh0KHN0cmluZ3MuZXJyb3JzLnVuc29sdmFibGUpO1xuICAgICAgICAgICAgICAgIFV0aWwuc2hvdyhlcnJvckRpdik7XG4gICAgICAgICAgICAgICAgZXJyb3JEaXYubm9kZSgpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNvbHZlQnV0dG9uLnByb3BlcnR5KCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgfVxufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/script.js\n");

/***/ })

/******/ });
//# sourceMappingURL=.bundle.js.map