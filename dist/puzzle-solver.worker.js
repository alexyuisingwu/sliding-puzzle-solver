/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/babel-loader/lib/index.js?!./src/puzzle-solver.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/avl/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/avl/src/index.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AVLTree; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/avl/src/utils.js\");\n\n\n\n// function createNode (parent, left, right, height, key, data) {\n//   return { parent, left, right, balanceFactor: height, key, data };\n// }\n\n/**\n * @typedef {{\n *   parent:        ?Node,\n *   left:          ?Node,\n *   right:         ?Node,\n *   balanceFactor: number,\n *   key:           Key,\n *   data:          Value\n * }} Node\n */\n\n/**\n * @typedef {*} Key\n */\n\n/**\n * @typedef {*} Value\n */\n\n/**\n * Default comparison function\n * @param {Key} a\n * @param {Key} b\n * @returns {number}\n */\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n\n/**\n * Single left rotation\n * @param  {Node} node\n * @return {Node}\n */\nfunction rotateLeft (node) {\n  var rightNode = node.right;\n  node.right    = rightNode.left;\n\n  if (rightNode.left) rightNode.left.parent = node;\n\n  rightNode.parent = node.parent;\n  if (rightNode.parent) {\n    if (rightNode.parent.left === node) {\n      rightNode.parent.left = rightNode;\n    } else {\n      rightNode.parent.right = rightNode;\n    }\n  }\n\n  node.parent    = rightNode;\n  rightNode.left = node;\n\n  node.balanceFactor += 1;\n  if (rightNode.balanceFactor < 0) {\n    node.balanceFactor -= rightNode.balanceFactor;\n  }\n\n  rightNode.balanceFactor += 1;\n  if (node.balanceFactor > 0) {\n    rightNode.balanceFactor += node.balanceFactor;\n  }\n  return rightNode;\n}\n\n\nfunction rotateRight (node) {\n  var leftNode = node.left;\n  node.left = leftNode.right;\n  if (node.left) node.left.parent = node;\n\n  leftNode.parent = node.parent;\n  if (leftNode.parent) {\n    if (leftNode.parent.left === node) {\n      leftNode.parent.left = leftNode;\n    } else {\n      leftNode.parent.right = leftNode;\n    }\n  }\n\n  node.parent    = leftNode;\n  leftNode.right = node;\n\n  node.balanceFactor -= 1;\n  if (leftNode.balanceFactor > 0) {\n    node.balanceFactor -= leftNode.balanceFactor;\n  }\n\n  leftNode.balanceFactor -= 1;\n  if (node.balanceFactor < 0) {\n    leftNode.balanceFactor += node.balanceFactor;\n  }\n\n  return leftNode;\n}\n\n\n// function leftBalance (node) {\n//   if (node.left.balanceFactor === -1) rotateLeft(node.left);\n//   return rotateRight(node);\n// }\n\n\n// function rightBalance (node) {\n//   if (node.right.balanceFactor === 1) rotateRight(node.right);\n//   return rotateLeft(node);\n// }\n\n\nclass AVLTree {\n  /**\n   * Callback for comparator\n   * @callback comparatorCallback\n   * @param {Key} a\n   * @param {Key} b\n   * @returns {number}\n   */\n\n  /**\n   * @class AVLTree\n   * @constructor\n   * @param  {comparatorCallback} [comparator]\n   * @param  {boolean}            [noDuplicates=false] Disallow duplicates\n   */\n  constructor (comparator, noDuplicates = false) {\n    this._comparator = comparator || DEFAULT_COMPARE;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  }\n\n\n  /**\n   * Clear the tree\n   * @return {AVLTree}\n   */\n  destroy() {\n    return this.clear();\n  }\n\n\n  /**\n   * Clear the tree\n   * @return {AVLTree}\n   */\n  clear() {\n    this._root = null;\n    this._size = 0;\n    return this;\n  }\n\n  /**\n   * Number of nodes\n   * @return {number}\n   */\n  get size () {\n    return this._size;\n  }\n\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param  {Key} key\n   * @return {boolean} true/false\n   */\n  contains (key) {\n    if (this._root)  {\n      var node       = this._root;\n      var comparator = this._comparator;\n      while (node)  {\n        var cmp = comparator(key, node.key);\n        if      (cmp === 0) return true;\n        else if (cmp < 0)   node = node.left;\n        else                node = node.right;\n      }\n    }\n    return false;\n  }\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor.left) successor = successor.left;\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  }\n\n\n  /**\n   * Predecessor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor.right) predecessor = predecessor.right;\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  }\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * Callback for forEach\n   * @callback forEachCallback\n   * @param {Node} node\n   * @param {number} index\n   */\n\n  /**\n   * @param  {forEachCallback} callback\n   * @return {AVLTree}\n   */\n  forEach(callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range(low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._comparator;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Returns node with the minimum key\n   * @return {?Node}\n   */\n  minNode () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.left) node = node.left;\n    return node;\n  }\n\n\n  /**\n   * Returns node with the max key\n   * @return {?Node}\n   */\n  maxNode () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.right) node = node.right;\n    return node;\n  }\n\n\n  /**\n   * Min key\n   * @return {?Key}\n   */\n  min () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.left) node = node.left;\n    return node.key;\n  }\n\n\n  /**\n   * Max key\n   * @return {?Key}\n   */\n  max () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.right) node = node.right;\n    return node.key;\n  }\n\n\n  /**\n   * @return {boolean} true/false\n   */\n  isEmpty() {\n    return !this._root;\n  }\n\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) node = node.left;\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  }\n\n\n  /**\n   * Find node by key\n   * @param  {Key} key\n   * @return {?Node}\n   */\n  find (key) {\n    var root = this._root;\n    // if (root === null)    return null;\n    // if (key === root.key) return root;\n\n    var subtree = root, cmp;\n    var compare = this._comparator;\n    while (subtree) {\n      cmp = compare(key, subtree.key);\n      if      (cmp === 0) return subtree;\n      else if (cmp < 0)   subtree = subtree.left;\n      else                subtree = subtree.right;\n    }\n\n    return null;\n  }\n\n\n  /**\n   * Insert a node into the tree\n   * @param  {Key} key\n   * @param  {Value} [data]\n   * @return {?Node}\n   */\n  insert (key, data) {\n    if (!this._root) {\n      this._root = {\n        parent: null, left: null, right: null, balanceFactor: 0,\n        key, data\n      };\n      this._size++;\n      return this._root;\n    }\n\n    var compare = this._comparator;\n    var node    = this._root;\n    var parent  = null;\n    var cmp     = 0;\n\n    if (this._noDuplicates) {\n      while (node) {\n        cmp = compare(key, node.key);\n        parent = node;\n        if      (cmp === 0) return null;\n        else if (cmp < 0)   node = node.left;\n        else                node = node.right;\n      }\n    } else {\n      while (node) {\n        cmp = compare(key, node.key);\n        parent = node;\n        if      (cmp <= 0)  node = node.left; //return null;\n        else                node = node.right;\n      }\n    }\n\n    var newNode = {\n      left: null,\n      right: null,\n      balanceFactor: 0,\n      parent, key, data\n    };\n    var newRoot;\n    if (cmp <= 0) parent.left  = newNode;\n    else         parent.right = newNode;\n\n    while (parent) {\n      cmp = compare(parent.key, key);\n      if (cmp < 0) parent.balanceFactor -= 1;\n      else         parent.balanceFactor += 1;\n\n      if        (parent.balanceFactor === 0) break;\n      else if   (parent.balanceFactor < -1) {\n        // inlined\n        //var newRoot = rightBalance(parent);\n        if (parent.right.balanceFactor === 1) rotateRight(parent.right);\n        newRoot = rotateLeft(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        break;\n      } else if (parent.balanceFactor > 1) {\n        // inlined\n        // var newRoot = leftBalance(parent);\n        if (parent.left.balanceFactor === -1) rotateLeft(parent.left);\n        newRoot = rotateRight(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        break;\n      }\n      parent = parent.parent;\n    }\n\n    this._size++;\n    return newNode;\n  }\n\n\n  /**\n   * Removes the node from the tree. If not found, returns null.\n   * @param  {Key} key\n   * @return {?Node}\n   */\n  remove (key) {\n    if (!this._root) return null;\n\n    var node = this._root;\n    var compare = this._comparator;\n    var cmp = 0;\n\n    while (node) {\n      cmp = compare(key, node.key);\n      if      (cmp === 0) break;\n      else if (cmp < 0)   node = node.left;\n      else                node = node.right;\n    }\n    if (!node) return null;\n\n    var returnValue = node.key;\n    var max, min;\n\n    if (node.left) {\n      max = node.left;\n\n      while (max.left || max.right) {\n        while (max.right) max = max.right;\n\n        node.key = max.key;\n        node.data = max.data;\n        if (max.left) {\n          node = max;\n          max = max.left;\n        }\n      }\n\n      node.key  = max.key;\n      node.data = max.data;\n      node = max;\n    }\n\n    if (node.right) {\n      min = node.right;\n\n      while (min.left || min.right) {\n        while (min.left) min = min.left;\n\n        node.key  = min.key;\n        node.data = min.data;\n        if (min.right) {\n          node = min;\n          min = min.right;\n        }\n      }\n\n      node.key  = min.key;\n      node.data = min.data;\n      node = min;\n    }\n\n    var parent = node.parent;\n    var pp     = node;\n    var newRoot;\n\n    while (parent) {\n      if (parent.left === pp) parent.balanceFactor -= 1;\n      else                    parent.balanceFactor += 1;\n\n      if        (parent.balanceFactor < -1) {\n        // inlined\n        //var newRoot = rightBalance(parent);\n        if (parent.right.balanceFactor === 1) rotateRight(parent.right);\n        newRoot = rotateLeft(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        parent = newRoot;\n      } else if (parent.balanceFactor > 1) {\n        // inlined\n        // var newRoot = leftBalance(parent);\n        if (parent.left.balanceFactor === -1) rotateLeft(parent.left);\n        newRoot = rotateRight(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        parent = newRoot;\n      }\n\n      if (parent.balanceFactor === -1 || parent.balanceFactor === 1) break;\n\n      pp     = parent;\n      parent = parent.parent;\n    }\n\n    if (node.parent) {\n      if (node.parent.left === node) node.parent.left  = null;\n      else                           node.parent.right = null;\n    }\n\n    if (node === this._root) this._root = null;\n\n    this._size--;\n    return returnValue;\n  }\n\n\n  /**\n   * Bulk-load items\n   * @param  {Array<Key>}  keys\n   * @param  {Array<Value>}  [values]\n   * @return {AVLTree}\n   */\n  load(keys = [], values = [], presort) {\n    if (this._size !== 0) throw new Error('bulk-load: tree is not empty');\n    const size = keys.length;\n    if (presort) Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"sort\"])(keys, values, 0, size - 1, this._comparator);\n    this._root = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"loadRecursive\"])(null, keys, values, 0, size);\n    Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"markBalance\"])(this._root);\n    this._size = size;\n    return this;\n  }\n\n\n  /**\n   * Returns true if the tree is balanced\n   * @return {boolean}\n   */\n  isBalanced() {\n    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isBalanced\"])(this._root);\n  }\n\n\n  /**\n   * String representation of the tree - primitive horizontal print-out\n   * @param  {Function(Node):string} [printNode]\n   * @return {string}\n   */\n  toString (printNode) {\n    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"print\"])(this._root, printNode);\n  }\n}\n\nAVLTree.default = AVLTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXZsL3NyYy9pbmRleC5qcz8wMTNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUE4RTs7O0FBRzlFO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLEVBQUU7QUFDZjs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLElBQUk7QUFDZixhQUFhO0FBQ2I7QUFDQSxpQ0FBaUMsbUNBQW1DOzs7QUFHcEU7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsSUFBSTtBQUNqQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakMsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixjQUFjLElBQUk7QUFDbEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsR0FBRztBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLGFBQWE7QUFDM0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFJO0FBQ3JCLGlCQUFpQiw0REFBYTtBQUM5QixJQUFJLDBEQUFXO0FBQ2Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXLHlEQUFVO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXLG9EQUFLO0FBQ2hCO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXZsL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByaW50LCBpc0JhbGFuY2VkLCBsb2FkUmVjdXJzaXZlLCBtYXJrQmFsYW5jZSwgc29ydCB9IGZyb20gJy4vdXRpbHMnO1xuXG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZU5vZGUgKHBhcmVudCwgbGVmdCwgcmlnaHQsIGhlaWdodCwga2V5LCBkYXRhKSB7XG4vLyAgIHJldHVybiB7IHBhcmVudCwgbGVmdCwgcmlnaHQsIGJhbGFuY2VGYWN0b3I6IGhlaWdodCwga2V5LCBkYXRhIH07XG4vLyB9XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgcGFyZW50OiAgICAgICAgP05vZGUsXG4gKiAgIGxlZnQ6ICAgICAgICAgID9Ob2RlLFxuICogICByaWdodDogICAgICAgICA/Tm9kZSxcbiAqICAgYmFsYW5jZUZhY3RvcjogbnVtYmVyLFxuICogICBrZXk6ICAgICAgICAgICBLZXksXG4gKiAgIGRhdGE6ICAgICAgICAgIFZhbHVlXG4gKiB9fSBOb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Kn0gS2V5XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Kn0gVmFsdWVcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvblxuICogQHBhcmFtIHtLZXl9IGFcbiAqIEBwYXJhbSB7S2V5fSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBERUZBVUxUX0NPTVBBUkUgKGEsIGIpIHsgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwOyB9XG5cblxuLyoqXG4gKiBTaW5nbGUgbGVmdCByb3RhdGlvblxuICogQHBhcmFtICB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZnVuY3Rpb24gcm90YXRlTGVmdCAobm9kZSkge1xuICB2YXIgcmlnaHROb2RlID0gbm9kZS5yaWdodDtcbiAgbm9kZS5yaWdodCAgICA9IHJpZ2h0Tm9kZS5sZWZ0O1xuXG4gIGlmIChyaWdodE5vZGUubGVmdCkgcmlnaHROb2RlLmxlZnQucGFyZW50ID0gbm9kZTtcblxuICByaWdodE5vZGUucGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gIGlmIChyaWdodE5vZGUucGFyZW50KSB7XG4gICAgaWYgKHJpZ2h0Tm9kZS5wYXJlbnQubGVmdCA9PT0gbm9kZSkge1xuICAgICAgcmlnaHROb2RlLnBhcmVudC5sZWZ0ID0gcmlnaHROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodE5vZGUucGFyZW50LnJpZ2h0ID0gcmlnaHROb2RlO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUucGFyZW50ICAgID0gcmlnaHROb2RlO1xuICByaWdodE5vZGUubGVmdCA9IG5vZGU7XG5cbiAgbm9kZS5iYWxhbmNlRmFjdG9yICs9IDE7XG4gIGlmIChyaWdodE5vZGUuYmFsYW5jZUZhY3RvciA8IDApIHtcbiAgICBub2RlLmJhbGFuY2VGYWN0b3IgLT0gcmlnaHROb2RlLmJhbGFuY2VGYWN0b3I7XG4gIH1cblxuICByaWdodE5vZGUuYmFsYW5jZUZhY3RvciArPSAxO1xuICBpZiAobm9kZS5iYWxhbmNlRmFjdG9yID4gMCkge1xuICAgIHJpZ2h0Tm9kZS5iYWxhbmNlRmFjdG9yICs9IG5vZGUuYmFsYW5jZUZhY3RvcjtcbiAgfVxuICByZXR1cm4gcmlnaHROb2RlO1xufVxuXG5cbmZ1bmN0aW9uIHJvdGF0ZVJpZ2h0IChub2RlKSB7XG4gIHZhciBsZWZ0Tm9kZSA9IG5vZGUubGVmdDtcbiAgbm9kZS5sZWZ0ID0gbGVmdE5vZGUucmlnaHQ7XG4gIGlmIChub2RlLmxlZnQpIG5vZGUubGVmdC5wYXJlbnQgPSBub2RlO1xuXG4gIGxlZnROb2RlLnBhcmVudCA9IG5vZGUucGFyZW50O1xuICBpZiAobGVmdE5vZGUucGFyZW50KSB7XG4gICAgaWYgKGxlZnROb2RlLnBhcmVudC5sZWZ0ID09PSBub2RlKSB7XG4gICAgICBsZWZ0Tm9kZS5wYXJlbnQubGVmdCA9IGxlZnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0Tm9kZS5wYXJlbnQucmlnaHQgPSBsZWZ0Tm9kZTtcbiAgICB9XG4gIH1cblxuICBub2RlLnBhcmVudCAgICA9IGxlZnROb2RlO1xuICBsZWZ0Tm9kZS5yaWdodCA9IG5vZGU7XG5cbiAgbm9kZS5iYWxhbmNlRmFjdG9yIC09IDE7XG4gIGlmIChsZWZ0Tm9kZS5iYWxhbmNlRmFjdG9yID4gMCkge1xuICAgIG5vZGUuYmFsYW5jZUZhY3RvciAtPSBsZWZ0Tm9kZS5iYWxhbmNlRmFjdG9yO1xuICB9XG5cbiAgbGVmdE5vZGUuYmFsYW5jZUZhY3RvciAtPSAxO1xuICBpZiAobm9kZS5iYWxhbmNlRmFjdG9yIDwgMCkge1xuICAgIGxlZnROb2RlLmJhbGFuY2VGYWN0b3IgKz0gbm9kZS5iYWxhbmNlRmFjdG9yO1xuICB9XG5cbiAgcmV0dXJuIGxlZnROb2RlO1xufVxuXG5cbi8vIGZ1bmN0aW9uIGxlZnRCYWxhbmNlIChub2RlKSB7XG4vLyAgIGlmIChub2RlLmxlZnQuYmFsYW5jZUZhY3RvciA9PT0gLTEpIHJvdGF0ZUxlZnQobm9kZS5sZWZ0KTtcbi8vICAgcmV0dXJuIHJvdGF0ZVJpZ2h0KG5vZGUpO1xuLy8gfVxuXG5cbi8vIGZ1bmN0aW9uIHJpZ2h0QmFsYW5jZSAobm9kZSkge1xuLy8gICBpZiAobm9kZS5yaWdodC5iYWxhbmNlRmFjdG9yID09PSAxKSByb3RhdGVSaWdodChub2RlLnJpZ2h0KTtcbi8vICAgcmV0dXJuIHJvdGF0ZUxlZnQobm9kZSk7XG4vLyB9XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQVZMVHJlZSB7XG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgY29tcGFyYXRvclxuICAgKiBAY2FsbGJhY2sgY29tcGFyYXRvckNhbGxiYWNrXG4gICAqIEBwYXJhbSB7S2V5fSBhXG4gICAqIEBwYXJhbSB7S2V5fSBiXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgQVZMVHJlZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7Y29tcGFyYXRvckNhbGxiYWNrfSBbY29tcGFyYXRvcl1cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICBbbm9EdXBsaWNhdGVzPWZhbHNlXSBEaXNhbGxvdyBkdXBsaWNhdGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29tcGFyYXRvciwgbm9EdXBsaWNhdGVzID0gZmFsc2UpIHtcbiAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvciB8fCBERUZBVUxUX0NPTVBBUkU7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5fbm9EdXBsaWNhdGVzID0gISFub0R1cGxpY2F0ZXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgdHJlZVxuICAgKiBAcmV0dXJuIHtBVkxUcmVlfVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGVhcigpO1xuICB9XG5cblxuICAvKipcbiAgICogQ2xlYXIgdGhlIHRyZWVcbiAgICogQHJldHVybiB7QVZMVHJlZX1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBub2Rlc1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB0cmVlIGNvbnRhaW5zIGEgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXlcbiAgICogQHBhcmFtICB7S2V5fSBrZXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZS9mYWxzZVxuICAgKi9cbiAgY29udGFpbnMgKGtleSkge1xuICAgIGlmICh0aGlzLl9yb290KSAge1xuICAgICAgdmFyIG5vZGUgICAgICAgPSB0aGlzLl9yb290O1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgICAgd2hpbGUgKG5vZGUpICB7XG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGtleSwgbm9kZS5rZXkpO1xuICAgICAgICBpZiAgICAgIChjbXAgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuXG4gIC8qKlxuICAgKiBTdWNjZXNzb3Igbm9kZVxuICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgbmV4dCAobm9kZSkge1xuICAgIHZhciBzdWNjZXNzb3IgPSBub2RlO1xuICAgIGlmIChzdWNjZXNzb3IpIHtcbiAgICAgIGlmIChzdWNjZXNzb3IucmlnaHQpIHtcbiAgICAgICAgc3VjY2Vzc29yID0gc3VjY2Vzc29yLnJpZ2h0O1xuICAgICAgICB3aGlsZSAoc3VjY2Vzc29yLmxlZnQpIHN1Y2Nlc3NvciA9IHN1Y2Nlc3Nvci5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VjY2Vzc29yID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChzdWNjZXNzb3IgJiYgc3VjY2Vzc29yLnJpZ2h0ID09PSBub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IHN1Y2Nlc3Nvcjsgc3VjY2Vzc29yID0gc3VjY2Vzc29yLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VjY2Vzc29yO1xuICB9XG5cblxuICAvKipcbiAgICogUHJlZGVjZXNzb3Igbm9kZVxuICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgcHJldiAobm9kZSkge1xuICAgIHZhciBwcmVkZWNlc3NvciA9IG5vZGU7XG4gICAgaWYgKHByZWRlY2Vzc29yKSB7XG4gICAgICBpZiAocHJlZGVjZXNzb3IubGVmdCkge1xuICAgICAgICBwcmVkZWNlc3NvciA9IHByZWRlY2Vzc29yLmxlZnQ7XG4gICAgICAgIHdoaWxlIChwcmVkZWNlc3Nvci5yaWdodCkgcHJlZGVjZXNzb3IgPSBwcmVkZWNlc3Nvci5yaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWRlY2Vzc29yID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwcmVkZWNlc3NvciAmJiBwcmVkZWNlc3Nvci5sZWZ0ID09PSBub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IHByZWRlY2Vzc29yO1xuICAgICAgICAgIHByZWRlY2Vzc29yID0gcHJlZGVjZXNzb3IucGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmVkZWNlc3NvcjtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cblxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgZm9yRWFjaFxuICAgKiBAY2FsbGJhY2sgZm9yRWFjaENhbGxiYWNrXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge2ZvckVhY2hDYWxsYmFja30gY2FsbGJhY2tcbiAgICogQHJldHVybiB7QVZMVHJlZX1cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHMgPSBbXSwgZG9uZSA9IGZhbHNlLCBpID0gMDtcblxuICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgLy8gUmVhY2ggdGhlIGxlZnQgbW9zdCBOb2RlIG9mIHRoZSBjdXJyZW50IE5vZGVcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIC8vIFBsYWNlIHBvaW50ZXIgdG8gYSB0cmVlIG5vZGUgb24gdGhlIHN0YWNrXG4gICAgICAgIC8vIGJlZm9yZSB0cmF2ZXJzaW5nIHRoZSBub2RlJ3MgbGVmdCBzdWJ0cmVlXG4gICAgICAgIHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJhY2tUcmFjayBmcm9tIHRoZSBlbXB0eSBzdWJ0cmVlIGFuZCB2aXNpdCB0aGUgTm9kZVxuICAgICAgICAvLyBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjazsgaG93ZXZlciwgaWYgdGhlIHN0YWNrIGlzXG4gICAgICAgIC8vIGVtcHR5IHlvdSBhcmUgZG9uZVxuICAgICAgICBpZiAocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IHMucG9wKCk7XG4gICAgICAgICAgY2FsbGJhY2soY3VycmVudCwgaSsrKTtcblxuICAgICAgICAgIC8vIFdlIGhhdmUgdmlzaXRlZCB0aGUgbm9kZSBhbmQgaXRzIGxlZnRcbiAgICAgICAgICAvLyBzdWJ0cmVlLiBOb3csIGl0J3MgcmlnaHQgc3VidHJlZSdzIHR1cm5cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfSBlbHNlIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdhbGsga2V5IHJhbmdlIGZyb20gYGxvd2AgdG8gYGhpZ2hgLiBTdG9wcyBpZiBgZm5gIHJldHVybnMgYSB2YWx1ZS5cbiAgICogQHBhcmFtICB7S2V5fSAgICAgIGxvd1xuICAgKiBAcGFyYW0gIHtLZXl9ICAgICAgaGlnaFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtICB7Kj99ICAgICAgIGN0eFxuICAgKiBAcmV0dXJuIHtTcGxheVRyZWV9XG4gICAqL1xuICByYW5nZShsb3csIGhpZ2gsIGZuLCBjdHgpIHtcbiAgICBjb25zdCBRID0gW107XG4gICAgY29uc3QgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgbGV0IG5vZGUgPSB0aGlzLl9yb290LCBjbXA7XG5cbiAgICB3aGlsZSAoUS5sZW5ndGggIT09IDAgfHwgbm9kZSkge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgUS5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IFEucG9wKCk7XG4gICAgICAgIGNtcCA9IGNvbXBhcmUobm9kZS5rZXksIGhpZ2gpO1xuICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmUobm9kZS5rZXksIGxvdykgPj0gMCkge1xuICAgICAgICAgIGlmIChmbi5jYWxsKGN0eCwgbm9kZSkpIHJldHVybiB0aGlzOyAvLyBzdG9wIGlmIHNtdGggaXMgcmV0dXJuZWRcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBrZXlzIGluIG9yZGVyXG4gICAqIEByZXR1cm4ge0FycmF5PEtleT59XG4gICAqL1xuICBrZXlzICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHMgPSBbXSwgciA9IFtdLCBkb25lID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gcy5wb3AoKTtcbiAgICAgICAgICByLnB1c2goY3VycmVudC5rZXkpO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyBgZGF0YWAgZmllbGRzIG9mIGFsbCBub2RlcyBpbiBvcmRlci5cbiAgICogQHJldHVybiB7QXJyYXk8VmFsdWU+fVxuICAgKi9cbiAgdmFsdWVzICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHMgPSBbXSwgciA9IFtdLCBkb25lID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gcy5wb3AoKTtcbiAgICAgICAgICByLnB1c2goY3VycmVudC5kYXRhKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfSBlbHNlIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgbm9kZSBhdCBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgYXQgKGluZGV4KSB7XG4gICAgLy8gcmVtb3ZlZCBhZnRlciBhIGNvbnNpZGVyYXRpb24sIG1vcmUgbWlzbGVhZGluZyB0aGFuIHVzZWZ1bFxuICAgIC8vIGluZGV4ID0gaW5kZXggJSB0aGlzLnNpemU7XG4gICAgLy8gaWYgKGluZGV4IDwgMCkgaW5kZXggPSB0aGlzLnNpemUgLSBpbmRleDtcblxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgcyA9IFtdLCBkb25lID0gZmFsc2UsIGkgPSAwO1xuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBzLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IHMucG9wKCk7XG4gICAgICAgICAgaWYgKGkgPT09IGluZGV4KSByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5vZGUgd2l0aCB0aGUgbWluaW11bSBrZXlcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBtaW5Ob2RlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgICB3aGlsZSAobm9kZS5sZWZ0KSBub2RlID0gbm9kZS5sZWZ0O1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyBub2RlIHdpdGggdGhlIG1heCBrZXlcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBtYXhOb2RlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgICB3aGlsZSAobm9kZS5yaWdodCkgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBNaW4ga2V5XG4gICAqIEByZXR1cm4gez9LZXl9XG4gICAqL1xuICBtaW4gKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcbiAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICAgIHdoaWxlIChub2RlLmxlZnQpIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgcmV0dXJuIG5vZGUua2V5O1xuICB9XG5cblxuICAvKipcbiAgICogTWF4IGtleVxuICAgKiBAcmV0dXJuIHs/S2V5fVxuICAgKi9cbiAgbWF4ICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgICB3aGlsZSAobm9kZS5yaWdodCkgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgcmV0dXJuIG5vZGUua2V5O1xuICB9XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZS9mYWxzZVxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuX3Jvb3Q7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBub2RlIHdpdGggc21hbGxlc3Qga2V5XG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgcG9wICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3QsIHJldHVyblZhbHVlID0gbnVsbDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgd2hpbGUgKG5vZGUubGVmdCkgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgIHJldHVyblZhbHVlID0geyBrZXk6IG5vZGUua2V5LCBkYXRhOiBub2RlLmRhdGEgfTtcbiAgICAgIHRoaXMucmVtb3ZlKG5vZGUua2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cblxuICAvKipcbiAgICogRmluZCBub2RlIGJ5IGtleVxuICAgKiBAcGFyYW0gIHtLZXl9IGtleVxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIGZpbmQgKGtleSkge1xuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICAvLyBpZiAocm9vdCA9PT0gbnVsbCkgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gaWYgKGtleSA9PT0gcm9vdC5rZXkpIHJldHVybiByb290O1xuXG4gICAgdmFyIHN1YnRyZWUgPSByb290LCBjbXA7XG4gICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgIHdoaWxlIChzdWJ0cmVlKSB7XG4gICAgICBjbXAgPSBjb21wYXJlKGtleSwgc3VidHJlZS5rZXkpO1xuICAgICAgaWYgICAgICAoY21wID09PSAwKSByZXR1cm4gc3VidHJlZTtcbiAgICAgIGVsc2UgaWYgKGNtcCA8IDApICAgc3VidHJlZSA9IHN1YnRyZWUubGVmdDtcbiAgICAgIGVsc2UgICAgICAgICAgICAgICAgc3VidHJlZSA9IHN1YnRyZWUucmlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBub2RlIGludG8gdGhlIHRyZWVcbiAgICogQHBhcmFtICB7S2V5fSBrZXlcbiAgICogQHBhcmFtICB7VmFsdWV9IFtkYXRhXVxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIGluc2VydCAoa2V5LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLl9yb290KSB7XG4gICAgICB0aGlzLl9yb290ID0ge1xuICAgICAgICBwYXJlbnQ6IG51bGwsIGxlZnQ6IG51bGwsIHJpZ2h0OiBudWxsLCBiYWxhbmNlRmFjdG9yOiAwLFxuICAgICAgICBrZXksIGRhdGFcbiAgICAgIH07XG4gICAgICB0aGlzLl9zaXplKys7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICB9XG5cbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgdmFyIG5vZGUgICAgPSB0aGlzLl9yb290O1xuICAgIHZhciBwYXJlbnQgID0gbnVsbDtcbiAgICB2YXIgY21wICAgICA9IDA7XG5cbiAgICBpZiAodGhpcy5fbm9EdXBsaWNhdGVzKSB7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjbXAgPSBjb21wYXJlKGtleSwgbm9kZS5rZXkpO1xuICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICBpZiAgICAgIChjbXAgPT09IDApIHJldHVybiBudWxsO1xuICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGNtcCA9IGNvbXBhcmUoa2V5LCBub2RlLmtleSk7XG4gICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgIGlmICAgICAgKGNtcCA8PSAwKSAgbm9kZSA9IG5vZGUubGVmdDsgLy9yZXR1cm4gbnVsbDtcbiAgICAgICAgZWxzZSAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Tm9kZSA9IHtcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICByaWdodDogbnVsbCxcbiAgICAgIGJhbGFuY2VGYWN0b3I6IDAsXG4gICAgICBwYXJlbnQsIGtleSwgZGF0YVxuICAgIH07XG4gICAgdmFyIG5ld1Jvb3Q7XG4gICAgaWYgKGNtcCA8PSAwKSBwYXJlbnQubGVmdCAgPSBuZXdOb2RlO1xuICAgIGVsc2UgICAgICAgICBwYXJlbnQucmlnaHQgPSBuZXdOb2RlO1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgY21wID0gY29tcGFyZShwYXJlbnQua2V5LCBrZXkpO1xuICAgICAgaWYgKGNtcCA8IDApIHBhcmVudC5iYWxhbmNlRmFjdG9yIC09IDE7XG4gICAgICBlbHNlICAgICAgICAgcGFyZW50LmJhbGFuY2VGYWN0b3IgKz0gMTtcblxuICAgICAgaWYgICAgICAgIChwYXJlbnQuYmFsYW5jZUZhY3RvciA9PT0gMCkgYnJlYWs7XG4gICAgICBlbHNlIGlmICAgKHBhcmVudC5iYWxhbmNlRmFjdG9yIDwgLTEpIHtcbiAgICAgICAgLy8gaW5saW5lZFxuICAgICAgICAvL3ZhciBuZXdSb290ID0gcmlnaHRCYWxhbmNlKHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnQucmlnaHQuYmFsYW5jZUZhY3RvciA9PT0gMSkgcm90YXRlUmlnaHQocGFyZW50LnJpZ2h0KTtcbiAgICAgICAgbmV3Um9vdCA9IHJvdGF0ZUxlZnQocGFyZW50KTtcblxuICAgICAgICBpZiAocGFyZW50ID09PSB0aGlzLl9yb290KSB0aGlzLl9yb290ID0gbmV3Um9vdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5iYWxhbmNlRmFjdG9yID4gMSkge1xuICAgICAgICAvLyBpbmxpbmVkXG4gICAgICAgIC8vIHZhciBuZXdSb290ID0gbGVmdEJhbGFuY2UocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudC5sZWZ0LmJhbGFuY2VGYWN0b3IgPT09IC0xKSByb3RhdGVMZWZ0KHBhcmVudC5sZWZ0KTtcbiAgICAgICAgbmV3Um9vdCA9IHJvdGF0ZVJpZ2h0KHBhcmVudCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcy5fcm9vdCkgdGhpcy5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICB0aGlzLl9zaXplKys7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBub2RlIGZyb20gdGhlIHRyZWUuIElmIG5vdCBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgKiBAcGFyYW0gIHtLZXl9IGtleVxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIHJlbW92ZSAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLl9yb290KSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgdmFyIGNtcCA9IDA7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgY21wID0gY29tcGFyZShrZXksIG5vZGUua2V5KTtcbiAgICAgIGlmICAgICAgKGNtcCA9PT0gMCkgYnJlYWs7XG4gICAgICBlbHNlIGlmIChjbXAgPCAwKSAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICBlbHNlICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgIH1cbiAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHJldHVyblZhbHVlID0gbm9kZS5rZXk7XG4gICAgdmFyIG1heCwgbWluO1xuXG4gICAgaWYgKG5vZGUubGVmdCkge1xuICAgICAgbWF4ID0gbm9kZS5sZWZ0O1xuXG4gICAgICB3aGlsZSAobWF4LmxlZnQgfHwgbWF4LnJpZ2h0KSB7XG4gICAgICAgIHdoaWxlIChtYXgucmlnaHQpIG1heCA9IG1heC5yaWdodDtcblxuICAgICAgICBub2RlLmtleSA9IG1heC5rZXk7XG4gICAgICAgIG5vZGUuZGF0YSA9IG1heC5kYXRhO1xuICAgICAgICBpZiAobWF4LmxlZnQpIHtcbiAgICAgICAgICBub2RlID0gbWF4O1xuICAgICAgICAgIG1heCA9IG1heC5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUua2V5ICA9IG1heC5rZXk7XG4gICAgICBub2RlLmRhdGEgPSBtYXguZGF0YTtcbiAgICAgIG5vZGUgPSBtYXg7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUucmlnaHQpIHtcbiAgICAgIG1pbiA9IG5vZGUucmlnaHQ7XG5cbiAgICAgIHdoaWxlIChtaW4ubGVmdCB8fCBtaW4ucmlnaHQpIHtcbiAgICAgICAgd2hpbGUgKG1pbi5sZWZ0KSBtaW4gPSBtaW4ubGVmdDtcblxuICAgICAgICBub2RlLmtleSAgPSBtaW4ua2V5O1xuICAgICAgICBub2RlLmRhdGEgPSBtaW4uZGF0YTtcbiAgICAgICAgaWYgKG1pbi5yaWdodCkge1xuICAgICAgICAgIG5vZGUgPSBtaW47XG4gICAgICAgICAgbWluID0gbWluLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUua2V5ICA9IG1pbi5rZXk7XG4gICAgICBub2RlLmRhdGEgPSBtaW4uZGF0YTtcbiAgICAgIG5vZGUgPSBtaW47XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIHZhciBwcCAgICAgPSBub2RlO1xuICAgIHZhciBuZXdSb290O1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5sZWZ0ID09PSBwcCkgcGFyZW50LmJhbGFuY2VGYWN0b3IgLT0gMTtcbiAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgIHBhcmVudC5iYWxhbmNlRmFjdG9yICs9IDE7XG5cbiAgICAgIGlmICAgICAgICAocGFyZW50LmJhbGFuY2VGYWN0b3IgPCAtMSkge1xuICAgICAgICAvLyBpbmxpbmVkXG4gICAgICAgIC8vdmFyIG5ld1Jvb3QgPSByaWdodEJhbGFuY2UocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudC5yaWdodC5iYWxhbmNlRmFjdG9yID09PSAxKSByb3RhdGVSaWdodChwYXJlbnQucmlnaHQpO1xuICAgICAgICBuZXdSb290ID0gcm90YXRlTGVmdChwYXJlbnQpO1xuXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMuX3Jvb3QpIHRoaXMuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgICBwYXJlbnQgPSBuZXdSb290O1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnQuYmFsYW5jZUZhY3RvciA+IDEpIHtcbiAgICAgICAgLy8gaW5saW5lZFxuICAgICAgICAvLyB2YXIgbmV3Um9vdCA9IGxlZnRCYWxhbmNlKHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnQubGVmdC5iYWxhbmNlRmFjdG9yID09PSAtMSkgcm90YXRlTGVmdChwYXJlbnQubGVmdCk7XG4gICAgICAgIG5ld1Jvb3QgPSByb3RhdGVSaWdodChwYXJlbnQpO1xuXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMuX3Jvb3QpIHRoaXMuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgICBwYXJlbnQgPSBuZXdSb290O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50LmJhbGFuY2VGYWN0b3IgPT09IC0xIHx8IHBhcmVudC5iYWxhbmNlRmFjdG9yID09PSAxKSBicmVhaztcblxuICAgICAgcHAgICAgID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgIGlmIChub2RlLnBhcmVudC5sZWZ0ID09PSBub2RlKSBub2RlLnBhcmVudC5sZWZ0ICA9IG51bGw7XG4gICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQucmlnaHQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB0aGlzLl9yb290KSB0aGlzLl9yb290ID0gbnVsbDtcblxuICAgIHRoaXMuX3NpemUtLTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBCdWxrLWxvYWQgaXRlbXNcbiAgICogQHBhcmFtICB7QXJyYXk8S2V5Pn0gIGtleXNcbiAgICogQHBhcmFtICB7QXJyYXk8VmFsdWU+fSAgW3ZhbHVlc11cbiAgICogQHJldHVybiB7QVZMVHJlZX1cbiAgICovXG4gIGxvYWQoa2V5cyA9IFtdLCB2YWx1ZXMgPSBbXSwgcHJlc29ydCkge1xuICAgIGlmICh0aGlzLl9zaXplICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2J1bGstbG9hZDogdHJlZSBpcyBub3QgZW1wdHknKTtcbiAgICBjb25zdCBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKHByZXNvcnQpIHNvcnQoa2V5cywgdmFsdWVzLCAwLCBzaXplIC0gMSwgdGhpcy5fY29tcGFyYXRvcik7XG4gICAgdGhpcy5fcm9vdCA9IGxvYWRSZWN1cnNpdmUobnVsbCwga2V5cywgdmFsdWVzLCAwLCBzaXplKTtcbiAgICBtYXJrQmFsYW5jZSh0aGlzLl9yb290KTtcbiAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJlZSBpcyBiYWxhbmNlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNCYWxhbmNlZCgpIHtcbiAgICByZXR1cm4gaXNCYWxhbmNlZCh0aGlzLl9yb290KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJlZSAtIHByaW1pdGl2ZSBob3Jpem9udGFsIHByaW50LW91dFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbihOb2RlKTpzdHJpbmd9IFtwcmludE5vZGVdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nIChwcmludE5vZGUpIHtcbiAgICByZXR1cm4gcHJpbnQodGhpcy5fcm9vdCwgcHJpbnROb2RlKTtcbiAgfVxufVxuXG5BVkxUcmVlLmRlZmF1bHQgPSBBVkxUcmVlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/avl/src/index.js\n");

/***/ }),

/***/ "./node_modules/avl/src/utils.js":
/*!***************************************!*\
  !*** ./node_modules/avl/src/utils.js ***!
  \***************************************/
/*! exports provided: print, isBalanced, loadRecursive, markBalance, sort */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"print\", function() { return print; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBalanced\", function() { return isBalanced; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRecursive\", function() { return loadRecursive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"markBalance\", function() { return markBalance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sort\", function() { return sort; });\n\n/**\n * Prints tree horizontally\n * @param  {Node}                       root\n * @param  {Function(node:Node):String} [printNode]\n * @return {String}\n */\nfunction print (root, printNode = (n) => n.key) {\n  var out = [];\n  row(root, '', true, (v) => out.push(v), printNode);\n  return out.join('');\n}\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Function(in:string):void}    out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction row (root, prefix, isTail, out, printNode) {\n  if (root) {\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\n`);\n    const indent = prefix + (isTail ? '    ' : '│   ');\n    if (root.left)  row(root.left,  indent, false, out, printNode);\n    if (root.right) row(root.right, indent, true,  out, printNode);\n  }\n}\n\n\n/**\n * Is the tree balanced (none of the subtrees differ in height by more than 1)\n * @param  {Node}    root\n * @return {Boolean}\n */\nfunction isBalanced(root) {\n  if (root === null) return true; // If node is empty then return true\n\n  // Get the height of left and right sub trees\n  var lh = height(root.left);\n  var rh = height(root.right);\n\n  if (Math.abs(lh - rh) <= 1 &&\n      isBalanced(root.left)  &&\n      isBalanced(root.right)) return true;\n\n  // If we reach here then tree is not height-balanced\n  return false;\n}\n\n/**\n * The function Compute the 'height' of a tree.\n * Height is the number of nodes along the longest path\n * from the root node down to the farthest leaf node.\n *\n * @param  {Node} node\n * @return {Number}\n */\nfunction height(node) {\n  return node ? (1 + Math.max(height(node.left), height(node.right))) : 0;\n}\n\n\nfunction loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nfunction markBalance(node) {\n  if (node === null) return 0;\n  const lh = markBalance(node.left);\n  const rh = markBalance(node.right);\n\n  node.balanceFactor = lh - rh;\n  return Math.max(lh, rh) + 1;\n}\n\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  // eslint-disable-next-line no-bitwise\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXZsL3NyYy91dGlscy5qcz83MjA2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksMkJBQTJCO0FBQ3ZDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUyxFQUFFLDJCQUEyQixFQUFFLGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVk7QUFDWjtBQUNPO0FBQ1AsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXZsL3NyYy91dGlscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBQcmludHMgdHJlZSBob3Jpem9udGFsbHlcbiAqIEBwYXJhbSAge05vZGV9ICAgICAgICAgICAgICAgICAgICAgICByb290XG4gKiBAcGFyYW0gIHtGdW5jdGlvbihub2RlOk5vZGUpOlN0cmluZ30gW3ByaW50Tm9kZV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50IChyb290LCBwcmludE5vZGUgPSAobikgPT4gbi5rZXkpIHtcbiAgdmFyIG91dCA9IFtdO1xuICByb3cocm9vdCwgJycsIHRydWUsICh2KSA9PiBvdXQucHVzaCh2KSwgcHJpbnROb2RlKTtcbiAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBQcmludHMgbGV2ZWwgb2YgdGhlIHRyZWVcbiAqIEBwYXJhbSAge05vZGV9ICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICBwcmVmaXhcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgaXNUYWlsXG4gKiBAcGFyYW0gIHtGdW5jdGlvbihpbjpzdHJpbmcpOnZvaWR9ICAgIG91dFxuICogQHBhcmFtICB7RnVuY3Rpb24obm9kZTpOb2RlKTpTdHJpbmd9ICBwcmludE5vZGVcbiAqL1xuZnVuY3Rpb24gcm93IChyb290LCBwcmVmaXgsIGlzVGFpbCwgb3V0LCBwcmludE5vZGUpIHtcbiAgaWYgKHJvb3QpIHtcbiAgICBvdXQoYCR7IHByZWZpeCB9JHsgaXNUYWlsID8gJ+KUlOKUgOKUgCAnIDogJ+KUnOKUgOKUgCAnIH0keyBwcmludE5vZGUocm9vdCkgfVxcbmApO1xuICAgIGNvbnN0IGluZGVudCA9IHByZWZpeCArIChpc1RhaWwgPyAnICAgICcgOiAn4pSCICAgJyk7XG4gICAgaWYgKHJvb3QubGVmdCkgIHJvdyhyb290LmxlZnQsICBpbmRlbnQsIGZhbHNlLCBvdXQsIHByaW50Tm9kZSk7XG4gICAgaWYgKHJvb3QucmlnaHQpIHJvdyhyb290LnJpZ2h0LCBpbmRlbnQsIHRydWUsICBvdXQsIHByaW50Tm9kZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIElzIHRoZSB0cmVlIGJhbGFuY2VkIChub25lIG9mIHRoZSBzdWJ0cmVlcyBkaWZmZXIgaW4gaGVpZ2h0IGJ5IG1vcmUgdGhhbiAxKVxuICogQHBhcmFtICB7Tm9kZX0gICAgcm9vdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmFsYW5jZWQocm9vdCkge1xuICBpZiAocm9vdCA9PT0gbnVsbCkgcmV0dXJuIHRydWU7IC8vIElmIG5vZGUgaXMgZW1wdHkgdGhlbiByZXR1cm4gdHJ1ZVxuXG4gIC8vIEdldCB0aGUgaGVpZ2h0IG9mIGxlZnQgYW5kIHJpZ2h0IHN1YiB0cmVlc1xuICB2YXIgbGggPSBoZWlnaHQocm9vdC5sZWZ0KTtcbiAgdmFyIHJoID0gaGVpZ2h0KHJvb3QucmlnaHQpO1xuXG4gIGlmIChNYXRoLmFicyhsaCAtIHJoKSA8PSAxICYmXG4gICAgICBpc0JhbGFuY2VkKHJvb3QubGVmdCkgICYmXG4gICAgICBpc0JhbGFuY2VkKHJvb3QucmlnaHQpKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBJZiB3ZSByZWFjaCBoZXJlIHRoZW4gdHJlZSBpcyBub3QgaGVpZ2h0LWJhbGFuY2VkXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gQ29tcHV0ZSB0aGUgJ2hlaWdodCcgb2YgYSB0cmVlLlxuICogSGVpZ2h0IGlzIHRoZSBudW1iZXIgb2Ygbm9kZXMgYWxvbmcgdGhlIGxvbmdlc3QgcGF0aFxuICogZnJvbSB0aGUgcm9vdCBub2RlIGRvd24gdG8gdGhlIGZhcnRoZXN0IGxlYWYgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGhlaWdodChub2RlKSB7XG4gIHJldHVybiBub2RlID8gKDEgKyBNYXRoLm1heChoZWlnaHQobm9kZS5sZWZ0KSwgaGVpZ2h0KG5vZGUucmlnaHQpKSkgOiAwO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUmVjdXJzaXZlIChwYXJlbnQsIGtleXMsIHZhbHVlcywgc3RhcnQsIGVuZCkge1xuICBjb25zdCBzaXplID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChzaXplID4gMCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgTWF0aC5mbG9vcihzaXplIC8gMik7XG4gICAgY29uc3Qga2V5ICAgID0ga2V5c1ttaWRkbGVdO1xuICAgIGNvbnN0IGRhdGEgICA9IHZhbHVlc1ttaWRkbGVdO1xuICAgIGNvbnN0IG5vZGUgICA9IHsga2V5LCBkYXRhLCBwYXJlbnQgfTtcbiAgICBub2RlLmxlZnQgICAgPSBsb2FkUmVjdXJzaXZlKG5vZGUsIGtleXMsIHZhbHVlcywgc3RhcnQsIG1pZGRsZSk7XG4gICAgbm9kZS5yaWdodCAgID0gbG9hZFJlY3Vyc2l2ZShub2RlLCBrZXlzLCB2YWx1ZXMsIG1pZGRsZSArIDEsIGVuZCk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtCYWxhbmNlKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IG51bGwpIHJldHVybiAwO1xuICBjb25zdCBsaCA9IG1hcmtCYWxhbmNlKG5vZGUubGVmdCk7XG4gIGNvbnN0IHJoID0gbWFya0JhbGFuY2Uobm9kZS5yaWdodCk7XG5cbiAgbm9kZS5iYWxhbmNlRmFjdG9yID0gbGggLSByaDtcbiAgcmV0dXJuIE1hdGgubWF4KGxoLCByaCkgKyAxO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0KGtleXMsIHZhbHVlcywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcbiAgaWYgKGxlZnQgPj0gcmlnaHQpIHJldHVybjtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICBjb25zdCBwaXZvdCA9IGtleXNbKGxlZnQgKyByaWdodCkgPj4gMV07XG4gIGxldCBpID0gbGVmdCAtIDE7XG4gIGxldCBqID0gcmlnaHQgKyAxO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBkbyBpKys7IHdoaWxlIChjb21wYXJlKGtleXNbaV0sIHBpdm90KSA8IDApO1xuICAgIGRvIGotLTsgd2hpbGUgKGNvbXBhcmUoa2V5c1tqXSwgcGl2b3QpID4gMCk7XG4gICAgaWYgKGkgPj0gaikgYnJlYWs7XG5cbiAgICBsZXQgdG1wID0ga2V5c1tpXTtcbiAgICBrZXlzW2ldID0ga2V5c1tqXTtcbiAgICBrZXlzW2pdID0gdG1wO1xuXG4gICAgdG1wID0gdmFsdWVzW2ldO1xuICAgIHZhbHVlc1tpXSA9IHZhbHVlc1tqXTtcbiAgICB2YWx1ZXNbal0gPSB0bXA7XG4gIH1cblxuICBzb3J0KGtleXMsIHZhbHVlcywgIGxlZnQsICAgICBqLCBjb21wYXJlKTtcbiAgc29ydChrZXlzLCB2YWx1ZXMsIGogKyAxLCByaWdodCwgY29tcGFyZSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/avl/src/utils.js\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./src/puzzle-solver.worker.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--5!./src/puzzle-solver.worker.js ***!
  \*****************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sliding_puzzle_algorithms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sliding-puzzle-algorithms */ \"./src/sliding-puzzle-algorithms.js\");\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n\n\nonmessage = function onmessage(e) {\n  var puzzle = _construct(_sliding_puzzle_algorithms__WEBPACK_IMPORTED_MODULE_0__[\"default\"], _toConsumableArray(e.data));\n\n  postMessage(puzzle.solve());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHV6emxlLXNvbHZlci53b3JrZXIuanM/YTZmZiJdLCJuYW1lcyI6WyJvbm1lc3NhZ2UiLCJlIiwicHV6emxlIiwiUHV6emxlIiwiZGF0YSIsInBvc3RNZXNzYWdlIiwic29sdmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQUEsU0FBUyxHQUFHLG1CQUFBQyxDQUFDLEVBQUk7QUFDaEIsTUFBSUMsTUFBTSxjQUFPQyxrRUFBUCxxQkFBaUJGLENBQUMsQ0FBQ0csSUFBbkIsRUFBVjs7QUFDQUMsYUFBVyxDQUFDSCxNQUFNLENBQUNJLEtBQVAsRUFBRCxDQUFYO0FBQ0EsQ0FIRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3NyYy9wdXp6bGUtc29sdmVyLndvcmtlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQdXp6bGUgZnJvbSAnLi9zbGlkaW5nLXB1enpsZS1hbGdvcml0aG1zJ1xuXG5vbm1lc3NhZ2UgPSBlID0+IHtcblx0bGV0IHB1enpsZSA9IG5ldyBQdXp6bGUoLi4uZS5kYXRhKTtcblx0cG9zdE1lc3NhZ2UocHV6emxlLnNvbHZlKCkpO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js?!./src/puzzle-solver.worker.js\n");

/***/ }),

/***/ "./node_modules/fastpriorityqueue/FastPriorityQueue.js":
/*!*************************************************************!*\
  !*** ./node_modules/fastpriorityqueue/FastPriorityQueue.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {/**\n * FastPriorityQueue.js : a fast heap-based priority queue  in JavaScript.\n * (c) the authors\n * Licensed under the Apache License, Version 2.0.\n *\n * Speed-optimized heap-based priority queue for modern browsers and JavaScript engines.\n *\n * Usage :\n         Installation (in shell, if you use node):\n         $ npm install fastpriorityqueue\n\n         Running test program (in JavaScript):\n\n         // var FastPriorityQueue = require(\"fastpriorityqueue\");// in node\n         var x = new FastPriorityQueue();\n         x.add(1);\n         x.add(0);\n         x.add(5);\n         x.add(4);\n         x.add(3);\n         x.peek(); // should return 0, leaves x unchanged\n         x.size; // should return 5, leaves x unchanged\n         while(!x.isEmpty()) {\n           console.log(x.poll());\n         } // will print 0 1 3 4 5\n         x.trim(); // (optional) optimizes memory usage\n */\n\n\nvar defaultcomparator = function(a, b) {\n  return a < b;\n};\n\n// the provided comparator function should take a, b and return *true* when a < b\nfunction FastPriorityQueue(comparator) {\n  if (!(this instanceof FastPriorityQueue)) return new FastPriorityQueue(comparator);\n  this.array = [];\n  this.size = 0;\n  this.compare = comparator || defaultcomparator;\n}\n\n// copy the priority queue into another, and return it. Queue items are shallow-copied.\n// Runs in `O(n)` time.\nFastPriorityQueue.prototype.clone = function() {\n  var fpq = new FastPriorityQueue(this.compare);\n  fpq.size = this.size;\n  for (var i = 0; i < this.size; i++) {\n    fpq.array.push(this.array[i]);\n  }\n  return fpq;\n};\n\n// Add an element into the queue\n// runs in O(log n) time\nFastPriorityQueue.prototype.add = function(myval) {\n  var i = this.size;\n  this.array[this.size] = myval;\n  this.size += 1;\n  var p;\n  var ap;\n  while (i > 0) {\n    p = (i - 1) >> 1;\n    ap = this.array[p];\n    if (!this.compare(myval, ap)) {\n      break;\n    }\n    this.array[i] = ap;\n    i = p;\n  }\n  this.array[i] = myval;\n};\n\n// replace the content of the heap by provided array and \"heapify it\"\nFastPriorityQueue.prototype.heapify = function(arr) {\n  this.array = arr;\n  this.size = arr.length;\n  var i;\n  for (i = this.size >> 1; i >= 0; i--) {\n    this._percolateDown(i);\n  }\n};\n\n// for internal use\nFastPriorityQueue.prototype._percolateUp = function(i, force) {\n  var myval = this.array[i];\n  var p;\n  var ap;\n  while (i > 0) {\n    p = (i - 1) >> 1;\n    ap = this.array[p];\n    // force will skip the compare\n    if (!force && !this.compare(myval, ap)) {\n      break;\n    }\n    this.array[i] = ap;\n    i = p;\n  }\n  this.array[i] = myval;\n};\n\n// for internal use\nFastPriorityQueue.prototype._percolateDown = function(i) {\n  var size = this.size;\n  var hsize = this.size >>> 1;\n  var ai = this.array[i];\n  var l;\n  var r;\n  var bestc;\n  while (i < hsize) {\n    l = (i << 1) + 1;\n    r = l + 1;\n    bestc = this.array[l];\n    if (r < size) {\n      if (this.compare(this.array[r], bestc)) {\n        l = r;\n        bestc = this.array[r];\n      }\n    }\n    if (!this.compare(bestc, ai)) {\n      break;\n    }\n    this.array[i] = bestc;\n    i = l;\n  }\n  this.array[i] = ai;\n};\n\n// internal\n// _removeAt(index) will remove the item at the given index from the queue,\n// retaining balance. returns the removed item, or undefined if nothing is removed.\nFastPriorityQueue.prototype._removeAt = function(index) {\n  if (index > this.size - 1 || index < 0) return undefined;\n\n  // impl1:\n  //this.array.splice(index, 1);\n  //this.heapify(this.array);\n  // impl2:\n  this._percolateUp(index, true);\n  return this.poll();\n};\n\n// remove(myval) will remove an item matching the provided value from the\n// queue, checked for equality by using the queue's comparator.\n// return true if removed, false otherwise.\nFastPriorityQueue.prototype.remove = function(myval) {\n  for (var i = 0; i < this.size; i++) {\n    if (!this.compare(this.array[i], myval) && !this.compare(myval, this.array[i])) {\n      // items match, comparator returns false both ways, remove item\n      this._removeAt(i);\n      return true;\n    }\n  }\n  return false;\n};\n\n// internal\n// removes and returns items for which the callback returns true.\nFastPriorityQueue.prototype._batchRemove = function(callback, limit) {\n  // initialize return array with max size of the limit or current queue size\n  var retArr = new Array(limit ? limit : this.size);\n  var count = 0;\n\n  if (typeof callback === 'function' && this.size) {\n    var i = 0;\n    while (i < this.size && count < retArr.length) {\n      if (callback(this.array[i])) {\n        retArr[count] = this._removeAt(i);\n        count++;\n        // move up a level in the heap if we remove an item\n        i = i >> 1;\n      } else {\n        i++;\n      }\n    } \n  }\n  retArr.length = count;\n  return retArr;\n}\n\n// removeOne(callback) will execute the callback function for each item of the queue\n// and will remove the first item for which the callback will return true.\n// return the removed item, or undefined if nothing is removed.\nFastPriorityQueue.prototype.removeOne = function(callback) {\n  var arr = this._batchRemove(callback, 1);\n  return arr.length > 0 ? arr[0] : undefined;\n};\n\n// remove(callback[, limit]) will execute the callback function for each item of\n// the queue and will remove each item for which the callback returns true, up to\n// a max limit of removed items if specified or no limit if unspecified.\n// return an array containing the removed items.\nFastPriorityQueue.prototype.removeMany = function(callback, limit) {\n  return this._batchRemove(callback, limit);\n};\n\n// Look at the top of the queue (one of the smallest elements) without removing it\n// executes in constant time\n//\n// Calling peek on an empty priority queue returns\n// the \"undefined\" value.\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined\n//\nFastPriorityQueue.prototype.peek = function() {\n  if (this.size == 0) return undefined;\n  return this.array[0];\n};\n\n// remove the element on top of the heap (one of the smallest elements)\n// runs in logarithmic time\n//\n// If the priority queue is empty, the function returns the\n// \"undefined\" value.\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined\n//\n// For long-running and large priority queues, or priority queues\n// storing large objects, you may  want to call the trim function\n// at strategic times to recover allocated memory.\nFastPriorityQueue.prototype.poll = function() {\n  if (this.size == 0) return undefined;\n  var ans = this.array[0];\n  if (this.size > 1) {\n    this.array[0] = this.array[--this.size];\n    this._percolateDown(0);\n  } else {\n    this.size -= 1;\n  }\n  return ans;\n};\n\n// This function adds the provided value to the heap, while removing\n// and returning one of the smallest elements (like poll). The size of the queue\n// thus remains unchanged.\nFastPriorityQueue.prototype.replaceTop = function(myval) {\n  if (this.size == 0) return undefined;\n  var ans = this.array[0];\n  this.array[0] = myval;\n  this._percolateDown(0);\n  return ans;\n};\n\n// recover unused memory (for long-running priority queues)\nFastPriorityQueue.prototype.trim = function() {\n  this.array = this.array.slice(0, this.size);\n};\n\n// Check whether the heap is empty\nFastPriorityQueue.prototype.isEmpty = function() {\n  return this.size === 0;\n};\n\n// iterate over the items in order, pass a callback that receives (item, index) as args.\n// TODO once we transpile, uncomment\n// if (Symbol && Symbol.iterator) {\n//   FastPriorityQueue.prototype[Symbol.iterator] = function*() {\n//     if (this.isEmpty()) return;\n//     var fpq = this.clone();\n//     while (!fpq.isEmpty()) {\n//       yield fpq.poll();\n//     }\n//   };\n// }\nFastPriorityQueue.prototype.forEach = function(callback) {\n  if (this.isEmpty() || typeof callback != 'function') return;\n  var i = 0;\n  var fpq = this.clone();\n  while (!fpq.isEmpty()) {\n    callback(fpq.poll(), i++);\n  }\n};\n\n// return the k 'smallest' elements of the queue\n// runs in O(k log k) time\n// this is the equivalent of repeatedly calling poll, but\n// it has a better computational complexity, which can be\n// important for large data sets.\nFastPriorityQueue.prototype.kSmallest = function(k) {\n  if (this.size == 0) return [];\n  var comparator = this.compare;\n  var arr = this.array\n  var fpq = new FastPriorityQueue(function(a,b){\n   return comparator(arr[a],arr[b]);\n  });\n  k = Math.min(this.size, k);\n  var smallest = new Array(k);\n  var j = 0;\n  fpq.add(0);\n  while (j < k) {\n    var small = fpq.poll();\n    smallest[j++] = this.array[small];\n    var l = (small << 1) + 1;\n    var r = l + 1;\n    if (l < this.size) fpq.add(l);\n    if (r < this.size) fpq.add(r);\n  }\n  return smallest;\n}\n\n// just for illustration purposes\nvar main = function() {\n  // main code\n  var x = new FastPriorityQueue(function(a, b) {\n    return a < b;\n  });\n  x.add(1);\n  x.add(0);\n  x.add(5);\n  x.add(4);\n  x.add(3);\n  while (!x.isEmpty()) {\n    console.log(x.poll());\n  }\n};\n\nif (__webpack_require__.c[__webpack_require__.s] === module) {\n  main();\n}\n\nmodule.exports = FastPriorityQueue;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmFzdHByaW9yaXR5cXVldWUvRmFzdFByaW9yaXR5UXVldWUuanM/ZDkzMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtCQUFrQjtBQUNsQjtBQUNhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDRDQUFZO0FBQ2hCO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdHByaW9yaXR5cXVldWUvRmFzdFByaW9yaXR5UXVldWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZhc3RQcmlvcml0eVF1ZXVlLmpzIDogYSBmYXN0IGhlYXAtYmFzZWQgcHJpb3JpdHkgcXVldWUgIGluIEphdmFTY3JpcHQuXG4gKiAoYykgdGhlIGF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuXG4gKlxuICogU3BlZWQtb3B0aW1pemVkIGhlYXAtYmFzZWQgcHJpb3JpdHkgcXVldWUgZm9yIG1vZGVybiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICpcbiAqIFVzYWdlIDpcbiAgICAgICAgIEluc3RhbGxhdGlvbiAoaW4gc2hlbGwsIGlmIHlvdSB1c2Ugbm9kZSk6XG4gICAgICAgICAkIG5wbSBpbnN0YWxsIGZhc3Rwcmlvcml0eXF1ZXVlXG5cbiAgICAgICAgIFJ1bm5pbmcgdGVzdCBwcm9ncmFtIChpbiBKYXZhU2NyaXB0KTpcblxuICAgICAgICAgLy8gdmFyIEZhc3RQcmlvcml0eVF1ZXVlID0gcmVxdWlyZShcImZhc3Rwcmlvcml0eXF1ZXVlXCIpOy8vIGluIG5vZGVcbiAgICAgICAgIHZhciB4ID0gbmV3IEZhc3RQcmlvcml0eVF1ZXVlKCk7XG4gICAgICAgICB4LmFkZCgxKTtcbiAgICAgICAgIHguYWRkKDApO1xuICAgICAgICAgeC5hZGQoNSk7XG4gICAgICAgICB4LmFkZCg0KTtcbiAgICAgICAgIHguYWRkKDMpO1xuICAgICAgICAgeC5wZWVrKCk7IC8vIHNob3VsZCByZXR1cm4gMCwgbGVhdmVzIHggdW5jaGFuZ2VkXG4gICAgICAgICB4LnNpemU7IC8vIHNob3VsZCByZXR1cm4gNSwgbGVhdmVzIHggdW5jaGFuZ2VkXG4gICAgICAgICB3aGlsZSgheC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgY29uc29sZS5sb2coeC5wb2xsKCkpO1xuICAgICAgICAgfSAvLyB3aWxsIHByaW50IDAgMSAzIDQgNVxuICAgICAgICAgeC50cmltKCk7IC8vIChvcHRpb25hbCkgb3B0aW1pemVzIG1lbW9yeSB1c2FnZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0Y29tcGFyYXRvciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiO1xufTtcblxuLy8gdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IgZnVuY3Rpb24gc2hvdWxkIHRha2UgYSwgYiBhbmQgcmV0dXJuICp0cnVlKiB3aGVuIGEgPCBiXG5mdW5jdGlvbiBGYXN0UHJpb3JpdHlRdWV1ZShjb21wYXJhdG9yKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGYXN0UHJpb3JpdHlRdWV1ZSkpIHJldHVybiBuZXcgRmFzdFByaW9yaXR5UXVldWUoY29tcGFyYXRvcik7XG4gIHRoaXMuYXJyYXkgPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5jb21wYXJlID0gY29tcGFyYXRvciB8fCBkZWZhdWx0Y29tcGFyYXRvcjtcbn1cblxuLy8gY29weSB0aGUgcHJpb3JpdHkgcXVldWUgaW50byBhbm90aGVyLCBhbmQgcmV0dXJuIGl0LiBRdWV1ZSBpdGVtcyBhcmUgc2hhbGxvdy1jb3BpZWQuXG4vLyBSdW5zIGluIGBPKG4pYCB0aW1lLlxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmcHEgPSBuZXcgRmFzdFByaW9yaXR5UXVldWUodGhpcy5jb21wYXJlKTtcbiAgZnBxLnNpemUgPSB0aGlzLnNpemU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICBmcHEuYXJyYXkucHVzaCh0aGlzLmFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gZnBxO1xufTtcblxuLy8gQWRkIGFuIGVsZW1lbnQgaW50byB0aGUgcXVldWVcbi8vIHJ1bnMgaW4gTyhsb2cgbikgdGltZVxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG15dmFsKSB7XG4gIHZhciBpID0gdGhpcy5zaXplO1xuICB0aGlzLmFycmF5W3RoaXMuc2l6ZV0gPSBteXZhbDtcbiAgdGhpcy5zaXplICs9IDE7XG4gIHZhciBwO1xuICB2YXIgYXA7XG4gIHdoaWxlIChpID4gMCkge1xuICAgIHAgPSAoaSAtIDEpID4+IDE7XG4gICAgYXAgPSB0aGlzLmFycmF5W3BdO1xuICAgIGlmICghdGhpcy5jb21wYXJlKG15dmFsLCBhcCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmFycmF5W2ldID0gYXA7XG4gICAgaSA9IHA7XG4gIH1cbiAgdGhpcy5hcnJheVtpXSA9IG15dmFsO1xufTtcblxuLy8gcmVwbGFjZSB0aGUgY29udGVudCBvZiB0aGUgaGVhcCBieSBwcm92aWRlZCBhcnJheSBhbmQgXCJoZWFwaWZ5IGl0XCJcbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHRoaXMuYXJyYXkgPSBhcnI7XG4gIHRoaXMuc2l6ZSA9IGFyci5sZW5ndGg7XG4gIHZhciBpO1xuICBmb3IgKGkgPSB0aGlzLnNpemUgPj4gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0aGlzLl9wZXJjb2xhdGVEb3duKGkpO1xuICB9XG59O1xuXG4vLyBmb3IgaW50ZXJuYWwgdXNlXG5GYXN0UHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX3BlcmNvbGF0ZVVwID0gZnVuY3Rpb24oaSwgZm9yY2UpIHtcbiAgdmFyIG15dmFsID0gdGhpcy5hcnJheVtpXTtcbiAgdmFyIHA7XG4gIHZhciBhcDtcbiAgd2hpbGUgKGkgPiAwKSB7XG4gICAgcCA9IChpIC0gMSkgPj4gMTtcbiAgICBhcCA9IHRoaXMuYXJyYXlbcF07XG4gICAgLy8gZm9yY2Ugd2lsbCBza2lwIHRoZSBjb21wYXJlXG4gICAgaWYgKCFmb3JjZSAmJiAhdGhpcy5jb21wYXJlKG15dmFsLCBhcCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmFycmF5W2ldID0gYXA7XG4gICAgaSA9IHA7XG4gIH1cbiAgdGhpcy5hcnJheVtpXSA9IG15dmFsO1xufTtcblxuLy8gZm9yIGludGVybmFsIHVzZVxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLl9wZXJjb2xhdGVEb3duID0gZnVuY3Rpb24oaSkge1xuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgdmFyIGhzaXplID0gdGhpcy5zaXplID4+PiAxO1xuICB2YXIgYWkgPSB0aGlzLmFycmF5W2ldO1xuICB2YXIgbDtcbiAgdmFyIHI7XG4gIHZhciBiZXN0YztcbiAgd2hpbGUgKGkgPCBoc2l6ZSkge1xuICAgIGwgPSAoaSA8PCAxKSArIDE7XG4gICAgciA9IGwgKyAxO1xuICAgIGJlc3RjID0gdGhpcy5hcnJheVtsXTtcbiAgICBpZiAociA8IHNpemUpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBhcmUodGhpcy5hcnJheVtyXSwgYmVzdGMpKSB7XG4gICAgICAgIGwgPSByO1xuICAgICAgICBiZXN0YyA9IHRoaXMuYXJyYXlbcl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5jb21wYXJlKGJlc3RjLCBhaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmFycmF5W2ldID0gYmVzdGM7XG4gICAgaSA9IGw7XG4gIH1cbiAgdGhpcy5hcnJheVtpXSA9IGFpO1xufTtcblxuLy8gaW50ZXJuYWxcbi8vIF9yZW1vdmVBdChpbmRleCkgd2lsbCByZW1vdmUgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4IGZyb20gdGhlIHF1ZXVlLFxuLy8gcmV0YWluaW5nIGJhbGFuY2UuIHJldHVybnMgdGhlIHJlbW92ZWQgaXRlbSwgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgaXMgcmVtb3ZlZC5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fcmVtb3ZlQXQgPSBmdW5jdGlvbihpbmRleCkge1xuICBpZiAoaW5kZXggPiB0aGlzLnNpemUgLSAxIHx8IGluZGV4IDwgMCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAvLyBpbXBsMTpcbiAgLy90aGlzLmFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gIC8vdGhpcy5oZWFwaWZ5KHRoaXMuYXJyYXkpO1xuICAvLyBpbXBsMjpcbiAgdGhpcy5fcGVyY29sYXRlVXAoaW5kZXgsIHRydWUpO1xuICByZXR1cm4gdGhpcy5wb2xsKCk7XG59O1xuXG4vLyByZW1vdmUobXl2YWwpIHdpbGwgcmVtb3ZlIGFuIGl0ZW0gbWF0Y2hpbmcgdGhlIHByb3ZpZGVkIHZhbHVlIGZyb20gdGhlXG4vLyBxdWV1ZSwgY2hlY2tlZCBmb3IgZXF1YWxpdHkgYnkgdXNpbmcgdGhlIHF1ZXVlJ3MgY29tcGFyYXRvci5cbi8vIHJldHVybiB0cnVlIGlmIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZS5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihteXZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBhcmUodGhpcy5hcnJheVtpXSwgbXl2YWwpICYmICF0aGlzLmNvbXBhcmUobXl2YWwsIHRoaXMuYXJyYXlbaV0pKSB7XG4gICAgICAvLyBpdGVtcyBtYXRjaCwgY29tcGFyYXRvciByZXR1cm5zIGZhbHNlIGJvdGggd2F5cywgcmVtb3ZlIGl0ZW1cbiAgICAgIHRoaXMuX3JlbW92ZUF0KGkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGludGVybmFsXG4vLyByZW1vdmVzIGFuZCByZXR1cm5zIGl0ZW1zIGZvciB3aGljaCB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVlLlxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLl9iYXRjaFJlbW92ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBsaW1pdCkge1xuICAvLyBpbml0aWFsaXplIHJldHVybiBhcnJheSB3aXRoIG1heCBzaXplIG9mIHRoZSBsaW1pdCBvciBjdXJyZW50IHF1ZXVlIHNpemVcbiAgdmFyIHJldEFyciA9IG5ldyBBcnJheShsaW1pdCA/IGxpbWl0IDogdGhpcy5zaXplKTtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nICYmIHRoaXMuc2l6ZSkge1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHRoaXMuc2l6ZSAmJiBjb3VudCA8IHJldEFyci5sZW5ndGgpIHtcbiAgICAgIGlmIChjYWxsYmFjayh0aGlzLmFycmF5W2ldKSkge1xuICAgICAgICByZXRBcnJbY291bnRdID0gdGhpcy5fcmVtb3ZlQXQoaSk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIC8vIG1vdmUgdXAgYSBsZXZlbCBpbiB0aGUgaGVhcCBpZiB3ZSByZW1vdmUgYW4gaXRlbVxuICAgICAgICBpID0gaSA+PiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gXG4gIH1cbiAgcmV0QXJyLmxlbmd0aCA9IGNvdW50O1xuICByZXR1cm4gcmV0QXJyO1xufVxuXG4vLyByZW1vdmVPbmUoY2FsbGJhY2spIHdpbGwgZXhlY3V0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbSBvZiB0aGUgcXVldWVcbi8vIGFuZCB3aWxsIHJlbW92ZSB0aGUgZmlyc3QgaXRlbSBmb3Igd2hpY2ggdGhlIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRydWUuXG4vLyByZXR1cm4gdGhlIHJlbW92ZWQgaXRlbSwgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgaXMgcmVtb3ZlZC5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZW1vdmVPbmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgYXJyID0gdGhpcy5fYmF0Y2hSZW1vdmUoY2FsbGJhY2ssIDEpO1xuICByZXR1cm4gYXJyLmxlbmd0aCA+IDAgPyBhcnJbMF0gOiB1bmRlZmluZWQ7XG59O1xuXG4vLyByZW1vdmUoY2FsbGJhY2tbLCBsaW1pdF0pIHdpbGwgZXhlY3V0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbSBvZlxuLy8gdGhlIHF1ZXVlIGFuZCB3aWxsIHJlbW92ZSBlYWNoIGl0ZW0gZm9yIHdoaWNoIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWUsIHVwIHRvXG4vLyBhIG1heCBsaW1pdCBvZiByZW1vdmVkIGl0ZW1zIGlmIHNwZWNpZmllZCBvciBubyBsaW1pdCBpZiB1bnNwZWNpZmllZC5cbi8vIHJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSByZW1vdmVkIGl0ZW1zLlxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLnJlbW92ZU1hbnkgPSBmdW5jdGlvbihjYWxsYmFjaywgbGltaXQpIHtcbiAgcmV0dXJuIHRoaXMuX2JhdGNoUmVtb3ZlKGNhbGxiYWNrLCBsaW1pdCk7XG59O1xuXG4vLyBMb29rIGF0IHRoZSB0b3Agb2YgdGhlIHF1ZXVlIChvbmUgb2YgdGhlIHNtYWxsZXN0IGVsZW1lbnRzKSB3aXRob3V0IHJlbW92aW5nIGl0XG4vLyBleGVjdXRlcyBpbiBjb25zdGFudCB0aW1lXG4vL1xuLy8gQ2FsbGluZyBwZWVrIG9uIGFuIGVtcHR5IHByaW9yaXR5IHF1ZXVlIHJldHVybnNcbi8vIHRoZSBcInVuZGVmaW5lZFwiIHZhbHVlLlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvdW5kZWZpbmVkXG4vL1xuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc2l6ZSA9PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICByZXR1cm4gdGhpcy5hcnJheVswXTtcbn07XG5cbi8vIHJlbW92ZSB0aGUgZWxlbWVudCBvbiB0b3Agb2YgdGhlIGhlYXAgKG9uZSBvZiB0aGUgc21hbGxlc3QgZWxlbWVudHMpXG4vLyBydW5zIGluIGxvZ2FyaXRobWljIHRpbWVcbi8vXG4vLyBJZiB0aGUgcHJpb3JpdHkgcXVldWUgaXMgZW1wdHksIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZVxuLy8gXCJ1bmRlZmluZWRcIiB2YWx1ZS5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL3VuZGVmaW5lZFxuLy9cbi8vIEZvciBsb25nLXJ1bm5pbmcgYW5kIGxhcmdlIHByaW9yaXR5IHF1ZXVlcywgb3IgcHJpb3JpdHkgcXVldWVzXG4vLyBzdG9yaW5nIGxhcmdlIG9iamVjdHMsIHlvdSBtYXkgIHdhbnQgdG8gY2FsbCB0aGUgdHJpbSBmdW5jdGlvblxuLy8gYXQgc3RyYXRlZ2ljIHRpbWVzIHRvIHJlY292ZXIgYWxsb2NhdGVkIG1lbW9yeS5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNpemUgPT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIGFucyA9IHRoaXMuYXJyYXlbMF07XG4gIGlmICh0aGlzLnNpemUgPiAxKSB7XG4gICAgdGhpcy5hcnJheVswXSA9IHRoaXMuYXJyYXlbLS10aGlzLnNpemVdO1xuICAgIHRoaXMuX3BlcmNvbGF0ZURvd24oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zaXplIC09IDE7XG4gIH1cbiAgcmV0dXJuIGFucztcbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWRkcyB0aGUgcHJvdmlkZWQgdmFsdWUgdG8gdGhlIGhlYXAsIHdoaWxlIHJlbW92aW5nXG4vLyBhbmQgcmV0dXJuaW5nIG9uZSBvZiB0aGUgc21hbGxlc3QgZWxlbWVudHMgKGxpa2UgcG9sbCkuIFRoZSBzaXplIG9mIHRoZSBxdWV1ZVxuLy8gdGh1cyByZW1haW5zIHVuY2hhbmdlZC5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZXBsYWNlVG9wID0gZnVuY3Rpb24obXl2YWwpIHtcbiAgaWYgKHRoaXMuc2l6ZSA9PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgYW5zID0gdGhpcy5hcnJheVswXTtcbiAgdGhpcy5hcnJheVswXSA9IG15dmFsO1xuICB0aGlzLl9wZXJjb2xhdGVEb3duKDApO1xuICByZXR1cm4gYW5zO1xufTtcblxuLy8gcmVjb3ZlciB1bnVzZWQgbWVtb3J5IChmb3IgbG9uZy1ydW5uaW5nIHByaW9yaXR5IHF1ZXVlcylcbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LnNsaWNlKDAsIHRoaXMuc2l6ZSk7XG59O1xuXG4vLyBDaGVjayB3aGV0aGVyIHRoZSBoZWFwIGlzIGVtcHR5XG5GYXN0UHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zaXplID09PSAwO1xufTtcblxuLy8gaXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBpbiBvcmRlciwgcGFzcyBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgKGl0ZW0sIGluZGV4KSBhcyBhcmdzLlxuLy8gVE9ETyBvbmNlIHdlIHRyYW5zcGlsZSwgdW5jb21tZW50XG4vLyBpZiAoU3ltYm9sICYmIFN5bWJvbC5pdGVyYXRvcikge1xuLy8gICBGYXN0UHJpb3JpdHlRdWV1ZS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKigpIHtcbi8vICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHJldHVybjtcbi8vICAgICB2YXIgZnBxID0gdGhpcy5jbG9uZSgpO1xuLy8gICAgIHdoaWxlICghZnBxLmlzRW1wdHkoKSkge1xuLy8gICAgICAgeWllbGQgZnBxLnBvbGwoKTtcbi8vICAgICB9XG4vLyAgIH07XG4vLyB9XG5GYXN0UHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLmlzRW1wdHkoKSB8fCB0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICB2YXIgaSA9IDA7XG4gIHZhciBmcHEgPSB0aGlzLmNsb25lKCk7XG4gIHdoaWxlICghZnBxLmlzRW1wdHkoKSkge1xuICAgIGNhbGxiYWNrKGZwcS5wb2xsKCksIGkrKyk7XG4gIH1cbn07XG5cbi8vIHJldHVybiB0aGUgayAnc21hbGxlc3QnIGVsZW1lbnRzIG9mIHRoZSBxdWV1ZVxuLy8gcnVucyBpbiBPKGsgbG9nIGspIHRpbWVcbi8vIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIHBvbGwsIGJ1dFxuLy8gaXQgaGFzIGEgYmV0dGVyIGNvbXB1dGF0aW9uYWwgY29tcGxleGl0eSwgd2hpY2ggY2FuIGJlXG4vLyBpbXBvcnRhbnQgZm9yIGxhcmdlIGRhdGEgc2V0cy5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5rU21hbGxlc3QgPSBmdW5jdGlvbihrKSB7XG4gIGlmICh0aGlzLnNpemUgPT0gMCkgcmV0dXJuIFtdO1xuICB2YXIgY29tcGFyYXRvciA9IHRoaXMuY29tcGFyZTtcbiAgdmFyIGFyciA9IHRoaXMuYXJyYXlcbiAgdmFyIGZwcSA9IG5ldyBGYXN0UHJpb3JpdHlRdWV1ZShmdW5jdGlvbihhLGIpe1xuICAgcmV0dXJuIGNvbXBhcmF0b3IoYXJyW2FdLGFycltiXSk7XG4gIH0pO1xuICBrID0gTWF0aC5taW4odGhpcy5zaXplLCBrKTtcbiAgdmFyIHNtYWxsZXN0ID0gbmV3IEFycmF5KGspO1xuICB2YXIgaiA9IDA7XG4gIGZwcS5hZGQoMCk7XG4gIHdoaWxlIChqIDwgaykge1xuICAgIHZhciBzbWFsbCA9IGZwcS5wb2xsKCk7XG4gICAgc21hbGxlc3RbaisrXSA9IHRoaXMuYXJyYXlbc21hbGxdO1xuICAgIHZhciBsID0gKHNtYWxsIDw8IDEpICsgMTtcbiAgICB2YXIgciA9IGwgKyAxO1xuICAgIGlmIChsIDwgdGhpcy5zaXplKSBmcHEuYWRkKGwpO1xuICAgIGlmIChyIDwgdGhpcy5zaXplKSBmcHEuYWRkKHIpO1xuICB9XG4gIHJldHVybiBzbWFsbGVzdDtcbn1cblxuLy8ganVzdCBmb3IgaWxsdXN0cmF0aW9uIHB1cnBvc2VzXG52YXIgbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBtYWluIGNvZGVcbiAgdmFyIHggPSBuZXcgRmFzdFByaW9yaXR5UXVldWUoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhIDwgYjtcbiAgfSk7XG4gIHguYWRkKDEpO1xuICB4LmFkZCgwKTtcbiAgeC5hZGQoNSk7XG4gIHguYWRkKDQpO1xuICB4LmFkZCgzKTtcbiAgd2hpbGUgKCF4LmlzRW1wdHkoKSkge1xuICAgIGNvbnNvbGUubG9nKHgucG9sbCgpKTtcbiAgfVxufTtcblxuaWYgKHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XG4gIG1haW4oKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGYXN0UHJpb3JpdHlRdWV1ZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fastpriorityqueue/FastPriorityQueue.js\n");

/***/ }),

/***/ "./node_modules/iota-array/iota.js":
/*!*****************************************!*\
  !*** ./node_modules/iota-array/iota.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW90YS1hcnJheS9pb3RhLmpzPzIwMzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpb3RhKG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlvdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/iota-array/iota.js\n");

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzPzA0NGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/is-buffer/index.js\n");

/***/ }),

/***/ "./node_modules/ndarray/ndarray.js":
/*!*****************************************!*\
  !*** ./node_modules/ndarray/ndarray.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iota = __webpack_require__(/*! iota-array */ \"./node_modules/iota-array/iota.js\")\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzP2I1YmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLHFEQUFZO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxvREFBVzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0Msa0NBQWtDO0FBQ2xDLHdCQUF3QjtBQUN4Qix1QkFBdUIsV0FBVztBQUNsQyxhQUFhO0FBQ2IsbUJBQW1CO0FBQ25CLHdDQUF3QztBQUN4QztBQUNBLFdBQVcsc0NBQXNDO0FBQ2pELGlDQUFpQztBQUNqQyxzQkFBc0IsYUFBYTtBQUNuQywyQ0FBMkMsNkJBQTZCO0FBQ3hFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxjQUFjO0FBQ2Q7QUFDQSxFQUFFO0FBQ0Ysa0NBQWtDO0FBQ2xDLHdCQUF3QjtBQUN4Qix1QkFBdUIsb0JBQW9CO0FBQzNDLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxFQUFFO0FBQ0YseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQixFQUFFO0FBQ0YscURBQXFEO0FBQ3JEO0FBQ0EsR0FBRztBQUNILHdDQUF3QztBQUN4QztBQUNBLEVBQUU7QUFDRixpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNM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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoXCJpcy1idWZmZXJcIilcblxudmFyIGhhc1R5cGVkQXJyYXlzICA9ICgodHlwZW9mIEZsb2F0NjRBcnJheSkgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuXG4gIC8vQ3JlYXRlIGNvbnN0cnVjdG9yIGZvciB2aWV3XG4gIHZhciBpbmRpY2VzID0gaW90YShkaW1lbnNpb24pXG4gIHZhciBhcmdzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJpXCIraSB9KVxuICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgdmFyIHN0cmlkZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgY29kZS5wdXNoKFxuICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgIFwidGhpcy5zaGFwZT1bXCIgKyBzaGFwZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLnN0cmlkZT1bXCIgKyBzdHJpZGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgIFwidmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGVcIixcbiAgICBcInByb3RvLmR0eXBlPSdcIitkdHlwZStcIidcIixcbiAgICBcInByb3RvLmRpbWVuc2lvbj1cIitkaW1lbnNpb24pXG5cbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLnNoYXBlW1wiK2krXCJdXCIgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpXG4gICAgICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgIGNvZGUucHVzaChcblwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO1xcXG5pZihzMD5zMSl7XFxcbmlmKHMxPnMyKXtcXFxucmV0dXJuIFsyLDEsMF07XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsxLDIsMF07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzEsMCwyXTtcXFxufVxcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMiwwLDFdO1xcXG59ZWxzZSBpZihzMj5zMSl7XFxcbnJldHVybiBbMCwxLDJdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFswLDIsMV07XFxcbn19fSlcIilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cblxuICAvL3ZpZXcuaW5kZXg6XG4gIGNvZGUucHVzaChcbiAgICBcInByb3RvLmluZGV4PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9pbmRleChcIiwgYXJncy5qb2luKCksIFwiKXtyZXR1cm4gXCIraW5kZXhfc3RyK1wifVwiKVxuXG4gIC8vdmlldy5oaSgpOlxuICBjb2RlLnB1c2goXCJwcm90by5oaT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaGkoXCIrYXJncy5qb2luKFwiLFwiKStcIil7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBbXCIodHlwZW9mIGlcIixpLFwiIT09J251bWJlcid8fGlcIixpLFwiPDApP3RoaXMuc2hhcGVbXCIsIGksIFwiXTppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIraSArIFwiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCIgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIiB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG5cbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcblxuICAvL3ZpZXcudHJhbnNwb3NlKCk6XG4gIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICB2YXIgdFN0cmlkZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdFNoYXBlW2ldID0gXCJhW2lcIitpK1wiXVwiXG4gICAgdFN0cmlkZVtpXSA9IFwiYltpXCIraStcIl1cIlxuICB9XG4gIGNvZGUucHVzaChcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfdHJhbnNwb3NlKFwiK2FyZ3MrXCIpe1wiK1xuICAgIGFyZ3MubWFwKGZ1bmN0aW9uKG4saWR4KSB7IHJldHVybiBuICsgXCI9KFwiICsgbiArIFwiPT09dW5kZWZpbmVkP1wiICsgaWR4ICsgXCI6XCIgKyBuICsgXCJ8MClcIn0pLmpvaW4oXCI7XCIpLFxuICAgIFwidmFyIGE9dGhpcy5zaGFwZSxiPXRoaXMuc3RyaWRlO3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIit0U2hhcGUuam9pbihcIixcIikrXCIsXCIrdFN0cmlkZS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIraStcIl0qaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5zaGFwZVtcIitpK1wiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiK2krXCJdKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcblxuICAvL0FkZCByZXR1cm4gc3RhdGVtZW50XG4gIGNvZGUucHVzaChcInJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixvZmZzZXQpfVwiKVxuXG4gIC8vQ29tcGlsZSBwcm9jZWR1cmVcbiAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIkNUT1JfTElTVFwiLCBcIk9SREVSXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXSwgb3JkZXIpXG59XG5cbmZ1bmN0aW9uIGFycmF5RFR5cGUoZGF0YSkge1xuICBpZihpc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBcImJ1ZmZlclwiXG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3JcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ndarray/ndarray.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() {\n  return this || (typeof self === \"object\" && self);\n})() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcz9iYmRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGdFQUFXOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmKTtcbn0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime-module.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() {\n    return this || (typeof self === \"object\" && self);\n  })() || Function(\"return this\")()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzPzk2Y2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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ZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZik7XG4gIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./src/math-utils.js":
/*!***************************!*\
  !*** ./src/math-utils.js ***!
  \***************************/
/*! exports provided: range, permutationGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"range\", function() { return range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"permutationGenerator\", function() { return permutationGenerator; });\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime-module.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__);\nvar _marked =\n/*#__PURE__*/\nregenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.mark(range),\n    _marked2 =\n/*#__PURE__*/\nregenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.mark(permutationGenerator);\n\n // returns generator over values in range\n// supports range(start, end[, step]) and range(end)\n// (start inclusive, end exclusive)\n// start = 0 by default\n// step = 1 by default\n\nfunction range() {\n  var start,\n      end,\n      step,\n      _len,\n      args,\n      _key,\n      i,\n      _i,\n      _args = arguments;\n\n  return regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function range$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = _args[_key];\n          }\n\n          if (args.length === 1) {\n            start = 0;\n            end = args[0];\n            step = 1;\n          } else if (args.length === 2) {\n            start = args[0];\n            end = args[1];\n            step = 1;\n          } else if (args.length === 3) {\n            start = args[0];\n            end = args[1];\n            step = args[2];\n          }\n\n          if (!(end > start)) {\n            _context.next = 14;\n            break;\n          }\n\n          if (!(step < 0)) {\n            _context.next = 5;\n            break;\n          }\n\n          throw new Error(\"Step must bring start closer to end\");\n\n        case 5:\n          i = start;\n\n        case 6:\n          if (!(i < end)) {\n            _context.next = 12;\n            break;\n          }\n\n          _context.next = 9;\n          return i;\n\n        case 9:\n          i += step;\n          _context.next = 6;\n          break;\n\n        case 12:\n          _context.next = 23;\n          break;\n\n        case 14:\n          if (!(step > 0)) {\n            _context.next = 16;\n            break;\n          }\n\n          throw new Error(\"Step must bring start closer to end\");\n\n        case 16:\n          _i = start;\n\n        case 17:\n          if (!(_i > end)) {\n            _context.next = 23;\n            break;\n          }\n\n          _context.next = 20;\n          return _i;\n\n        case 20:\n          _i += step;\n          _context.next = 17;\n          break;\n\n        case 23:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, this);\n} // returns Generator over all permutations of values in arr with length r\n// adapted from python's itertools.permutations\n\n\nfunction permutationGenerator(arr) {\n  var r,\n      pool,\n      n,\n      inds,\n      cycles,\n      output,\n      i,\n      yielded,\n      _i2,\n      temp,\n      j,\n      swapInd,\n      _ref,\n      k,\n      _args2 = arguments;\n\n  return regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function permutationGenerator$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          r = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : arr.length;\n          pool = arr;\n          n = arr.length;\n          inds = Uint8Array.from(range(n));\n          cycles = Uint8Array.from(range(n, n - r, -1));\n          output = new Uint8Array(r);\n\n          for (i = 0; i < r; i++) {\n            output[i] = pool[inds[i]];\n          }\n\n          _context2.next = 9;\n          return output;\n\n        case 9:\n          yielded = true;\n\n        case 10:\n          if (!yielded) {\n            _context2.next = 37;\n            break;\n          }\n\n          yielded = false;\n          _i2 = r - 1;\n\n        case 13:\n          if (!(_i2 >= 0)) {\n            _context2.next = 35;\n            break;\n          }\n\n          cycles[_i2]--;\n\n          if (!(cycles[_i2] === 0)) {\n            _context2.next = 22;\n            break;\n          }\n\n          // moves inds[i] to end, push other inds left to fill space\n          temp = inds[_i2];\n          inds.copyWithin(_i2, _i2 + 1);\n          inds[inds.length - 1] = temp;\n          cycles[_i2] = n - _i2;\n          _context2.next = 32;\n          break;\n\n        case 22:\n          j = cycles[_i2];\n          swapInd = j === 0 ? 0 : inds.length - j;\n          _ref = [inds[swapInd], inds[_i2]];\n          inds[_i2] = _ref[0];\n          inds[swapInd] = _ref[1];\n\n          for (k = 0; k < r; k++) {\n            output[k] = pool[inds[k]];\n          }\n\n          _context2.next = 30;\n          return output;\n\n        case 30:\n          yielded = true;\n          return _context2.abrupt(\"break\", 35);\n\n        case 32:\n          _i2--;\n          _context2.next = 13;\n          break;\n\n        case 35:\n          _context2.next = 10;\n          break;\n\n        case 37:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, this);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC11dGlscy5qcz83YmVhIl0sIm5hbWVzIjpbInJhbmdlIiwicGVybXV0YXRpb25HZW5lcmF0b3IiLCJhcmdzIiwibGVuZ3RoIiwic3RhcnQiLCJlbmQiLCJzdGVwIiwiRXJyb3IiLCJpIiwiYXJyIiwiciIsInBvb2wiLCJuIiwiaW5kcyIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiY3ljbGVzIiwib3V0cHV0IiwieWllbGRlZCIsInRlbXAiLCJjb3B5V2l0aGluIiwiaiIsInN3YXBJbmQiLCJrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O2dFQU9VQSxLOzs7Z0VBNEJBQyxvQjs7Q0FqQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFVRCxLQUFWO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0NBQW1CRSxJQUFuQjtBQUFtQkEsZ0JBQW5CO0FBQUE7O0FBRUksY0FBSUEsSUFBSSxDQUFDQyxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CQyxpQkFBSyxHQUFHLENBQVI7QUFDQUMsZUFBRyxHQUFHSCxJQUFJLENBQUMsQ0FBRCxDQUFWO0FBQ0FJLGdCQUFJLEdBQUcsQ0FBUDtBQUNILFdBSkQsTUFJTyxJQUFJSixJQUFJLENBQUNDLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDekJDLGlCQUR5QixHQUNYRixJQURXO0FBQ2xCRyxlQURrQixHQUNYSCxJQURXO0FBRTFCSSxnQkFBSSxHQUFHLENBQVA7QUFDSCxXQUhNLE1BR0EsSUFBSUosSUFBSSxDQUFDQyxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3pCQyxpQkFEeUIsR0FDTEYsSUFESztBQUNsQkcsZUFEa0IsR0FDTEgsSUFESztBQUNiSSxnQkFEYSxHQUNMSixJQURLO0FBRTdCOztBQVhMLGdCQWFRRyxHQUFHLEdBQUdELEtBYmQ7QUFBQTtBQUFBO0FBQUE7O0FBQUEsZ0JBY1lF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Q1IsSUFBSSxDQUFDUyxPQUFELENBQUwsRUFBZ0JULElBQUksQ0FBQ0wsR0FBRCxDQUFwQixDQTNCM0M7QUEyQmlCSyxjQUFJLENBQUNMLEdBQUQsQ0EzQnJCO0FBMkIwQkssY0FBSSxDQUFDUyxPQUFELENBM0I5Qjs7QUE2QmdCLGVBQVNDLENBQVQsR0FBYSxDQUFiLEVBQWdCQSxDQUFDLEdBQUdiLENBQXBCLEVBQXVCYSxDQUFDLEVBQXhCO0FBQTRCTixrQkFBTSxDQUFDTSxDQUFELENBQU4sR0FBWVosSUFBSSxDQUFDRSxJQUFJLENBQUNVLENBQUQsQ0FBTCxDQUFoQjtBQUE1Qjs7QUE3QmhCO0FBOEJnQixpQkFBTU4sTUFBTjs7QUE5QmhCO0FBZ0NnQkMsaUJBQU8sR0FBRyxJQUFWO0FBaENoQjs7QUFBQTtBQWVtQ1YsYUFBQyxFQWZwQztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwiZmlsZSI6Ii4vc3JjL21hdGgtdXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVnZW5lcmF0b3JSdW50aW1lIGZyb20gJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUnXG5cbi8vIHJldHVybnMgZ2VuZXJhdG9yIG92ZXIgdmFsdWVzIGluIHJhbmdlXG4vLyBzdXBwb3J0cyByYW5nZShzdGFydCwgZW5kWywgc3RlcF0pIGFuZCByYW5nZShlbmQpXG4vLyAoc3RhcnQgaW5jbHVzaXZlLCBlbmQgZXhjbHVzaXZlKVxuLy8gc3RhcnQgPSAwIGJ5IGRlZmF1bHRcbi8vIHN0ZXAgPSAxIGJ5IGRlZmF1bHRcbmZ1bmN0aW9uKiByYW5nZSguLi5hcmdzKSB7XG4gICAgbGV0IHN0YXJ0LCBlbmQsIHN0ZXA7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gYXJnc1swXTtcbiAgICAgICAgc3RlcCA9IDE7XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBbc3RhcnQsIGVuZF0gPSBhcmdzO1xuICAgICAgICBzdGVwID0gMTtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIFtzdGFydCwgZW5kLCBzdGVwXSA9IGFyZ3M7XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIGlmIChzdGVwIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGVwIG11c3QgYnJpbmcgc3RhcnQgY2xvc2VyIHRvIGVuZGApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBzdGVwKSB5aWVsZCBpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGVwIG11c3QgYnJpbmcgc3RhcnQgY2xvc2VyIHRvIGVuZGApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA+IGVuZDsgaSArPSBzdGVwKSB5aWVsZCBpO1xuICAgIH1cbn1cblxuLy8gcmV0dXJucyBHZW5lcmF0b3Igb3ZlciBhbGwgcGVybXV0YXRpb25zIG9mIHZhbHVlcyBpbiBhcnIgd2l0aCBsZW5ndGggclxuLy8gYWRhcHRlZCBmcm9tIHB5dGhvbidzIGl0ZXJ0b29scy5wZXJtdXRhdGlvbnNcbmZ1bmN0aW9uKiBwZXJtdXRhdGlvbkdlbmVyYXRvcihhcnIsIHI9YXJyLmxlbmd0aCkge1xuICAgIGxldCBwb29sID0gYXJyO1xuICAgIGxldCBuID0gYXJyLmxlbmd0aDtcblxuICAgIGxldCBpbmRzID0gVWludDhBcnJheS5mcm9tKHJhbmdlKG4pKTtcbiAgICBsZXQgY3ljbGVzID0gVWludDhBcnJheS5mcm9tKHJhbmdlKG4sIG4gLSByLCAtMSkpO1xuXG4gICAgbGV0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrKSBvdXRwdXRbaV0gPSBwb29sW2luZHNbaV1dO1xuICAgIHlpZWxkIG91dHB1dDtcblxuICAgIGxldCB5aWVsZGVkID0gdHJ1ZTtcblxuICAgIHdoaWxlICh5aWVsZGVkKSB7XG4gICAgICAgIHlpZWxkZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHIgLSAxOyBpID49MDsgaS0tKSB7XG4gICAgICAgICAgICBjeWNsZXNbaV0tLTtcbiAgICAgICAgICAgIGlmIChjeWNsZXNbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlcyBpbmRzW2ldIHRvIGVuZCwgcHVzaCBvdGhlciBpbmRzIGxlZnQgdG8gZmlsbCBzcGFjZVxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gaW5kc1tpXTtcbiAgICAgICAgICAgICAgICBpbmRzLmNvcHlXaXRoaW4oaSwgaSArIDEpO1xuICAgICAgICAgICAgICAgIGluZHNbaW5kcy5sZW5ndGggLSAxXSA9IHRlbXA7XG5cbiAgICAgICAgICAgICAgICBjeWNsZXNbaV0gPSBuIC0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGogPSBjeWNsZXNbaV07XG4gICAgICAgICAgICAgICAgbGV0IHN3YXBJbmQgPSBqID09PSAwID8gMCA6IGluZHMubGVuZ3RoIC0gajtcbiAgICAgICAgICAgICAgICBbaW5kc1tpXSwgaW5kc1tzd2FwSW5kXV0gPSBbaW5kc1tzd2FwSW5kXSwgaW5kc1tpXV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHI7IGsrKykgb3V0cHV0W2tdID0gcG9vbFtpbmRzW2tdXTtcbiAgICAgICAgICAgICAgICB5aWVsZCBvdXRwdXQ7XG5cbiAgICAgICAgICAgICAgICB5aWVsZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHtyYW5nZSwgcGVybXV0YXRpb25HZW5lcmF0b3J9Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/math-utils.js\n");

/***/ }),

/***/ "./src/sliding-puzzle-algorithms.js":
/*!******************************************!*\
  !*** ./src/sliding-puzzle-algorithms.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fastpriorityqueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastpriorityqueue */ \"./node_modules/fastpriorityqueue/FastPriorityQueue.js\");\n/* harmony import */ var fastpriorityqueue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fastpriorityqueue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ndarray */ \"./node_modules/ndarray/ndarray.js\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var avl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avl */ \"./node_modules/avl/src/index.js\");\n/* harmony import */ var _math_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math-utils */ \"./src/math-utils.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime-module.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_4__);\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Operator pre-computation, in-place modification of grid state for ida* based on\n// \"Implementing Fast Heuristic Search Code\"\n// by Ethan Burns and Matthew Hatem and Michael J. Leighton and Wheeler Ruml\n// Linear conflict heuristic based on\n// \"Criticizing Solutions to Relaxed Models Yields Powerful Admissible Heuristics\"\n// by Othar Hansson and Andrew Mayer\n// TODO: modify readme to explain how to use node + webpack + babel\n// TODO: write function to time performance of different alg+heuristic combos\n// TODO: fix freeze when solving some 5x4 puzzles (and presumably those larger than that) using A*\n// iteration limit should work, but not working and/or iterations taking substantially more memory + longer\n\n\n\n\n\nvar REVERSE_MOVE_MAP = {\n  'r': 'l',\n  'l': 'r',\n  'd': 'u',\n  'u': 'd' // TODO: if using pattern database, consider encoding pattern numbers into bytes and storing in int\n  // probably use 6-6-3 pattern database (while not fastest, takes up moderate amount of memory)\n  // consider using IndexedDB for db storage\n  // pros: simple, well-supported\n  // cons: probably slower than loading Map into memory\n  // alternative: look into storing db as bytes, read whole db into memory at start and query from there\n  // TODO: note that pattern dbs will make it difficult to allow non-square puzzles with dimensions > 4\n  // NOTE: methods not static to support using cached MD data specific to puzzle\n  // grid not part of constructor as single heuristic passed between all grids in a given Puzzle\n\n};\n\nvar ManhattanHeuristic =\n/*#__PURE__*/\nfunction () {\n  function ManhattanHeuristic(numRows, numCols) {\n    _classCallCheck(this, ManhattanHeuristic);\n\n    this.numRows = numRows;\n    this.numCols = numCols;\n    this.numTiles = numRows * numCols;\n\n    this._precompute();\n\n    this.moveNumberMap = {\n      'l': 0,\n      'r': 1,\n      'u': 2,\n      'd': 3\n    };\n  } // TODO: change so precompute called once for all puzzles of same size\n  // since no matter what user settings are called, all possible inds and goalInds accounted for\n  // store as class property, and change heuristics back to static\n  // returns whether precomputation could be completed\n\n\n  _createClass(ManhattanHeuristic, [{\n    key: \"_precompute\",\n    value: function _precompute() {\n      // stop precomputing when numTiles > 100 (50,000 array entries in cache)\n      if (this.numTiles > 100) {\n        return false;\n      } // _md.get(i, j) = md value at ind = i, goalInd = j\n\n\n      this._md = ndarray__WEBPACK_IMPORTED_MODULE_1___default()(new Uint16Array(Math.pow(this.numTiles, 2)), [this.numTiles, this.numTiles]); // _mdDelta.get(i, j, k) = change in MD when ind = i, goalInd = j, and move = k\n      // where move = 0 -> 'l', 1 -> 'r', 2 -> 'u' 3 -> 'd'\n\n      this._mdDelta = ndarray__WEBPACK_IMPORTED_MODULE_1___default()(new Int8Array(4 * Math.pow(this.numTiles, 2)), [this.numTiles, this.numTiles, 4]); // l, r, u, d\n\n      var moveDeltaMap = Int16Array.from([-1, 1, -this.numCols, this.numCols]);\n      var ind, goalInd;\n      ind = 0;\n\n      for (var row1 = 0; row1 < this.numRows; row1++) {\n        for (var col1 = 0; col1 < this.numCols; col1++) {\n          goalInd = 0;\n\n          for (var row2 = 0; row2 < this.numRows; row2++) {\n            for (var col2 = 0; col2 < this.numCols; col2++) {\n              this._md.set(ind, goalInd, Math.abs(row2 - row1) + Math.abs(col2 - col1));\n\n              goalInd++;\n            }\n          }\n\n          ind++;\n        }\n      }\n\n      ind = 0;\n\n      for (var _row = 0; _row < this.numRows; _row++) {\n        for (var _col = 0; _col < this.numCols; _col++) {\n          goalInd = 0;\n\n          for (var _row2 = 0; _row2 < this.numRows; _row2++) {\n            for (var _col2 = 0; _col2 < this.numCols; _col2++) {\n              var startMD = this._md.get(ind, goalInd); // l, r, u, d\n\n\n              for (var move = 0; move < 4; move++) {\n                var endMD = this._md.get(ind + moveDeltaMap[move], goalInd);\n\n                this._mdDelta.set(ind, goalInd, move, endMD - startMD);\n              }\n\n              goalInd++;\n            }\n          }\n\n          ind++;\n        }\n      }\n\n      return true;\n    } // returns heuristic distance from goal\n\n  }, {\n    key: \"calculate\",\n    value: function calculate(grid) {\n      var dist = 0;\n\n      for (var i = 0; i < grid.tiles.length; i++) {\n        if (i !== grid.emptyPos) {\n          if (this._md) {\n            dist += this._md.get(i, grid.tiles[i]);\n          } else {\n            dist += grid.getTileDist(i, grid.tiles[i]);\n          }\n        }\n      }\n\n      return dist;\n    } // TODO: consider refactoring to just use \"grid\" to prevent confusion\n    // Returns updated heuristic distance from goal after move\n    // newGrid = Grid after move (distinct object), with all properties updated besides heuristicValue\n    // startInd = ind moved tile started in\n    // endInd = ind moved tile ended up in\n    // move = single-letter move within 'l/r/u/d'\n    // NOTE: assumes newGrid's heuristic value is same as old grid (not yet updated)\n\n  }, {\n    key: \"update\",\n    value: function update(newGrid, startInd, endInd, move) {\n      return this.getUpdateDelta(newGrid, startInd, endInd, move) + newGrid.heuristicValue;\n    } // returns change in heuristic distance from move\n    // newGrid = Grid after move (distinct object), with all properties updated besides heuristicValue\n    // startInd = ind moved tile started in\n    // endInd = ind moved tile ended up in\n    // move = single-letter move within 'l/r/u/d'\n\n  }, {\n    key: \"getUpdateDelta\",\n    value: function getUpdateDelta(newGrid, startInd, endInd, move) {\n      if (this._mdDelta) {\n        // get(movedInd, goalInd, move)\n        // (goalInd is value of tile at endInd, as newGrid's endInd is oldGrid's startInd)\n        return this._mdDelta.get(startInd, newGrid.tiles[endInd], this.moveNumberMap[move]);\n      }\n\n      var goalInd = newGrid.tiles[endInd],\n          goalRow = newGrid.getTileRow(goalInd),\n          goalCol = newGrid.getTileCol(goalInd);\n      var startRow = newGrid.getTileRow(startInd),\n          startCol = newGrid.getTileCol(startInd);\n      var endRow = newGrid.getTileRow(endInd),\n          endCol = newGrid.getTileCol(endInd);\n      return Math.abs(goalRow - endRow) + Math.abs(goalCol - endCol) - Math.abs(goalRow - startRow) + Math.abs(goalCol - startCol);\n    } // returns whether heuristic value indicates if puzzle is solved\n\n  }, {\n    key: \"isSolved\",\n    value: function isSolved(heuristicValue) {\n      return heuristicValue === 0;\n    }\n  }]);\n\n  return ManhattanHeuristic;\n}(); // NOTE: methods not static to support using cached MD data specific to puzzle\n\n\nvar LinearConflictHeuristic =\n/*#__PURE__*/\nfunction (_ManhattanHeuristic) {\n  _inherits(LinearConflictHeuristic, _ManhattanHeuristic);\n\n  function LinearConflictHeuristic(numRows, numCols) {\n    _classCallCheck(this, LinearConflictHeuristic);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LinearConflictHeuristic).call(this, numRows, numCols));\n  } // returns whether precomputation could be completed\n\n\n  _createClass(LinearConflictHeuristic, [{\n    key: \"_precompute\",\n    value: function _precompute() {\n      _get(_getPrototypeOf(LinearConflictHeuristic.prototype), \"_precompute\", this).call(this);\n\n      var n = Math.max(this.numRows, this.numCols); // avoid precomputation when n > 8 or puzzle is 1D (can just use MD)\n      // 9 has 986,409 perms\n      // 8 has 19,173,960 spaces (each > 1 byte given Uint8Array and overhead)\n      // while precomputing still feasible for n = 9, no point as > 1D puzzles not\n      // optimally solvable at that point for current solvers here\n      // ndarray also becomes too large when n = 10 (throws error)\n\n      if (n > 8 || this.numRows === 1 || this.numCols === 1) {\n        return false;\n      } // maps size of orderings of tiles in their goal row/col to an ndarray\n      // mapping the orderings themselves to the linear conflict heuristic value\n      // NOTE: ndarray used instead of map, as constant toString() computationally costlier\n      // than indexing into ndarray\n      // cons: much larger space consumption (sum of n^k from k = 1 to n)\n      // consumes 19,173,960 spaces (each > 1 byte given Uint8Array and overhead) when n = 8\n\n\n      this._lc = new Array(n);\n\n      for (var permSize = 1; permSize <= n; permSize++) {\n        this._lc[permSize] = ndarray__WEBPACK_IMPORTED_MODULE_1___default()(new Uint8Array(Math.pow(n, permSize)), new Uint8Array(permSize).fill(n));\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._permutationHelper(n)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _this$_lc$perm$length;\n\n          var perm = _step.value;\n\n          (_this$_lc$perm$length = this._lc[perm.length]).set.apply(_this$_lc$perm$length, _toConsumableArray(perm).concat([this._calculate(perm)]));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    } // returns Generator over possible orderings of tiles in their goal rows/cols\n    // ex: [2, 1, 0] = 0th ind -> tile with goal ind of 2, 1st ind -> tile with goal ind of 1\n    // NOTE: # permutations = sum of n permute k from k = 1 to n = ⌊en!−1⌋\n\n  }, {\n    key: \"_permutationHelper\",\n    value:\n    /*#__PURE__*/\n    regenerator_runtime__WEBPACK_IMPORTED_MODULE_4___default.a.mark(function _permutationHelper(n) {\n      var arr, permSize, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, perm;\n\n      return regenerator_runtime__WEBPACK_IMPORTED_MODULE_4___default.a.wrap(function _permutationHelper$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // while Int8Array goes from 0 to 255, acceptable as memory requirements\n              // balloon when numRows/numCols > 8\n              arr = Uint8Array.from(Object(_math_utils__WEBPACK_IMPORTED_MODULE_3__[\"range\"])(n));\n              permSize = 1;\n\n            case 2:\n              if (!(permSize <= n)) {\n                _context.next = 32;\n                break;\n              }\n\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 6;\n              _iterator2 = Object(_math_utils__WEBPACK_IMPORTED_MODULE_3__[\"permutationGenerator\"])(arr, permSize)[Symbol.iterator]();\n\n            case 8:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              perm = _step2.value;\n              _context.next = 12;\n              return perm;\n\n            case 12:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 8;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context[\"catch\"](6);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError2) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              permSize++;\n              _context.next = 2;\n              break;\n\n            case 32:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _permutationHelper, this, [[6, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: \"_calculate\",\n    value: function _calculate(arr) {\n      var map = new Map();\n\n      for (var i = 0; i < arr.length; i++) {\n        var goalInd = arr[i];\n        map.set(i, {\n          goalInd: goalInd,\n          conflicts: new Set()\n        });\n      }\n\n      return this._calculateForMap(map);\n    } // TODO: consider separating lc condition check into new function for possibly better performance\n    // (less \"if\" checks)\n    // calculates linear conflict of specified grid\n    // optional start/end params allow specifying section of grid to calculate conflict heuristic for\n    // rectangular section of grid, where start is inclusive and end if exclusive\n    // calcMD determines if calculate() includes Manhattan Distance in heuristic calculation\n    // NOTE: since linear conflict + MD always admissible and at least as good, only use\n    // calcMD = false for testing or if you plan on calculating MD in a different way\n    // ex: calculate(grid, 0, 3, 1, 2) calculates heuristic for 3 tile tall vertical chunk\n    // in col[1] from row[0->2]\n    // Heuristic explanation:\n    // linear conflict = 2 tiles in the same goal row/col but have inversion relationship.\n    // horizontal: (a is to right of b but a's goal is to left of b's goal)\n    // vertical: same but with bottom and top instead of right and left\n    // To reach goal positions, one of the tiles in the pair has to move out of the way\n    // for the other tile to reach their goal. The moved tile has to move back into their\n    // goal row/col to reach their goals.\n    //\n    // Linear conflict is calculated on every row and column, and can be combined with\n    // manhattan distance heuristic to make better admissible heuristic,\n    // as manhattan distance heuristic doesn't account for moving tiles out of the way\n    // and linear conflct doesn't account for moving to the correct tile position \n    //\n    // WARNING: You can't just add 2 to the heuristic value for each inversion found,\n    // as moving one tile out of the way can allow 2 tiles it conflicts with to move into their goals\n    // ex: [3, 1, 2] has goal positions of [1, 2, 3]\n    // to reach the goal, move 3 down and slide 1 and 2 over, and then move 3 to the goal\n    // while there are 2 inversions (3, 1) and (3, 2), moving 3 out of the way for 1 means\n    // that it is out of the way for 2 as well.\n    // If you added 2 for each inversion, heuristic = LC = (2 + 2) + MD = (2 + 1 + 1) = 8\n    // when the optimal solution only takes 6 moves (\"3\" down, \"1\" left, \"2\" left, \"3\" right x2, \"3\" up)\n\n  }, {\n    key: \"calculate\",\n    value: function calculate(grid) {\n      var heuristicValue = 0; // candidateTiles.get(i) = map of tiles of row/col i that are in their goal row/col\n      // map = {ind: {goalInd, conflicts}}\n      // - ind = current index in flattened puzzle array\n      // - goalInd = value at ind = index of the tile in the goal puzzle\n      // - conflicts is a set of conflicting indices (initially empty)\n      // NOTE: cols accessed at key = column index + grid.numRows\n      // (first grid.numRows entries are for rows, next grid.numCols entries for columns)\n\n      var candidateTiles = new Map(); // determines which tiles are in their goal row and/or column\n\n      for (var row = 0; row < this.numRows; row++) {\n        for (var col = 0; col < this.numCols; col++) {\n          var ind = grid.getIndex(row, col);\n          var goalInd = grid.tiles[ind],\n              goalRow = grid.getTileRow(goalInd),\n              goalCol = grid.getTileCol(goalInd);\n\n          if (ind !== grid.emptyPos) {\n            // add manhattan distance to heuristic value\n            if (this._md) {\n              heuristicValue += this._md.get(ind, goalInd);\n            } else {\n              heuristicValue += Math.abs(row - goalRow) + Math.abs(col - goalCol);\n            } // NOTE: single tile can be candidate for both row and col conflict\n            // as tile can be part of conflict even when it's in its goal position\n\n\n            if (grid.getTileRow(goalInd) === row) {\n              if (this._lc) {\n                if (!candidateTiles.has(row)) {\n                  candidateTiles.set(row, []);\n                }\n\n                candidateTiles.get(row).push(goalCol);\n              } else {\n                if (!candidateTiles.has(row)) {\n                  candidateTiles.set(row, new Map());\n                }\n\n                candidateTiles.get(row).set(ind, {\n                  goalInd: goalInd,\n                  conflicts: new Set()\n                });\n              }\n            }\n\n            if (grid.getTileCol(goalInd) === col) {\n              var key = grid.numRows + col;\n\n              if (this._lc) {\n                if (!candidateTiles.has(key)) {\n                  candidateTiles.set(key, []);\n                }\n\n                candidateTiles.get(key).push(goalRow);\n              } else {\n                if (!candidateTiles.has(key)) {\n                  candidateTiles.set(key, new Map());\n                }\n\n                candidateTiles.get(key).set(ind, {\n                  goalInd: goalInd,\n                  conflicts: new Set()\n                });\n              }\n            }\n          }\n        }\n      } // TODO: consider making custom function for update since only need to examine\n      // if tile in 1 (known) goal dimension and map also unnecessary\n      // maybe helper functions for processing each row/col?\n      // don't use helpers for regular calculate() though (probably less efficient\n      // since each tile would be iterated over twice (separately for row and col))\n\n\n      if (this._lc) {\n        // TODO: use values since keys unnecessary now\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = candidateTiles.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _this$_lc$arr$length;\n\n            var _step3$value = _slicedToArray(_step3.value, 2),\n                arr = _step3$value[1];\n\n            heuristicValue += (_this$_lc$arr$length = this._lc[arr.length]).get.apply(_this$_lc$arr$length, _toConsumableArray(arr));\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      } else {\n        // row/grid.numRows + col no longer relevant and can be discarded \n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = candidateTiles.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n                map = _step4$value[1];\n\n            heuristicValue += this._calculateForMap(map);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      return heuristicValue;\n    }\n  }, {\n    key: \"_calculateForMap\",\n    value: function _calculateForMap(map) {\n      if (map.size < 2) {\n        return 0;\n      }\n\n      var heuristicValue = 0;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = map[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              ind1 = _step5$value[0],\n              _step5$value$ = _step5$value[1],\n              goalInd1 = _step5$value$.goalInd,\n              conflicts1 = _step5$value$.conflicts;\n\n          var _iteratorNormalCompletion8 = true;\n          var _didIteratorError8 = false;\n          var _iteratorError8 = undefined;\n\n          try {\n            for (var _iterator8 = map[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n              var _step8$value = _slicedToArray(_step8.value, 2),\n                  ind2 = _step8$value[0],\n                  _step8$value$ = _step8$value[1],\n                  goalInd2 = _step8$value$.goalInd,\n                  conflicts2 = _step8$value$.conflicts;\n\n              if (ind2 > ind1 && goalInd2 < goalInd1) {\n                map.get(ind1).conflicts.add(ind2);\n                map.get(ind2).conflicts.add(ind1);\n              }\n            }\n          } catch (err) {\n            _didIteratorError8 = true;\n            _iteratorError8 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                _iterator8.return();\n              }\n            } finally {\n              if (_didIteratorError8) {\n                throw _iteratorError8;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var conflictTree = new avl__WEBPACK_IMPORTED_MODULE_2__[\"default\"](function (a, b) {\n        if (a.ind === b.ind) return 0;\n        var diff = a.conflicts.size - b.conflicts.size; // sorts by ind ascending if conflicts equal\n        // necessary to identify object by ind in tree, as node with same # conflicts\n        // as desired node can appear before desired node\n\n        return diff === 0 ? a.ind - b.ind : diff;\n      });\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = map[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              ind = _step6$value[0],\n              _step6$value$ = _step6$value[1],\n              goalInd = _step6$value$.goalInd,\n              conflicts = _step6$value$.conflicts;\n\n          if (conflicts.size > 0) {\n            conflictTree.insert({\n              conflicts: conflicts,\n              ind: ind\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var tile;\n\n      while (conflictTree.size > 0) {\n        tile = conflictTree.max(); // NOTE: library has no option for finding and removing largest item in one step\n        // could use pop() workaround with opposite comparator, but pop also calls\n        // remove() after finding min in current version (1.4.4)\n\n        conflictTree.remove(tile); // heuristic += 2 for each tile that must be removed before there are no conflicts\n\n        heuristicValue += 2;\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = tile.conflicts[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var conflict = _step7.value;\n            // corresponding conflicts of conflicting tile\n            // ex: a.conflicts = [b,c], b.conflicts = [a], corrConflicts of a = (Set) [a]\n            var corrConflicts = map.get(conflict).conflicts;\n            var corrObj = {\n              conflicts: corrConflicts,\n              ind: conflict\n            };\n            conflictTree.remove(corrObj); // NOTE: tree uses reference to same conflicts object, so conflicts updated there as well\n\n            corrConflicts.delete(tile.ind); // removed and inserted to reorder based on new number of conflicts\n\n            if (corrConflicts.size > 0) {\n              conflictTree.insert(corrObj);\n            }\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      }\n\n      return heuristicValue;\n    } // calculates LC for given row index\n    // NOTE: doesn't incorporate MD\n\n  }, {\n    key: \"_calculateForRow\",\n    value: function _calculateForRow(grid, row) {\n      var candidateTiles = this._lc ? [] : new Map();\n\n      for (var col = 0; col < this.numCols; col++) {\n        var ind = col + this.numCols * row;\n\n        if (ind !== grid.emptyPos) {\n          var goalInd = grid.tiles[ind],\n              goalRow = grid.getTileRow(goalInd),\n              goalCol = grid.getTileCol(goalInd);\n\n          if (row === goalRow) {\n            if (this._lc) {\n              candidateTiles.push(goalCol);\n            } else {\n              candidateTiles.set(col, {\n                goalInd: goalCol,\n                conflicts: new Set()\n              });\n            }\n          }\n        }\n      }\n\n      if (this._lc) {\n        var _this$_lc$candidateTi;\n\n        if (candidateTiles.length < 2) {\n          return 0;\n        }\n\n        return (_this$_lc$candidateTi = this._lc[candidateTiles.length]).get.apply(_this$_lc$candidateTi, _toConsumableArray(candidateTiles));\n      }\n\n      return this._calculateForMap(candidateTiles);\n    } // calculates LC for given column index\n    // NOTE: doesn't incorporate MD\n\n  }, {\n    key: \"_calculateForCol\",\n    value: function _calculateForCol(grid, col) {\n      var candidateTiles = this._lc ? [] : new Map();\n\n      for (var row = 0; row < this.numRows; row++) {\n        var ind = col + this.numCols * row;\n\n        if (ind !== grid.emptyPos) {\n          var goalInd = grid.tiles[ind],\n              goalRow = grid.getTileRow(goalInd),\n              goalCol = grid.getTileCol(goalInd);\n\n          if (col === goalCol) {\n            if (this._lc) {\n              candidateTiles.push(goalRow);\n            } else {\n              candidateTiles.set(row, {\n                goalInd: goalRow,\n                conflicts: new Set()\n              });\n            }\n          }\n        }\n      }\n\n      if (this._lc) {\n        var _this$_lc$candidateTi2;\n\n        if (candidateTiles.length < 2) {\n          return 0;\n        }\n\n        return (_this$_lc$candidateTi2 = this._lc[candidateTiles.length]).get.apply(_this$_lc$candidateTi2, _toConsumableArray(candidateTiles));\n      }\n\n      return this._calculateForMap(candidateTiles);\n    }\n  }, {\n    key: \"update\",\n    value: function update(newGrid, startInd, endInd, move) {\n      return this.getUpdateDelta(newGrid, startInd, endInd, move) + newGrid.heuristicValue;\n    } // TODO: consider splitting update into 2 parts so newGrid isn't switched back and forth in IDA*\n    // (or create helper that also takes in start and end locations of tile as well as newGrid\n    // for use in IDA*)\n    // TODO: have update function that returns updated grid for use in ida*\n    // TODO: see if calculate() needs anything changed besides emptyPos and tile swap\n    // returns change in heuristic distance from move\n    // newGrid = Grid after move (distinct object), with all properties updated besides heuristicValue\n    // startInd = ind moved tile started in\n    // endInd = ind moved tile ended up in\n    // move = single-letter move within 'l/r/u/d'\n\n  }, {\n    key: \"getUpdateDelta\",\n    value: function getUpdateDelta(newGrid, startInd, endInd, move) {\n      var startRow = newGrid.getTileRow(startInd),\n          startCol = newGrid.getTileCol(startInd);\n      var startVal = 0,\n          endVal = 0;\n      var func;\n      var inds;\n\n      switch (move) {\n        case 'l':\n          func = this._calculateForCol;\n          inds = [startCol, startCol - 1];\n          break;\n\n        case 'r':\n          func = this._calculateForCol;\n          inds = [startCol, startCol + 1];\n          break;\n\n        case 'u':\n          func = this._calculateForRow;\n          inds = [startRow, startRow - 1];\n          break;\n\n        case 'd':\n          func = this._calculateForRow;\n          inds = [startRow, startRow + 1];\n          break;\n      } // Manhattan distance not calculated in func as only needs to be calculated\n      // for single tile moved (more efficient to calculate separately)\n\n\n      endVal += func.call(this, newGrid, inds[0]);\n      endVal += func.call(this, newGrid, inds[1]); // returns grid partially to pre-move state to calculate LC for relevant cols pre-move\n\n      newGrid.swap(startInd, endInd);\n      newGrid.emptyPos = endInd;\n      startVal += func.call(this, newGrid, inds[0]);\n      startVal += func.call(this, newGrid, inds[1]); // return grid to original state\n\n      newGrid.swap(startInd, endInd);\n      newGrid.emptyPos = startInd;\n      return endVal - startVal + _get(_getPrototypeOf(LinearConflictHeuristic.prototype), \"getUpdateDelta\", this).call(this, newGrid, startInd, endInd, move);\n    } // returns whether heuristic value indicates if puzzle is solved\n\n  }, {\n    key: \"isSolved\",\n    value: function isSolved(heuristicValue) {\n      return heuristicValue === 0;\n    }\n  }]);\n\n  return LinearConflictHeuristic;\n}(ManhattanHeuristic); // NOTE: separate from puzzle-graphic's Puzzles to ease testing and reduce memory cost in A*\n\n\nvar Puzzle =\n/*#__PURE__*/\nfunction () {\n  /**\n   * creates new Puzzle instance\n   * @param numRows # rows in grid\n   * @param numCols # columns in grid\n   * @param tiles flattened array of tile ids corresponding to their locations in the unsolved puzzle\n   * (where ids = tile positions in the solved puzzle left to right, top to bottom, 0 indexed)\n   * - ex: startGrid = [b, a, c], goalGrid = [a, b, c], return = [1, 0, 2]\n   * - explanation: b = goalGrid[1], a = goalGrid[0], c = goalGrid[2]\n   * @param emptyPos position of empty tile in grid\n   * @param heuristic heuristic used to determine how far grid is from goal state.\n   * Default heuristic is Linear Conflict, possible values are 'MD' and 'LC'\n   * corresponding with manhattan distance and linear conflict respectively\n   * @param solver solving algorithm to use ('IDA*' or 'A*')\n   */\n  function Puzzle(numRows, numCols, tiles, emptyPos) {\n    var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n        _ref$heuristic = _ref.heuristic,\n        heuristic = _ref$heuristic === void 0 ? 'LC' : _ref$heuristic,\n        _ref$solver = _ref.solver,\n        solver = _ref$solver === void 0 ? numRows * numCols > 9 ? 'IDA*' : 'A*' : _ref$solver;\n\n    _classCallCheck(this, Puzzle);\n\n    this.numRows = numRows;\n    this.numCols = numCols; // use less memory if possible\n\n    this.tiles = tiles.length > 256 ? Uint16Array.from(tiles) : Uint8Array.from(tiles);\n    this.emptyPos = emptyPos;\n    var heuristicClass;\n\n    switch (heuristic) {\n      case 'MD':\n        heuristicClass = ManhattanHeuristic;\n        break;\n\n      default:\n        heuristicClass = LinearConflictHeuristic;\n    }\n\n    this.heuristic = new heuristicClass(numRows, numCols);\n    this.solver = solver;\n  } // returns\n  // - solution as array of moves within (l/r/u/d)\n  // - -1 if solution took too long to find\n  // - null if solution could not be found\n  // NOTE: maxIterations ignored for 'strategic' option\n\n\n  _createClass(Puzzle, [{\n    key: \"solve\",\n    value: function solve() {\n      var maxIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100000;\n\n      if (this.solver === 'A*') {\n        return this.solveAStar(maxIterations);\n      } else if (this.solver === 'IDA*') {\n        return this.solveIDAStar(maxIterations);\n      } else if (this.solver === 'strategic') {\n        return this.solveStrategically();\n      } else {\n        throw new Error(\"\\n                {this.solver} is not a valid option. Choose between 'A*', 'IDA*', and 'strategic'.\");\n      }\n    }\n  }, {\n    key: \"solveAStar\",\n    value: function solveAStar(maxIterations) {\n      // TODO: consider using bucket queue instead of priority queue\n      // e.g. array where key = total distance, value = node with that distance\n      // also consider nested bucket queue to allow ordering by traveledDist to tie-break\n      var q = new fastpriorityqueue__WEBPACK_IMPORTED_MODULE_0___default.a( // NOTE: comparator puts grid1 first if return \"true\" (grid1 less than grid2)\n      function (grid1, grid2) {\n        var total1 = grid1.heuristicValue + grid1.traveledDist,\n            total2 = grid2.heuristicValue + grid2.traveledDist; // favor grids with more traveled distance\n        // explanation: since admissisible heuristics\n        // underestimate or match actual distance to goal,\n        // actual distance of grid with more traveled distance is likely to be <=\n        // actual distance of grid with less traveled distance\n        // when total distance is equal\n\n        return total1 === total2 ? grid1.traveledDist > grid2.traveledDist : total1 < total2;\n      });\n      var grid = new Grid(this.numRows, this.numCols, this.tiles, this.emptyPos, this.heuristic, 0);\n      q.add(grid);\n      var curr; // maps Grid state to best/shortest (heuristic + distance traveled) found so far\n\n      var best = new Map();\n      var iterations = 0;\n\n      while (q.size > 0) {\n        if (iterations > maxIterations) {\n          return -1;\n        }\n\n        curr = q.poll();\n\n        if (curr.isSolved()) {\n          console.log(iterations);\n          return curr.reconstructPath();\n        }\n\n        var _iteratorNormalCompletion9 = true;\n        var _didIteratorError9 = false;\n        var _iteratorError9 = undefined;\n\n        try {\n          for (var _iterator9 = curr.getValidMoves()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n            var move = _step9.value;\n\n            // reversing a move will never lead to an optimal path\n            if (move !== Grid.getReversedMove(curr.lastMove)) {\n              var newGrid = curr.cloneAndApplyMove(move);\n              var score = newGrid.traveledDist + newGrid.heuristicValue;\n              var key = newGrid.tiles.toString(); // add to queue and replace best score if score better than previous best\n              // NOTE: not using <, as previous best could be undefined\n              // executes if best either undefined or >= current score\n              // NOTE: obviates need for visited set, as only adds node when\n              // better than best found so far vs. adding when better than best possible\n              // (by the time best possible is found, several nodes could be discarded\n              // by being worse than previous discovered not-yet-popped nodes)\n\n              if (!(score >= best.get(key))) {\n                best.set(key, score);\n                q.add(newGrid);\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError9 = true;\n          _iteratorError9 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n              _iterator9.return();\n            }\n          } finally {\n            if (_didIteratorError9) {\n              throw _iteratorError9;\n            }\n          }\n        }\n\n        iterations++;\n      } // no solution found\n\n\n      return null;\n    } // TODO: make use of maxIterations or some other limiting function to stop freezing browser\n\n  }, {\n    key: \"solveIDAStar\",\n    value: function solveIDAStar(maxIterations) {\n      var grid = new Grid(this.numRows, this.numCols, this.tiles, this.emptyPos, this.heuristic, 0); // upper bound of total distance for when to stop exploring nodes in given iteration of dfs\n\n      var bound = grid.heuristicValue;\n      var path = [];\n\n      while (true) {\n        var output = this._searchIDAStar(grid, path, 0, bound);\n\n        if (output === true) {\n          return path;\n        } else if (output === Infinity) {\n          return null;\n        } // upper bound of search updated to min total distance explored that was\n        // greater than previous bound\n\n\n        bound = output;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_searchIDAStar\",\n    value: function _searchIDAStar(grid, path, traveledDist, bound) {\n      var totalDist = traveledDist + grid.heuristicValue;\n      if (totalDist > bound) return totalDist;\n      if (grid.isSolved()) return true; // tracks min total distance of all nodes explored\n\n      var minTotalDist = Infinity;\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = grid.getValidMoves()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var move = _step10.value;\n\n          // reversing previous move never leads to optimal solution\n          if (move !== Grid.getReversedMove(path[path.length - 1])) {\n            var moveRecord = grid.applyMove(move);\n            path.push(move);\n\n            var output = this._searchIDAStar(grid, path, traveledDist + 1, bound);\n\n            if (output === true) return true;\n            if (output < minTotalDist) minTotalDist = output;\n            path.pop();\n            grid.reverseMove(moveRecord);\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      return minTotalDist;\n    } // TODO: consider moving functions into closure / avoid nesting for slightly better performance\n    // (no re-instantiation on each call to solveStrategically())\n    // general strategy:\n    // # rows & # columns > 3:\n    // - solve all rows but \n\n  }, {\n    key: \"solveStrategically\",\n    value: function solveStrategically() {\n      var grid = new StrategicGrid(this.numRows, this.numCols, this.tiles, this.emptyPos);\n      var moves = [];\n      var _ref2 = [grid.getTileRow(grid.emptyPos), grid.getTileCol(grid.emptyPos)],\n          emptyRow = _ref2[0],\n          emptyCol = _ref2[1]; // WARNING: does NOT update [row, col]\n\n      function move(moveList) {\n        var _iteratorNormalCompletion11 = true;\n        var _didIteratorError11 = false;\n        var _iteratorError11 = undefined;\n\n        try {\n          for (var _iterator11 = moveList[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n            var _move = _step11.value;\n            moves.push(_move);\n            grid.applyMove(_move);\n\n            switch (_move) {\n              case 'l':\n                emptyCol++;\n                break;\n\n              case 'r':\n                emptyCol--;\n                break;\n\n              case 'u':\n                emptyRow++;\n                break;\n\n              case 'd':\n                emptyRow--;\n                break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError11 = true;\n          _iteratorError11 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n              _iterator11.return();\n            }\n          } finally {\n            if (_didIteratorError11) {\n              throw _iteratorError11;\n            }\n          }\n        }\n      } // moves tile into its goal\n      // NOTE: assumes puzzle filled from top or bottom, left to right\n      // WARNING: should NOT be used for filling in columns instead of rows, as assumptions\n      // will often result in invalid moves/bad solutions\n      // should NOT be used for last 2 rows of puzzles as well, as those must be solved\n      // column by column (solving a single row leaves remaining row no room to maneuver)\n\n\n      function moveTile(ind, goalInd) {\n        if (ind === goalInd) return;\n        var _ref3 = [grid.getTileRow(grid.emptyPos), grid.getTileCol(grid.emptyPos)];\n        emptyRow = _ref3[0];\n        emptyCol = _ref3[1];\n        var _ref4 = [grid.getTileRow(ind), grid.getTileCol(ind)],\n            row = _ref4[0],\n            col = _ref4[1];\n        var _ref5 = [grid.getTileRow(goalInd), grid.getTileCol(goalInd)],\n            goalRow = _ref5[0],\n            goalCol = _ref5[1]; // moves empty out of the way of already solved tiles\n        // explanation: if empty is in row with solved tiles, it must be to their right\n        // more specifically, it will be in the goal col of the current tile\n        // if the current tile is to the left of its goal, empty will need\n        // to move left to get to its left, displacing solved tiles\n        // unless it moves down (or a tile moves up into it) first\n\n        if (col < goalCol && emptyRow === goalRow) {\n          emptyRow === grid.rowEnd - 1 ? move('d') : move('u');\n        }\n\n        while (col > goalCol) {\n          // tile needs to move left, so empty tile needs to be moved to left of tile\n          // empty needs to move out the way to get to the left side of the tile\n          if (row === emptyRow && emptyCol > col) {\n            // move empty around tile to avoid moving solved tiles\n            // if filling top, try to move around bottom of tile if possible\n            if (goalRow === grid.rowStart) {\n              row === grid.rowEnd - 1 ? move('d') : move('u');\n            } else if (goalRow === grid.rowEnd - 1) {\n              // if filling bottom, try to move around top of tile if possible\n              row === grid.rowStart ? move('u') : move('d');\n            }\n          } // move empty to col left of tile\n\n\n          while (emptyCol >= col) {\n            move('r');\n          }\n\n          while (emptyCol < col - 1) {\n            move('l');\n          } // move empty to row of tile\n\n\n          while (emptyRow > row) {\n            move('d');\n          }\n\n          while (emptyRow < row) {\n            move('u');\n          } // move tile left\n\n\n          move('l');\n          col--;\n        }\n\n        while (col < goalCol) {\n          // tile needs to move right, so empty tile needs to be moved to right of tile\n          // empty needs to move out the way to get to the right side of the tile\n          if (row === emptyRow && emptyCol < col) {\n            // move empty around tile to avoid moving solved tiles\n            // if filling top, try to move around bottom of tile if possible\n            if (goalRow === grid.rowStart) {\n              row === grid.rowEnd - 1 ? move('d') : move('u');\n            } else if (goalRow === grid.rowEnd - 1) {\n              // if filling bottom, try to move around top of tile if possible\n              row === grid.rowStart ? move('u') : move('d');\n            }\n          } // move empty to right of tile\n\n\n          while (emptyCol <= col) {\n            move('l');\n          }\n\n          while (emptyCol > col + 1) {\n            move('r');\n          } // move empty to row of tile\n\n\n          while (emptyRow > row) {\n            move('d');\n          }\n\n          while (emptyRow < row) {\n            move('u');\n          } // move tile right\n\n\n          move('r');\n          col++;\n        } // tile now in correct column\n\n\n        while (row > goalRow) {\n          // tile needs to move up, so the empty tile needs to be moved to top of tile\n          // can move up normally as long as\n          // - not last tile in row\n          // - tile is more than 2 tiles below goal\n          if (col !== grid.colEnd - 1 || row - 2 > goalRow) {\n            // if row is 1 below goal and empty is to the left or below tile\n            // empty must rotate around the bottom of the tile to get to the top\n            // so as not to displace previously placed tiles\n            if (row - 1 === goalRow && emptyCol <= col && emptyRow >= row) {\n              // move emptyRow below row\n              while (emptyRow <= row) {\n                move('u');\n              } // move emptyCol to right of tile\n\n\n              while (emptyCol <= col) {\n                move('l');\n              }\n            } // NOTE: necessary despite code block above as tile could be against wall\n            // if empty under tile, move to the right if possible\n            // to avoid displacing previously placed tiles\n\n\n            if (emptyRow > row && emptyCol === col) {\n              col === grid.colEnd - 1 ? move('r') : move('l');\n            } // move empty row to just above tile\n\n\n            while (emptyRow >= row) {\n              move('d');\n            }\n\n            while (emptyRow < row - 1) {\n              move('u');\n            } // move empty col to match tile's\n\n\n            while (emptyCol > col) {\n              move('r');\n            }\n\n            while (emptyCol < col) {\n              move('l');\n            } // move tile up\n\n\n            move('u');\n            row--;\n          } // last tile of row must be rotated in along with previous tile in row\n          // because rotating affects tiles on one side of a tile\n          // and at the last column, only the left column's tiles can be used for rotation\n          else {\n              // tile in last col and row - 2 <= goalRow\n              if (row - 1 === goalRow) {\n                // move directly into goal:\n                // if empty in goalRow, must be directly above tile\n                // as previously tiles already solved\n                if (emptyRow === goalRow) {\n                  move('u');\n                  return;\n                } else {\n                  // move tile down one to give room to maneuver previous tile \n                  // above it\n                  // NOTE: empty must be to left and/or below tile\n                  // as tile is in rightmost column and 1 space below the top\n                  // and empty is not above it\n                  // position empty below tile\n                  while (emptyRow <= row) {\n                    move('u');\n                  }\n\n                  while (emptyCol < col) {\n                    move('l');\n                  } // move tile down\n\n\n                  move('d');\n                  row++;\n                }\n              } // tile is in last col and row - 2 === goalRow\n              // move previous tile into current goal\n              // move empty around tile to get up to previous tile\n\n\n              if (emptyRow > row && emptyCol === col) move('r'); // avoid previously solved tiles while going up and around tile\n\n              while (emptyRow > goalRow + 1) {\n                move('d');\n              }\n\n              while (emptyCol < goalCol) {\n                move('l');\n              } // move empty to goal position\n\n\n              while (emptyRow > goalRow) {\n                move('d');\n              } // current state:\n              // tile 2 spaces below goal\n              // previous tiles in their goals\n              // empty tile 1 space right of previous tile (current tile's goal position)\n              // rotate last 2 tiles in row into place\n\n\n              move('rulurddlu');\n              row = goalRow;\n            }\n        }\n\n        while (row < goalRow) {\n          // tile needs to move down, so the empty tile needs to be moved to bottom of tile\n          if (col !== grid.colEnd - 1 || row + 2 < goalRow) {\n            // empty needs to move out of the way to get to the bottom of the tile\n            // as is currently to tile's top/left and needs to move to tile's bottom\n            if (row + 1 === goalRow && emptyCol <= col && emptyRow <= row) {\n              while (emptyRow >= row) {\n                move('d');\n              }\n\n              while (emptyCol <= col) {\n                move('l');\n              }\n            } // move empty around tile if in same column and empty above tile\n            // (different from above, as above only necessary if tile is too\n            // close to goal and not as good a solution when tile is farther away)\n\n\n            if (col === emptyCol && emptyRow < row) {\n              col === grid.colEnd - 1 ? move('r') : move('l');\n            } // move empty to bottom of tile\n\n\n            while (emptyRow <= row) {\n              move('u');\n            }\n\n            while (emptyRow > row + 1) {\n              move('d');\n            } // move empty to col of tile\n\n\n            while (emptyCol > col) {\n              move('r');\n            }\n\n            while (emptyCol < col) {\n              move('l');\n            } // move tile down\n\n\n            move('d');\n            row++;\n          } else {\n            // last tile of bottom row needs to be rotated in along with previous tile,\n            // similar to last tile of top row\n            // tile in correct col and either 1 or 2 spaces above goal\n            if (row + 1 === goalRow) {\n              // move tile directly into place\n              if (emptyRow === goalRow) {\n                move('d');\n                return;\n              } else {\n                // move tile up to give room for previous tile to maneuver\n                while (emptyRow >= row) {\n                  move('d');\n                }\n\n                while (emptyCol < col) {\n                  move('l');\n                }\n\n                move('u');\n                row--;\n              }\n            } // tile is now 2 spaces above goal\n            // move previous tile into current goal\n            // move empty around tile to get up to previous tile\n\n\n            if (emptyRow < row && emptyCol === col) move('r');\n\n            while (emptyRow < goalRow - 1) {\n              move('u');\n            }\n\n            while (emptyCol < goalCol) {\n              move('l');\n            } // move empty to goal position\n\n\n            while (emptyRow < goalRow) {\n              move('u');\n            } // curent state:\n            // tile 2 spaces above goal\n            // previous tiles in goal\n            // empty tile 1 space right of previous tile (current tile's goal position)\n            // rotate last 2 tiles into place\n\n\n            move('rdldruuld');\n            row = goalRow;\n          }\n        }\n      }\n\n      var emptyGoal = grid.tiles[grid.emptyPos]; // solves 1 dimensional puzzles\n\n      if (grid.numRows === 1) {\n        while (grid.emptyPos < emptyGoal) {\n          move('l');\n        }\n\n        while (grid.emptyPos > emptyGoal) {\n          move('r');\n        }\n\n        return moves;\n      } else if (grid.numCols === 1) {\n        while (grid.emptyPos < emptyGoal) {\n          move('u');\n        }\n\n        while (grid.emptyPos > emptyGoal) {\n          move('d');\n        }\n\n        return moves;\n      }\n\n      var emptyGoalRow = grid.getTileRow(emptyGoal);\n      var emptyGoalCol = grid.getTileCol(emptyGoal); // fill each row left to right, top to bottom until empty tile's row reach\n      // or 2 rows remaining\n\n      for (var row = 0; row < Math.min(emptyGoalRow, grid.numRows - 2); row++) {\n        var start = grid.numCols * row;\n\n        for (var goal = start; goal < start + grid.numCols; goal++) {\n          var ind = grid.goals[goal];\n          moveTile(ind, goal);\n        }\n\n        grid.rowStart++;\n      }\n\n      for (var _row3 = grid.numRows - 1; _row3 > emptyGoalRow + 1; _row3--) {\n        var _start = grid.numCols * _row3;\n\n        for (var _goal = _start; _goal < _start + grid.numCols; _goal++) {\n          var _ind = grid.goals[_goal];\n          moveTile(_ind, _goal);\n        }\n\n        grid.rowEnd--;\n      } // remaining unsolved puzzle is now 2xN (where N is arbitrary integer)\n\n\n      console.log(grid.rowStart, grid.rowEnd, grid.colStart, grid.colEnd);\n      console.log(moves);\n      var emptyColGoal = grid.getTileCol(grid.tiles[grid.emptyPos]); // fill in from left to right until empty tile col reached or 2x2 square remaining\n\n      for (var col = 0; col < Math.min(grid.numCols - 2, emptyColGoal); col++) {\n        // goal and current indices of top tile of leftmost column\n        var topGoal = grid.getIndex(grid.rowStart, grid.colStart);\n        var topInd = grid.goals[topGoal]; // move top tile to its goal\n\n        moveTile(topInd, topGoal); // goal and current indices of bottom tile of leftmost column\n\n        var bottomGoal = topGoal + grid.numCols;\n        var bottomInd = grid.goals[bottomGoal];\n\n        if (bottomInd === bottomGoal) {\n          grid.colStart++;\n          continue;\n        } // current coords of tile that belongs on the bottom of the leftmost column\n\n\n        var bottomCol = grid.getTileCol(bottomInd);\n        var bottomRow = grid.getTileRow(bottomInd); // top tile is occupied, so emptyCol must be in bottom left corner\n        // if bottom tile is one away, can move directly into goal\n\n        if (emptyCol === grid.colStart && grid.emptyPos + 1 === bottomInd) {\n          move('l');\n          grid.colStart++;\n          continue;\n        } // Otherwise:\n        // tile needs to be rotated in similarly to top and bottom tiles\n        // cannot use moveTile() as above, as certain assumptions on\n        // fill order no longer hold true\n        // move bottom tile to 2 spaces right of its goal\n        // first move tile into bottom row\n\n\n        while (bottomRow < grid.rowEnd - 1) {\n          // move into bottom row\n          if (emptyRow === grid.rowStart) move('u'); // move below tile\n\n          while (emptyCol > bottomCol) {\n            move('r');\n          }\n\n          while (emptyCol < bottomCol) {\n            move('l');\n          } // move tile into bottom row\n\n\n          move('d');\n          bottomRow++;\n        } // then move tile into correct col\n        // tile is more than 2 spaces right from final goal\n\n\n        while (bottomCol > col + 2) {\n          // move empty around tile to get to its left if necessary\n          if (emptyRow === bottomRow && emptyCol > bottomCol) move('d');\n\n          while (emptyCol >= bottomCol) {\n            move('r');\n          }\n\n          if (emptyRow < bottomRow) move('u');\n\n          while (emptyCol < bottomCol) {\n            move('l');\n          }\n\n          bottomCol--;\n        } // tile is one right of final goal (1 tile left of intermediate goal)\n\n\n        while (bottomCol < col + 2) {\n          // maneuver empty to right of goal\n          if (emptyCol === bottomCol) move('l');\n          if (emptyRow === grid.rowStart) move('u'); // move bottom col one right\n\n          while (emptyCol > bottomCol) {\n            move('r');\n          }\n\n          bottomCol++;\n        } // tile is now 2 spaces right of goal\n        // need to move top tile one down in preparation for rotating 2 tiles in\n        // move around tile to get below top tile if necessary\n\n\n        if (emptyCol > bottomCol && emptyRow === bottomRow) move('d');\n\n        while (emptyCol >= bottomCol) {\n          move('r');\n        }\n\n        if (emptyRow === grid.rowStart) move('u');\n\n        while (emptyCol > grid.colStart) {\n          move('r');\n        } // current state:\n        // empty tile in bottom goal\n        // top tile in top goal\n        // bottom tile 2 tiles right of bottom goal\n        // rotate both tiles into place\n\n\n        move('dluldrrul');\n        grid.colStart++;\n      } // // fill in from right to left until 2x2 square remaining\n\n\n      for (var _col3 = grid.numCols - 1; _col3 > emptyColGoal + 1; _col3--) {\n        // goal and current indices of top tile of leftmost column\n        var _topGoal = grid.getIndex(grid.rowStart, grid.colEnd - 1);\n\n        var _topInd = grid.goals[_topGoal]; // move top tile to its goal\n        // NOTE: can't use moveTile as relies on assumptions like:\n        // tiles to left in goalRow are filled in and can't be modified\n        // modifying moveTile() to work with right-to-left would\n        // make the function more confusing\n\n        var topCol = grid.getTileCol(_topInd);\n        var topRow = grid.getTileRow(_topInd); // move top tile into correct row\n\n        if (topRow > grid.rowStart) {\n          if (emptyRow === grid.rowEnd - 1) move('d');\n\n          while (emptyCol < topCol) {\n            move('l');\n          }\n\n          while (emptyCol > topCol) {\n            move('r');\n          }\n\n          move('u');\n          topRow--;\n        } // move top tile into correct col\n\n\n        while (topCol < grid.colEnd - 1) {\n          // move empty around tile to get to right if necessary\n          if (emptyCol < topCol && emptyRow === topRow) move('u');\n\n          while (emptyCol <= topCol) {\n            move('l');\n          }\n\n          while (emptyCol > topCol + 1) {\n            move('r');\n          }\n\n          if (emptyRow > topRow) move('d');\n          move('r');\n          topCol++;\n        } // goal and current indices of bottom tile of leftmost column\n\n\n        var _bottomGoal = _topGoal + grid.numCols;\n\n        var _bottomInd = grid.goals[_bottomGoal];\n\n        if (_bottomInd === _bottomGoal) {\n          grid.colEnd--;\n          continue;\n        } // current coords of tile that belongs on the bottom of the leftmost column\n\n\n        var _bottomCol = grid.getTileCol(_bottomInd);\n\n        var _bottomRow = grid.getTileRow(_bottomInd); // top tile is occupied, so emptyCol must be in bottom right corner\n        // if bottom tile is one away, can move directly into goal\n\n\n        if (emptyCol === grid.colEnd - 1 && grid.emptyPos - 1 === _bottomInd) {\n          move('r');\n          grid.colEnd--;\n          continue;\n        } // move bottom tile 2 tiles left of goal in preparation of rotating 2 tiles in\n        // first move tile into bottom row\n\n\n        while (_bottomRow < grid.rowEnd - 1) {\n          // move into bottom row\n          if (emptyRow === grid.rowStart) move('u'); // move below tile\n\n          while (emptyCol > _bottomCol) {\n            move('r');\n          }\n\n          while (emptyCol < _bottomCol) {\n            move('l');\n          } // move tile into bottom row\n\n\n          move('d');\n          _bottomRow++;\n        } // then move tile into correct col\n        // tile is more than 2 spaces left from final goal\n\n\n        while (_bottomCol < _col3 - 2) {\n          // move empty around tile to get to its right if necessary\n          if (emptyRow === _bottomRow && emptyCol < _bottomCol) move('d');\n\n          while (emptyCol <= _bottomCol) {\n            move('l');\n          }\n\n          if (emptyRow < _bottomRow) move('u');\n\n          while (emptyCol > _bottomCol) {\n            move('r');\n          }\n\n          _bottomCol++;\n        } // tile is one left of final goal (1 tile right of intermediate goal)\n\n\n        while (_bottomCol > _col3 - 2) {\n          // maneuver empty to right of goal\n          if (emptyCol === _bottomCol) move('r');\n          if (emptyRow === grid.rowStart) move('u'); // move bottom col one right\n\n          while (emptyCol < _bottomCol) {\n            move('l');\n          }\n\n          _bottomCol--;\n        } // tile is now 2 spaces left of goal\n        // need to move top tile one down in preparation for rotating 2 tiles in\n        // move around tile to get below top tile if necessary\n\n\n        if (emptyCol < _bottomCol && emptyRow === _bottomRow) move('d');\n\n        while (emptyCol <= _bottomCol) {\n          move('l');\n        }\n\n        if (emptyRow === grid.rowStart) move('u');\n\n        while (emptyCol < grid.colEnd - 1) {\n          move('l');\n        } // current state:\n        // empty tile in bottom goal\n        // top tile in top goal\n        // bottom tile 2 tiles left of bottom goal\n        // rotate both tiles into place\n\n\n        move('drurdllur');\n        grid.colEnd--;\n      } // solve remaining 2x2 puzzle\n      // Once 2 tiles (including empty) are solved, \n      // remaining 2 must be already solved if puzzle is solvable\n      // NOTE: moveTile is only used for top-left and bottom-left tiles\n      // as fill-order assumptions mean using it for tiles on the right\n      // won't work\n\n\n      var topLeftGoal = grid.getIndex(grid.rowStart, grid.colStart);\n\n      if (topLeftGoal !== emptyGoal) {\n        // solve top-left tile\n        moveTile(grid.goals[topLeftGoal], topLeftGoal); // if empty needs to move left, its goal is bottom-left tile\n\n        if (emptyCol > emptyGoalCol) {\n          if (emptyRow < emptyGoalRow) move('u');\n          move('r');\n        }\n\n        if (emptyCol < emptyGoalCol) move('l');\n        if (emptyRow > emptyGoalRow) move('d');\n        if (emptyRow < emptyGoalRow) move('u');\n      }\n\n      var bottomLeftGoal = topLeftGoal + grid.numCols;\n\n      if (bottomLeftGoal !== emptyGoal) {\n        // solve bottom-left tile\n        moveTile(grid.goals[bottomLeftGoal], bottomLeftGoal); // if empty needs to move left, its goal is top-left tile\n\n        if (emptyCol > emptyGoalCol) {\n          if (emptyRow > emptyGoalRow) move('d');\n          move('r');\n        }\n\n        if (emptyCol < emptyGoalCol) move('l');\n        if (emptyRow > emptyGoalRow) move('d');\n        if (emptyRow < emptyGoalRow) move('u');\n      }\n\n      return moves;\n    }\n  }]);\n\n  return Puzzle;\n}();\n\nvar BaseGrid =\n/*#__PURE__*/\nfunction () {\n  function BaseGrid(numRows, numCols, tiles, emptyPos) {\n    _classCallCheck(this, BaseGrid);\n\n    this.numRows = numRows;\n    this.numCols = numCols;\n    this.tiles = tiles;\n    this.emptyPos = emptyPos;\n  }\n\n  _createClass(BaseGrid, [{\n    key: \"getTileCol\",\n    value: function getTileCol(ind) {\n      return ind % this.numCols;\n    }\n  }, {\n    key: \"getTileRow\",\n    value: function getTileRow(ind) {\n      return Math.floor(ind / this.numCols);\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(row, col) {\n      return row * this.numCols + col;\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(pos1, pos2) {\n      var _ref6 = [this.tiles[pos2], this.tiles[pos1]];\n      this.tiles[pos1] = _ref6[0];\n      this.tiles[pos2] = _ref6[1];\n    } // returns change in index of tile to be moved after move\n\n  }, {\n    key: \"getMoveDelta\",\n    value: function getMoveDelta(move) {\n      var moveDeltaMap = {\n        'r': 1,\n        'l': -1,\n        'u': -this.numCols,\n        'd': this.numCols\n      };\n      return moveDeltaMap[move];\n    } // TODO: consider instead caching movedInd for every move + emptyPos combo O(n)\n    // returns index of tile that would be moved by specified move\n\n  }, {\n    key: \"getMovedInd\",\n    value: function getMovedInd(move) {\n      return this.emptyPos - this.getMoveDelta(move);\n    }\n  }, {\n    key: \"applyMove\",\n    value: function applyMove(move) {\n      var movedInd = this.getMovedInd(move);\n      var endInd = this.emptyPos;\n      this.swap(endInd, movedInd);\n      this.emptyPos = movedInd;\n    }\n  }], [{\n    key: \"getReversedMove\",\n    value: function getReversedMove(move) {\n      return REVERSE_MOVE_MAP[move];\n    }\n  }]);\n\n  return BaseGrid;\n}(); // Grid optimized for strategic solver\n\n\nvar StrategicGrid =\n/*#__PURE__*/\nfunction (_BaseGrid) {\n  _inherits(StrategicGrid, _BaseGrid);\n\n  function StrategicGrid(numRows, numCols, tiles, emptyPos) {\n    var _this;\n\n    _classCallCheck(this, StrategicGrid);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StrategicGrid).call(this, numRows, numCols, tiles, emptyPos)); // maps goal index to current index\n    // ex: arr[0] = 2 -> tile with goal index 0 is now at index 2\n\n    _this.goals = tiles.length > 256 ? new Uint16Array(tiles.length) : new Uint8Array(tiles.length);\n\n    _this.tiles.forEach(function (goal, ind) {\n      return _this.goals[goal] = ind;\n    }); // marks bounds of unsolved grid (start inclusive, end exclusive)\n    // NOTE: bounds do NOT affect any tile positions/indices\n    // i.e. indices/rows/cols are the same as if no bounds exist\n\n\n    _this.rowStart = 0;\n    _this.rowEnd = numRows;\n    _this.colStart = 0;\n    _this.colEnd = numCols;\n    _this.colBounds = [0, numCols];\n    return _this;\n  }\n\n  _createClass(StrategicGrid, [{\n    key: \"swap\",\n    value: function swap(pos1, pos2) {\n      // each goal position now corresponds with the opposite tile's swapped position\n      var _ref7 = [pos2, pos1];\n      this.goals[this.tiles[pos1]] = _ref7[0];\n      this.goals[this.tiles[pos2]] = _ref7[1];\n\n      _get(_getPrototypeOf(StrategicGrid.prototype), \"swap\", this).call(this, pos1, pos2);\n    }\n  }]);\n\n  return StrategicGrid;\n}(BaseGrid); // TODO: consider moving validMoves to field of Class instead of instance\n// (indexed under grid dimensions)\n// TODO: consider having both this and graphical grid extend from BaseGrid to reuse move functions\n// pros: cleaner, less redundancy\n// cons: performance hit as called functions now have to move up prototype chain\n// (not a huge problem for strategic solver, but IDA* explores a lot more nodes)\n// Grid optimized for A* and IDA*\n\n\nvar Grid =\n/*#__PURE__*/\nfunction () {\n  function Grid(numRows, numCols, tiles, emptyPos, heuristic, traveledDist) {\n    var heuristicValue = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    var lastMove = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    var lastGrid = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n    var validMoves = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n\n    _classCallCheck(this, Grid);\n\n    this.numRows = numRows;\n    this.numCols = numCols;\n    this.tiles = tiles;\n    this.emptyPos = emptyPos;\n    this.heuristic = heuristic;\n    this.traveledDist = traveledDist;\n    this.heuristicValue = heuristicValue === null ? heuristic.calculate(this) : heuristicValue;\n    this.lastMove = lastMove;\n    this.lastGrid = lastGrid; // TODO: attach to external obj or pass between grids to avoid recomputing every new grid\n    // precomputing values for better performance\n    // IDEA: do all precomputing inside Puzzle() to be referenced by Grid\n    // (passing along takes up memory)\n\n    this.validMoves = validMoves === null ? this._precomputeValidMoves() : validMoves;\n  }\n\n  _createClass(Grid, [{\n    key: \"getTileCol\",\n    value: function getTileCol(ind) {\n      return ind % this.numCols;\n    }\n  }, {\n    key: \"getTileRow\",\n    value: function getTileRow(ind) {\n      return Math.floor(ind / this.numCols);\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(row, col) {\n      return row * this.numCols + col;\n    } // returns change in index of tile to be moved after move\n\n  }, {\n    key: \"getMoveDelta\",\n    value: function getMoveDelta(move) {\n      var moveDeltaMap = {\n        'r': 1,\n        'l': -1,\n        'u': -this.numCols,\n        'd': this.numCols\n      };\n      return moveDeltaMap[move];\n    } // TODO: consider instead caching movedInd for every move + emptyPos combo O(n)\n    // returns index of tile that would be moved by specified move\n\n  }, {\n    key: \"getMovedInd\",\n    value: function getMovedInd(move) {\n      return this.emptyPos - this.getMoveDelta(move);\n    }\n  }, {\n    key: \"getTileDist\",\n    value: function getTileDist(tile1, tile2) {\n      return Math.abs(this.getTileRow(tile1) - this.getTileRow(tile2)) + Math.abs(this.getTileCol(tile1) - this.getTileCol(tile2));\n    }\n  }, {\n    key: \"reconstructPath\",\n    value: function reconstructPath() {\n      var path = [];\n      var curr = this;\n\n      while (curr.lastMove !== null) {\n        path.unshift(curr.lastMove);\n        curr = curr.lastGrid;\n      }\n\n      return path;\n    }\n    /**\n     * returns deep copy of grid ignoring lastGrid (null)\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Grid(this.numRows, this.numCols, this.tiles.slice(), this.emptyPos, this.heuristic, this.traveledDist, this.heuristicValue, this.lastMove, null, this.validMoves);\n    }\n    /**\n     * returns copy of current grid with specified directional move applied to tile moving into empty position\n     * also updates all affected Grid fields in new Grid (emptyPos, heuristic/travel distance, etc.)\n     * @param move direction to move tile into empty space\n     * @return returns copy of current grid with specified move applied to tile into empty position\n     */\n\n  }, {\n    key: \"cloneAndApplyMove\",\n    value: function cloneAndApplyMove(move) {\n      var newGrid = this.clone();\n      newGrid.lastGrid = this;\n      newGrid.lastMove = move;\n      return Grid._applyMoveHelper(move, newGrid);\n    } // Applies move to grid NOT clone on grid\n    // Returns moveRecord object storing old heuristicValue and emptyPos (for use in reverseMove())\n    // (useful for IDA* as memory allocation can be avoided)\n    // NOTE: separate function instead of consolidation with \"clone\" param for slightly better performance\n    // NOTE: does NOT update lastMove or lastGrid\n\n  }, {\n    key: \"applyMove\",\n    value: function applyMove(move) {\n      var oldHeuristicValue = this.heuristicValue;\n      var oldEmptyPos = this.emptyPos;\n\n      Grid._applyMoveHelper(move, this); // TODO; consider changing to typedArray for slightly better performance\n\n\n      return {\n        heuristicValue: oldHeuristicValue,\n        emptyPos: oldEmptyPos\n      };\n    }\n  }, {\n    key: \"reverseMove\",\n    value: function reverseMove(moveRecord) {\n      this.traveledDist--;\n      this.heuristicValue = moveRecord.heuristicValue;\n      this.swap(this.emptyPos, moveRecord.emptyPos);\n      this.emptyPos = moveRecord.emptyPos;\n    } // applies move to specified grid WITHOUT updating lastMove or lastGrid\n\n  }, {\n    key: \"swap\",\n\n    /**\n     * WARNING: Does NOT update heuristicValue, lastMove, emptyPos, or lastGrid\n     * swaps 2 positions in grid.\n     */\n    value: function swap(pos1, pos2) {\n      var _ref8 = [this.tiles[pos2], this.tiles[pos1]];\n      this.tiles[pos1] = _ref8[0];\n      this.tiles[pos2] = _ref8[1];\n    } // precomputes valid moves for each possible emptyPos to give slight performance benefit\n\n  }, {\n    key: \"_precomputeValidMoves\",\n    value: function _precomputeValidMoves() {\n      var moves;\n      var validMoves = [];\n\n      for (var emptyPos = 0; emptyPos < this.tiles.length; emptyPos++) {\n        moves = [];\n        var row = this.getTileRow(emptyPos);\n        var col = this.getTileCol(emptyPos);\n\n        if (row < this.numRows - 1) {\n          moves.push('u');\n        }\n\n        if (row > 0) {\n          moves.push('d');\n        }\n\n        if (col < this.numCols - 1) {\n          moves.push('l');\n        }\n\n        if (col > 0) {\n          moves.push('r');\n        }\n\n        validMoves[emptyPos] = moves;\n      }\n\n      return validMoves;\n    }\n    /**\n     * returns array of valid moves, where 'l' = left, 'r' = right, 'd' = down, and 'u' = up.\n     * @returns {Array} array of valid moves, where moves are defined by tiles moving into the empty space in the grid\n     */\n\n  }, {\n    key: \"getValidMoves\",\n    value: function getValidMoves() {\n      return this.validMoves[this.emptyPos];\n    }\n    /**\n     * Returns whether grid is solved assuming goal is [0, 1, ... tiles.length - 1]\n     * @returns {boolean} whether puzzle is solved\n     */\n\n  }, {\n    key: \"isSolved\",\n    value: function isSolved() {\n      if (this.heuristic.isSolved(this.heuristicValue)) return true; // accounts for if can't determine if puzzle solved using heuristic value\n\n      return this.tiles.every(function (goalInd, ind) {\n        return goalInd === ind;\n      });\n    }\n  }], [{\n    key: \"getReversedMove\",\n    value: function getReversedMove(move) {\n      return REVERSE_MOVE_MAP[move];\n    }\n  }, {\n    key: \"_applyMoveHelper\",\n    value: function _applyMoveHelper(move, grid) {\n      var movedInd = grid.getMovedInd(move);\n      var endInd = grid.emptyPos;\n      grid.swap(endInd, movedInd);\n      grid.emptyPos = movedInd;\n      grid.traveledDist++;\n      grid.heuristicValue = grid.heuristic.update(grid, movedInd, endInd, move);\n      return grid;\n    }\n  }]);\n\n  return Grid;\n}();\n\nfunction testLinearConflictHeuristic() {\n  var testCases = [[[0, 2, 1, 7, 4, 5, 6, 3, 8], 0], [[0, 2, 1, 5, 4, 3, 6, 7, 8], 0], [[4, 3, 6, 8, 0, 7, 5, 2, 1], 4], [[2, 7, 0, 5, 4, 3, 8, 1, 6], 2]];\n  var ans = [8, 12, 22, 24];\n  var _iteratorNormalCompletion12 = true;\n  var _didIteratorError12 = false;\n  var _iteratorError12 = undefined;\n\n  try {\n    for (var _iterator12 = testCases.entries()[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n      var _step12$value = _slicedToArray(_step12.value, 2),\n          ind = _step12$value[0],\n          testCase = _step12$value[1];\n\n      var testGrid = _construct(Grid, [3, 3].concat(_toConsumableArray(testCase), [new LinearConflictHeuristic(3, 3), 0]));\n\n      console.assert(testGrid.heuristicValue === ans[ind], \"incorrect answer: answer = \".concat(testGrid.heuristicValue, \", correct answer = \").concat(ans[ind]));\n    }\n  } catch (err) {\n    _didIteratorError12 = true;\n    _iteratorError12 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n        _iterator12.return();\n      }\n    } finally {\n      if (_didIteratorError12) {\n        throw _iteratorError12;\n      }\n    }\n  }\n} // TODO: remove after done testing\n// testLinearConflictHeuristic();\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Puzzle);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2xpZGluZy1wdXp6bGUtYWxnb3JpdGhtcy5qcz9iMTE5Il0sIm5hbWVzIjpbIlJFVkVSU0VfTU9WRV9NQVAiLCJNYW5oYXR0YW5IZXVyaXN0aWMiLCJudW1Sb3dzIiwibnVtQ29scyIsIm51bVRpbGVzIiwiX3ByZWNvbXB1dGUiLCJtb3ZlTnVtYmVyTWFwIiwiX21kIiwibmRhcnJheSIsIlVpbnQxNkFycmF5IiwiX21kRGVsdGEiLCJJbnQ4QXJyYXkiLCJtb3ZlRGVsdGFNYXAiLCJJbnQxNkFycmF5IiwiZnJvbSIsImluZCIsImdvYWxJbmQiLCJyb3cxIiwiY29sMSIsInJvdzIiLCJjb2wyIiwic2V0IiwiTWF0aCIsImFicyIsInN0YXJ0TUQiLCJnZXQiLCJtb3ZlIiwiZW5kTUQiLCJncmlkIiwiZGlzdCIsImkiLCJ0aWxlcyIsImxlbmd0aCIsImVtcHR5UG9zIiwiZ2V0VGlsZURpc3QiLCJuZXdHcmlkIiwic3RhcnRJbmQiLCJlbmRJbmQiLCJnZXRVcGRhdGVEZWx0YSIsImhldXJpc3RpY1ZhbHVlIiwiZ29hbFJvdyIsImdldFRpbGVSb3ciLCJnb2FsQ29sIiwiZ2V0VGlsZUNvbCIsInN0YXJ0Um93Iiwic3RhcnRDb2wiLCJlbmRSb3ciLCJlbmRDb2wiLCJMaW5lYXJDb25mbGljdEhldXJpc3RpYyIsIm4iLCJtYXgiLCJfbGMiLCJBcnJheSIsInBlcm1TaXplIiwiVWludDhBcnJheSIsImZpbGwiLCJfcGVybXV0YXRpb25IZWxwZXIiLCJwZXJtIiwiX2NhbGN1bGF0ZSIsImFyciIsInJhbmdlIiwicGVybXV0YXRpb25HZW5lcmF0b3IiLCJtYXAiLCJNYXAiLCJjb25mbGljdHMiLCJTZXQiLCJfY2FsY3VsYXRlRm9yTWFwIiwiY2FuZGlkYXRlVGlsZXMiLCJyb3ciLCJjb2wiLCJnZXRJbmRleCIsImhhcyIsInB1c2giLCJrZXkiLCJlbnRyaWVzIiwic2l6ZSIsImluZDEiLCJnb2FsSW5kMSIsImNvbmZsaWN0czEiLCJpbmQyIiwiZ29hbEluZDIiLCJjb25mbGljdHMyIiwiYWRkIiwiY29uZmxpY3RUcmVlIiwiQVZMVHJlZSIsImEiLCJiIiwiZGlmZiIsImluc2VydCIsInRpbGUiLCJyZW1vdmUiLCJjb25mbGljdCIsImNvcnJDb25mbGljdHMiLCJjb3JyT2JqIiwiZGVsZXRlIiwic3RhcnRWYWwiLCJlbmRWYWwiLCJmdW5jIiwiaW5kcyIsIl9jYWxjdWxhdGVGb3JDb2wiLCJfY2FsY3VsYXRlRm9yUm93IiwiY2FsbCIsInN3YXAiLCJQdXp6bGUiLCJoZXVyaXN0aWMiLCJzb2x2ZXIiLCJoZXVyaXN0aWNDbGFzcyIsIm1heEl0ZXJhdGlvbnMiLCJzb2x2ZUFTdGFyIiwic29sdmVJREFTdGFyIiwic29sdmVTdHJhdGVnaWNhbGx5IiwiRXJyb3IiLCJxIiwiRmFzdFByaW9yaXR5UXVldWUiLCJncmlkMSIsImdyaWQyIiwidG90YWwxIiwidHJhdmVsZWREaXN0IiwidG90YWwyIiwiR3JpZCIsImN1cnIiLCJiZXN0IiwiaXRlcmF0aW9ucyIsInBvbGwiLCJpc1NvbHZlZCIsImNvbnNvbGUiLCJsb2ciLCJyZWNvbnN0cnVjdFBhdGgiLCJnZXRWYWxpZE1vdmVzIiwiZ2V0UmV2ZXJzZWRNb3ZlIiwibGFzdE1vdmUiLCJjbG9uZUFuZEFwcGx5TW92ZSIsInNjb3JlIiwidG9TdHJpbmciLCJib3VuZCIsInBhdGgiLCJvdXRwdXQiLCJfc2VhcmNoSURBU3RhciIsIkluZmluaXR5IiwidG90YWxEaXN0IiwibWluVG90YWxEaXN0IiwibW92ZVJlY29yZCIsImFwcGx5TW92ZSIsInBvcCIsInJldmVyc2VNb3ZlIiwiU3RyYXRlZ2ljR3JpZCIsIm1vdmVzIiwiZW1wdHlSb3ciLCJlbXB0eUNvbCIsIm1vdmVMaXN0IiwibW92ZVRpbGUiLCJyb3dFbmQiLCJyb3dTdGFydCIsImNvbEVuZCIsImVtcHR5R29hbCIsImVtcHR5R29hbFJvdyIsImVtcHR5R29hbENvbCIsIm1pbiIsInN0YXJ0IiwiZ29hbCIsImdvYWxzIiwiY29sU3RhcnQiLCJlbXB0eUNvbEdvYWwiLCJ0b3BHb2FsIiwidG9wSW5kIiwiYm90dG9tR29hbCIsImJvdHRvbUluZCIsImJvdHRvbUNvbCIsImJvdHRvbVJvdyIsInRvcENvbCIsInRvcFJvdyIsInRvcExlZnRHb2FsIiwiYm90dG9tTGVmdEdvYWwiLCJCYXNlR3JpZCIsImZsb29yIiwicG9zMSIsInBvczIiLCJnZXRNb3ZlRGVsdGEiLCJtb3ZlZEluZCIsImdldE1vdmVkSW5kIiwiZm9yRWFjaCIsImNvbEJvdW5kcyIsImxhc3RHcmlkIiwidmFsaWRNb3ZlcyIsImNhbGN1bGF0ZSIsIl9wcmVjb21wdXRlVmFsaWRNb3ZlcyIsInRpbGUxIiwidGlsZTIiLCJ1bnNoaWZ0Iiwic2xpY2UiLCJjbG9uZSIsIl9hcHBseU1vdmVIZWxwZXIiLCJvbGRIZXVyaXN0aWNWYWx1ZSIsIm9sZEVtcHR5UG9zIiwiZXZlcnkiLCJ1cGRhdGUiLCJ0ZXN0TGluZWFyQ29uZmxpY3RIZXVyaXN0aWMiLCJ0ZXN0Q2FzZXMiLCJhbnMiLCJ0ZXN0Q2FzZSIsInRlc3RHcmlkIiwiYXNzZXJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQSxJQUFNQSxnQkFBZ0IsR0FBRztBQUNyQixPQUFLLEdBRGdCO0FBRXJCLE9BQUssR0FGZ0I7QUFHckIsT0FBSyxHQUhnQjtBQUlyQixPQUFLLEdBSmdCLENBT3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFoQnlCLENBQXpCOztJQWlCTUMsa0I7OztBQUVGLDhCQUFZQyxPQUFaLEVBQXFCQyxPQUFyQixFQUE4QjtBQUFBOztBQUMxQixTQUFLRCxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxRQUFMLEdBQWdCRixPQUFP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QUFzQixDQUF0QixDQUhjLEVBSWQsQ0FBQyxDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssQ0FBTCxFQUFPLENBQVAsRUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZSxDQUFmLEVBQWlCLENBQWpCLENBQUQsRUFBc0IsQ0FBdEIsQ0FKYyxDQUFsQjtBQU1BLE1BQU1DLEdBQUcsR0FBRyxDQUFDLENBQUQsRUFBSSxFQUFKLEVBQVEsRUFBUixFQUFZLEVBQVosQ0FBWjtBQVBtQztBQUFBO0FBQUE7O0FBQUE7QUFTbkMsMkJBQTRCRCxTQUFTLENBQUMzSCxPQUFWLEVBQTVCLHdJQUFpRDtBQUFBO0FBQUEsVUFBdkMzRCxHQUF1QztBQUFBLFVBQWxDd0wsUUFBa0M7O0FBQzdDLFVBQUlDLFFBQVEsY0FBT2pGLElBQVAsR0FBWSxDQUFaLEVBQWUsQ0FBZiw0QkFBcUJnRixRQUFyQixJQUErQixJQUFJdkosdUJBQUosQ0FBNEIsQ0FBNUIsRUFBK0IsQ0FBL0IsQ0FBL0IsRUFBa0UsQ0FBbEUsR0FBWjs7QUFDQTZFLGFBQU8sQ0FBQzRFLE1BQVIsQ0FBZUQsUUFBUSxDQUFDakssY0FBVCxLQUE0QitKLEdBQUcsQ0FBQ3ZMLEdBQUQsQ0FBOUMsdUNBQ2tDeUwsUUFBUSxDQUFDakssY0FEM0MsZ0NBQytFK0osR0FBRyxDQUFDdkwsR0FBRCxDQURsRjtBQUVIO0FBYmtDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFjdEMsQyxDQUVEO0FBQ0E7OztBQUdld0YscUVBQWYiLCJmaWxlIjoiLi9zcmMvc2xpZGluZy1wdXp6bGUtYWxnb3JpdGhtcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIE9wZXJhdG9yIHByZS1jb21wdXRhdGlvbiwgaW4tcGxhY2UgbW9kaWZpY2F0aW9uIG9mIGdyaWQgc3RhdGUgZm9yIGlkYSogYmFzZWQgb25cbi8vIFwiSW1wbGVtZW50aW5nIEZhc3QgSGV1cmlzdGljIFNlYXJjaCBDb2RlXCJcbi8vIGJ5IEV0aGFuIEJ1cm5zIGFuZCBNYXR0aGV3IEhhdGVtIGFuZCBNaWNoYWVsIEouIExlaWdodG9uIGFuZCBXaGVlbGVyIFJ1bWxcblxuLy8gTGluZWFyIGNvbmZsaWN0IGhldXJpc3RpYyBiYXNlZCBvblxuLy8gXCJDcml0aWNpemluZyBTb2x1dGlvbnMgdG8gUmVsYXhlZCBNb2RlbHMgWWllbGRzIFBvd2VyZnVsIEFkbWlzc2libGUgSGV1cmlzdGljc1wiXG4vLyBieSBPdGhhciBIYW5zc29uIGFuZCBBbmRyZXcgTWF5ZXJcblxuLy8gVE9ETzogbW9kaWZ5IHJlYWRtZSB0byBleHBsYWluIGhvdyB0byB1c2Ugbm9kZSArIHdlYnBhY2sgKyBiYWJlbFxuXG4vLyBUT0RPOiB3cml0ZSBmdW5jdGlvbiB0byB0aW1lIHBlcmZvcm1hbmNlIG9mIGRpZmZlcmVudCBhbGcraGV1cmlzdGljIGNvbWJvc1xuXG4vLyBUT0RPOiBmaXggZnJlZXplIHdoZW4gc29sdmluZyBzb21lIDV4NCBwdXp6bGVzIChhbmQgcHJlc3VtYWJseSB0aG9zZSBsYXJnZXIgdGhhbiB0aGF0KSB1c2luZyBBKlxuLy8gaXRlcmF0aW9uIGxpbWl0IHNob3VsZCB3b3JrLCBidXQgbm90IHdvcmtpbmcgYW5kL29yIGl0ZXJhdGlvbnMgdGFraW5nIHN1YnN0YW50aWFsbHkgbW9yZSBtZW1vcnkgKyBsb25nZXJcblxuaW1wb3J0IEZhc3RQcmlvcml0eVF1ZXVlIGZyb20gJ2Zhc3Rwcmlvcml0eXF1ZXVlJ1xuaW1wb3J0IG5kYXJyYXkgZnJvbSAnbmRhcnJheSdcbmltcG9ydCBBVkxUcmVlIGZyb20gJ2F2bCdcblxuaW1wb3J0IHtyYW5nZSwgcGVybXV0YXRpb25HZW5lcmF0b3J9IGZyb20gJy4vbWF0aC11dGlscydcbmltcG9ydCByZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSAncmVnZW5lcmF0b3ItcnVudGltZSdcblxuY29uc3QgUkVWRVJTRV9NT1ZFX01BUCA9IHtcbiAgICAncic6ICdsJyxcbiAgICAnbCc6ICdyJyxcbiAgICAnZCc6ICd1JyxcbiAgICAndSc6ICdkJ1xufVxuXG4vLyBUT0RPOiBpZiB1c2luZyBwYXR0ZXJuIGRhdGFiYXNlLCBjb25zaWRlciBlbmNvZGluZyBwYXR0ZXJuIG51bWJlcnMgaW50byBieXRlcyBhbmQgc3RvcmluZyBpbiBpbnRcbi8vIHByb2JhYmx5IHVzZSA2LTYtMyBwYXR0ZXJuIGRhdGFiYXNlICh3aGlsZSBub3QgZmFzdGVzdCwgdGFrZXMgdXAgbW9kZXJhdGUgYW1vdW50IG9mIG1lbW9yeSlcbi8vIGNvbnNpZGVyIHVzaW5nIEluZGV4ZWREQiBmb3IgZGIgc3RvcmFnZVxuLy8gcHJvczogc2ltcGxlLCB3ZWxsLXN1cHBvcnRlZFxuLy8gY29uczogcHJvYmFibHkgc2xvd2VyIHRoYW4gbG9hZGluZyBNYXAgaW50byBtZW1vcnlcbi8vIGFsdGVybmF0aXZlOiBsb29rIGludG8gc3RvcmluZyBkYiBhcyBieXRlcywgcmVhZCB3aG9sZSBkYiBpbnRvIG1lbW9yeSBhdCBzdGFydCBhbmQgcXVlcnkgZnJvbSB0aGVyZVxuLy8gVE9ETzogbm90ZSB0aGF0IHBhdHRlcm4gZGJzIHdpbGwgbWFrZSBpdCBkaWZmaWN1bHQgdG8gYWxsb3cgbm9uLXNxdWFyZSBwdXp6bGVzIHdpdGggZGltZW5zaW9ucyA+IDRcblxuLy8gTk9URTogbWV0aG9kcyBub3Qgc3RhdGljIHRvIHN1cHBvcnQgdXNpbmcgY2FjaGVkIE1EIGRhdGEgc3BlY2lmaWMgdG8gcHV6emxlXG4vLyBncmlkIG5vdCBwYXJ0IG9mIGNvbnN0cnVjdG9yIGFzIHNpbmdsZSBoZXVyaXN0aWMgcGFzc2VkIGJldHdlZW4gYWxsIGdyaWRzIGluIGEgZ2l2ZW4gUHV6emxlXG5jbGFzcyBNYW5oYXR0YW5IZXVyaXN0aWMge1xuXG4gICAgY29uc3RydWN0b3IobnVtUm93cywgbnVtQ29scykge1xuICAgICAgICB0aGlzLm51bVJvd3MgPSBudW1Sb3dzO1xuICAgICAgICB0aGlzLm51bUNvbHMgPSBudW1Db2xzO1xuICAgICAgICB0aGlzLm51bVRpbGVzID0gbnVtUm93cyAqIG51bUNvbHM7XG5cbiAgICAgICAgdGhpcy5fcHJlY29tcHV0ZSgpO1xuXG4gICAgICAgIHRoaXMubW92ZU51bWJlck1hcCA9IHtcbiAgICAgICAgICAgICdsJzogMCxcbiAgICAgICAgICAgICdyJzogMSxcbiAgICAgICAgICAgICd1JzogMixcbiAgICAgICAgICAgICdkJzogM1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogY2hhbmdlIHNvIHByZWNvbXB1dGUgY2FsbGVkIG9uY2UgZm9yIGFsbCBwdXp6bGVzIG9mIHNhbWUgc2l6ZVxuICAgIC8vIHNpbmNlIG5vIG1hdHRlciB3aGF0IHVzZXIgc2V0dGluZ3MgYXJlIGNhbGxlZCwgYWxsIHBvc3NpYmxlIGluZHMgYW5kIGdvYWxJbmRzIGFjY291bnRlZCBmb3JcbiAgICAvLyBzdG9yZSBhcyBjbGFzcyBwcm9wZXJ0eSwgYW5kIGNoYW5nZSBoZXVyaXN0aWNzIGJhY2sgdG8gc3RhdGljXG5cbiAgICAvLyByZXR1cm5zIHdoZXRoZXIgcHJlY29tcHV0YXRpb24gY291bGQgYmUgY29tcGxldGVkXG4gICAgX3ByZWNvbXB1dGUoKSB7XG5cbiAgICAgICAgLy8gc3RvcCBwcmVjb21wdXRpbmcgd2hlbiBudW1UaWxlcyA+IDEwMCAoNTAsMDAwIGFycmF5IGVudHJpZXMgaW4gY2FjaGUpXG4gICAgICAgIGlmICh0aGlzLm51bVRpbGVzID4gMTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBfbWQuZ2V0KGksIGopID0gbWQgdmFsdWUgYXQgaW5kID0gaSwgZ29hbEluZCA9IGpcbiAgICAgICAgdGhpcy5fbWQgPSBuZGFycmF5KG5ldyBVaW50MTZBcnJheSh0aGlzLm51bVRpbGVzICoqIDIpLCBbdGhpcy5udW1UaWxlcywgdGhpcy5udW1UaWxlc10pO1xuICAgICAgICAvLyBfbWREZWx0YS5nZXQoaSwgaiwgaykgPSBjaGFuZ2UgaW4gTUQgd2hlbiBpbmQgPSBpLCBnb2FsSW5kID0gaiwgYW5kIG1vdmUgPSBrXG4gICAgICAgIC8vIHdoZXJlIG1vdmUgPSAwIC0+ICdsJywgMSAtPiAncicsIDIgLT4gJ3UnIDMgLT4gJ2QnXG4gICAgICAgIHRoaXMuX21kRGVsdGEgPSBuZGFycmF5KG5ldyBJbnQ4QXJyYXkoNCAqIHRoaXMubnVtVGlsZXMgKiogMiksIFt0aGlzLm51bVRpbGVzLCB0aGlzLm51bVRpbGVzLCA0XSk7XG5cbiAgICAgICAgLy8gbCwgciwgdSwgZFxuICAgICAgICBjb25zdCBtb3ZlRGVsdGFNYXAgPSBJbnQxNkFycmF5LmZyb20oWy0xLCAxLCAtdGhpcy5udW1Db2xzLCB0aGlzLm51bUNvbHNdKTtcblxuICAgICAgICBsZXQgaW5kLCBnb2FsSW5kO1xuXG4gICAgICAgIGluZCA9IDA7XG4gICAgICAgIGZvciAobGV0IHJvdzEgPSAwOyByb3cxIDwgdGhpcy5udW1Sb3dzOyByb3cxKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbDEgPSAwOyBjb2wxIDwgdGhpcy5udW1Db2xzOyBjb2wxKyspIHtcbiAgICAgICAgICAgICAgICBnb2FsSW5kID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cyID0gMDsgcm93MiA8IHRoaXMubnVtUm93czsgcm93MisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbDIgPSAwOyBjb2wyIDwgdGhpcy5udW1Db2xzOyBjb2wyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21kLnNldChpbmQsIGdvYWxJbmQsIE1hdGguYWJzKHJvdzIgLSByb3cxKSArIE1hdGguYWJzKGNvbDIgLSBjb2wxKSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgZ29hbEluZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5kID0gMDtcbiAgICAgICAgZm9yIChsZXQgcm93MSA9IDA7IHJvdzEgPCB0aGlzLm51bVJvd3M7IHJvdzErKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sMSA9IDA7IGNvbDEgPCB0aGlzLm51bUNvbHM7IGNvbDErKykge1xuICAgICAgICAgICAgICAgIGdvYWxJbmQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdzIgPSAwOyByb3cyIDwgdGhpcy5udW1Sb3dzOyByb3cyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29sMiA9IDA7IGNvbDIgPCB0aGlzLm51bUNvbHM7IGNvbDIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0TUQgPSB0aGlzLl9tZC5nZXQoaW5kLCBnb2FsSW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGwsIHIsIHUsIGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG1vdmUgPSAwOyBtb3ZlIDwgNDsgbW92ZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZE1EID0gdGhpcy5fbWQuZ2V0KGluZCArIG1vdmVEZWx0YU1hcFttb3ZlXSwgZ29hbEluZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWREZWx0YS5zZXQoaW5kLCBnb2FsSW5kLCBtb3ZlLCBlbmRNRCAtIHN0YXJ0TUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ29hbEluZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgaGV1cmlzdGljIGRpc3RhbmNlIGZyb20gZ29hbFxuICAgIGNhbGN1bGF0ZShncmlkKSB7XG4gICAgICAgIGxldCBkaXN0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmlkLnRpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZ3JpZC5lbXB0eVBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0ICs9IHRoaXMuX21kLmdldChpLCBncmlkLnRpbGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXN0ICs9IGdyaWQuZ2V0VGlsZURpc3QoaSwgZ3JpZC50aWxlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgIH1cblxuICAgIC8vIFRPRE86IGNvbnNpZGVyIHJlZmFjdG9yaW5nIHRvIGp1c3QgdXNlIFwiZ3JpZFwiIHRvIHByZXZlbnQgY29uZnVzaW9uXG5cbiAgICAvLyBSZXR1cm5zIHVwZGF0ZWQgaGV1cmlzdGljIGRpc3RhbmNlIGZyb20gZ29hbCBhZnRlciBtb3ZlXG4gICAgLy8gbmV3R3JpZCA9IEdyaWQgYWZ0ZXIgbW92ZSAoZGlzdGluY3Qgb2JqZWN0KSwgd2l0aCBhbGwgcHJvcGVydGllcyB1cGRhdGVkIGJlc2lkZXMgaGV1cmlzdGljVmFsdWVcbiAgICAvLyBzdGFydEluZCA9IGluZCBtb3ZlZCB0aWxlIHN0YXJ0ZWQgaW5cbiAgICAvLyBlbmRJbmQgPSBpbmQgbW92ZWQgdGlsZSBlbmRlZCB1cCBpblxuICAgIC8vIG1vdmUgPSBzaW5nbGUtbGV0dGVyIG1vdmUgd2l0aGluICdsL3IvdS9kJ1xuICAgIC8vIE5PVEU6IGFzc3VtZXMgbmV3R3JpZCdzIGhldXJpc3RpYyB2YWx1ZSBpcyBzYW1lIGFzIG9sZCBncmlkIChub3QgeWV0IHVwZGF0ZWQpXG4gICAgdXBkYXRlKG5ld0dyaWQsIHN0YXJ0SW5kLCBlbmRJbmQsIG1vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VXBkYXRlRGVsdGEobmV3R3JpZCwgc3RhcnRJbmQsIGVuZEluZCwgbW92ZSkgKyBuZXdHcmlkLmhldXJpc3RpY1ZhbHVlO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgY2hhbmdlIGluIGhldXJpc3RpYyBkaXN0YW5jZSBmcm9tIG1vdmVcbiAgICAvLyBuZXdHcmlkID0gR3JpZCBhZnRlciBtb3ZlIChkaXN0aW5jdCBvYmplY3QpLCB3aXRoIGFsbCBwcm9wZXJ0aWVzIHVwZGF0ZWQgYmVzaWRlcyBoZXVyaXN0aWNWYWx1ZVxuICAgIC8vIHN0YXJ0SW5kID0gaW5kIG1vdmVkIHRpbGUgc3RhcnRlZCBpblxuICAgIC8vIGVuZEluZCA9IGluZCBtb3ZlZCB0aWxlIGVuZGVkIHVwIGluXG4gICAgLy8gbW92ZSA9IHNpbmdsZS1sZXR0ZXIgbW92ZSB3aXRoaW4gJ2wvci91L2QnXG4gICAgZ2V0VXBkYXRlRGVsdGEobmV3R3JpZCwgc3RhcnRJbmQsIGVuZEluZCwgbW92ZSkge1xuXG4gICAgICAgIGlmICh0aGlzLl9tZERlbHRhKSB7XG4gICAgICAgICAgICAvLyBnZXQobW92ZWRJbmQsIGdvYWxJbmQsIG1vdmUpXG4gICAgICAgICAgICAvLyAoZ29hbEluZCBpcyB2YWx1ZSBvZiB0aWxlIGF0IGVuZEluZCwgYXMgbmV3R3JpZCdzIGVuZEluZCBpcyBvbGRHcmlkJ3Mgc3RhcnRJbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWREZWx0YS5nZXQoc3RhcnRJbmQsIG5ld0dyaWQudGlsZXNbZW5kSW5kXSwgdGhpcy5tb3ZlTnVtYmVyTWFwW21vdmVdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ29hbEluZCA9IG5ld0dyaWQudGlsZXNbZW5kSW5kXSxcbiAgICAgICAgICAgIGdvYWxSb3cgPSBuZXdHcmlkLmdldFRpbGVSb3coZ29hbEluZCksXG4gICAgICAgICAgICBnb2FsQ29sID0gbmV3R3JpZC5nZXRUaWxlQ29sKGdvYWxJbmQpO1xuXG4gICAgICAgIGxldCBzdGFydFJvdyA9IG5ld0dyaWQuZ2V0VGlsZVJvdyhzdGFydEluZCksXG4gICAgICAgICAgICBzdGFydENvbCA9IG5ld0dyaWQuZ2V0VGlsZUNvbChzdGFydEluZCk7XG5cbiAgICAgICAgbGV0IGVuZFJvdyA9IG5ld0dyaWQuZ2V0VGlsZVJvdyhlbmRJbmQpLFxuICAgICAgICAgICAgZW5kQ29sID0gbmV3R3JpZC5nZXRUaWxlQ29sKGVuZEluZCk7XG5cbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyhnb2FsUm93IC0gZW5kUm93KSArIE1hdGguYWJzKGdvYWxDb2wgLSBlbmRDb2wpKSAtXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ29hbFJvdyAtIHN0YXJ0Um93KSArIE1hdGguYWJzKGdvYWxDb2wgLSBzdGFydENvbCk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyB3aGV0aGVyIGhldXJpc3RpYyB2YWx1ZSBpbmRpY2F0ZXMgaWYgcHV6emxlIGlzIHNvbHZlZFxuICAgIGlzU29sdmVkKGhldXJpc3RpY1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBoZXVyaXN0aWNWYWx1ZSA9PT0gMDtcbiAgICB9XG59XG5cbi8vIE5PVEU6IG1ldGhvZHMgbm90IHN0YXRpYyB0byBzdXBwb3J0IHVzaW5nIGNhY2hlZCBNRCBkYXRhIHNwZWNpZmljIHRvIHB1enpsZVxuY2xhc3MgTGluZWFyQ29uZmxpY3RIZXVyaXN0aWMgZXh0ZW5kcyBNYW5oYXR0YW5IZXVyaXN0aWN7XG5cbiAgICBjb25zdHJ1Y3RvcihudW1Sb3dzLCBudW1Db2xzKSB7XG4gICAgICAgIHN1cGVyKG51bVJvd3MsIG51bUNvbHMpO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgd2hldGhlciBwcmVjb21wdXRhdGlvbiBjb3VsZCBiZSBjb21wbGV0ZWRcbiAgICBfcHJlY29tcHV0ZSgpIHtcbiAgICAgICAgc3VwZXIuX3ByZWNvbXB1dGUoKTtcblxuICAgICAgICBsZXQgbiA9IE1hdGgubWF4KHRoaXMubnVtUm93cywgdGhpcy5udW1Db2xzKTtcblxuICAgICAgICAvLyBhdm9pZCBwcmVjb21wdXRhdGlvbiB3aGVuIG4gPiA4IG9yIHB1enpsZSBpcyAxRCAoY2FuIGp1c3QgdXNlIE1EKVxuICAgICAgICAvLyA5IGhhcyA5ODYsNDA5IHBlcm1zXG4gICAgICAgIC8vIDggaGFzIDE5LDE3Myw5NjAgc3BhY2VzIChlYWNoID4gMSBieXRlIGdpdmVuIFVpbnQ4QXJyYXkgYW5kIG92ZXJoZWFkKVxuICAgICAgICAvLyB3aGlsZSBwcmVjb21wdXRpbmcgc3RpbGwgZmVhc2libGUgZm9yIG4gPSA5LCBubyBwb2ludCBhcyA+IDFEIHB1enpsZXMgbm90XG4gICAgICAgIC8vIG9wdGltYWxseSBzb2x2YWJsZSBhdCB0aGF0IHBvaW50IGZvciBjdXJyZW50IHNvbHZlcnMgaGVyZVxuICAgICAgICAvLyBuZGFycmF5IGFsc28gYmVjb21lcyB0b28gbGFyZ2Ugd2hlbiBuID0gMTAgKHRocm93cyBlcnJvcilcbiAgICAgICAgaWYgKG4gPiA4IHx8IHRoaXMubnVtUm93cyA9PT0gMSB8fCB0aGlzLm51bUNvbHMgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hcHMgc2l6ZSBvZiBvcmRlcmluZ3Mgb2YgdGlsZXMgaW4gdGhlaXIgZ29hbCByb3cvY29sIHRvIGFuIG5kYXJyYXlcbiAgICAgICAgLy8gbWFwcGluZyB0aGUgb3JkZXJpbmdzIHRoZW1zZWx2ZXMgdG8gdGhlIGxpbmVhciBjb25mbGljdCBoZXVyaXN0aWMgdmFsdWVcblxuICAgICAgICAvLyBOT1RFOiBuZGFycmF5IHVzZWQgaW5zdGVhZCBvZiBtYXAsIGFzIGNvbnN0YW50IHRvU3RyaW5nKCkgY29tcHV0YXRpb25hbGx5IGNvc3RsaWVyXG4gICAgICAgIC8vIHRoYW4gaW5kZXhpbmcgaW50byBuZGFycmF5XG4gICAgICAgIC8vIGNvbnM6IG11Y2ggbGFyZ2VyIHNwYWNlIGNvbnN1bXB0aW9uIChzdW0gb2Ygbl5rIGZyb20gayA9IDEgdG8gbilcbiAgICAgICAgLy8gY29uc3VtZXMgMTksMTczLDk2MCBzcGFjZXMgKGVhY2ggPiAxIGJ5dGUgZ2l2ZW4gVWludDhBcnJheSBhbmQgb3ZlcmhlYWQpIHdoZW4gbiA9IDhcbiAgICAgICAgdGhpcy5fbGMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGZvciAobGV0IHBlcm1TaXplID0gMTsgcGVybVNpemUgPD0gbjsgcGVybVNpemUrKykge1xuICAgICAgICAgICAgdGhpcy5fbGNbcGVybVNpemVdID0gbmRhcnJheShcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShuICoqIHBlcm1TaXplKSxcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShwZXJtU2l6ZSkuZmlsbChuKVxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcGVybSBvZiB0aGlzLl9wZXJtdXRhdGlvbkhlbHBlcihuKSkge1xuICAgICAgICAgICAgdGhpcy5fbGNbcGVybS5sZW5ndGhdLnNldCguLi5wZXJtLCB0aGlzLl9jYWxjdWxhdGUocGVybSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBHZW5lcmF0b3Igb3ZlciBwb3NzaWJsZSBvcmRlcmluZ3Mgb2YgdGlsZXMgaW4gdGhlaXIgZ29hbCByb3dzL2NvbHNcbiAgICAvLyBleDogWzIsIDEsIDBdID0gMHRoIGluZCAtPiB0aWxlIHdpdGggZ29hbCBpbmQgb2YgMiwgMXN0IGluZCAtPiB0aWxlIHdpdGggZ29hbCBpbmQgb2YgMVxuICAgIC8vIE5PVEU6ICMgcGVybXV0YXRpb25zID0gc3VtIG9mIG4gcGVybXV0ZSBrIGZyb20gayA9IDEgdG8gbiA9IOKMimVuIeKIkjHijItcbiAgICAqX3Blcm11dGF0aW9uSGVscGVyKG4pIHtcbiAgICAgICAgLy8gd2hpbGUgSW50OEFycmF5IGdvZXMgZnJvbSAwIHRvIDI1NSwgYWNjZXB0YWJsZSBhcyBtZW1vcnkgcmVxdWlyZW1lbnRzXG4gICAgICAgIC8vIGJhbGxvb24gd2hlbiBudW1Sb3dzL251bUNvbHMgPiA4XG4gICAgICAgIGxldCBhcnIgPSBVaW50OEFycmF5LmZyb20ocmFuZ2UobikpO1xuICAgICAgICBmb3IgKGxldCBwZXJtU2l6ZSA9IDE7IHBlcm1TaXplIDw9IG47IHBlcm1TaXplKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBlcm0gb2YgcGVybXV0YXRpb25HZW5lcmF0b3IoYXJyLCBwZXJtU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBwZXJtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZShhcnIpIHtcbiAgICAgICAgbGV0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBnb2FsSW5kID0gYXJyW2ldO1xuICAgICAgICAgICAgbWFwLnNldChpLCB7Z29hbEluZCwgY29uZmxpY3RzOiBuZXcgU2V0KCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVGb3JNYXAobWFwKTtcbiAgICB9XG4gICAgLy8gVE9ETzogY29uc2lkZXIgc2VwYXJhdGluZyBsYyBjb25kaXRpb24gY2hlY2sgaW50byBuZXcgZnVuY3Rpb24gZm9yIHBvc3NpYmx5IGJldHRlciBwZXJmb3JtYW5jZVxuICAgIC8vIChsZXNzIFwiaWZcIiBjaGVja3MpXG5cbiAgICAvLyBjYWxjdWxhdGVzIGxpbmVhciBjb25mbGljdCBvZiBzcGVjaWZpZWQgZ3JpZFxuICAgIC8vIG9wdGlvbmFsIHN0YXJ0L2VuZCBwYXJhbXMgYWxsb3cgc3BlY2lmeWluZyBzZWN0aW9uIG9mIGdyaWQgdG8gY2FsY3VsYXRlIGNvbmZsaWN0IGhldXJpc3RpYyBmb3JcbiAgICAvLyByZWN0YW5ndWxhciBzZWN0aW9uIG9mIGdyaWQsIHdoZXJlIHN0YXJ0IGlzIGluY2x1c2l2ZSBhbmQgZW5kIGlmIGV4Y2x1c2l2ZVxuICAgIC8vIGNhbGNNRCBkZXRlcm1pbmVzIGlmIGNhbGN1bGF0ZSgpIGluY2x1ZGVzIE1hbmhhdHRhbiBEaXN0YW5jZSBpbiBoZXVyaXN0aWMgY2FsY3VsYXRpb25cbiAgICAvLyBOT1RFOiBzaW5jZSBsaW5lYXIgY29uZmxpY3QgKyBNRCBhbHdheXMgYWRtaXNzaWJsZSBhbmQgYXQgbGVhc3QgYXMgZ29vZCwgb25seSB1c2VcbiAgICAvLyBjYWxjTUQgPSBmYWxzZSBmb3IgdGVzdGluZyBvciBpZiB5b3UgcGxhbiBvbiBjYWxjdWxhdGluZyBNRCBpbiBhIGRpZmZlcmVudCB3YXlcbiAgICAvLyBleDogY2FsY3VsYXRlKGdyaWQsIDAsIDMsIDEsIDIpIGNhbGN1bGF0ZXMgaGV1cmlzdGljIGZvciAzIHRpbGUgdGFsbCB2ZXJ0aWNhbCBjaHVua1xuICAgIC8vIGluIGNvbFsxXSBmcm9tIHJvd1swLT4yXVxuICAgIC8vIEhldXJpc3RpYyBleHBsYW5hdGlvbjpcbiAgICAvLyBsaW5lYXIgY29uZmxpY3QgPSAyIHRpbGVzIGluIHRoZSBzYW1lIGdvYWwgcm93L2NvbCBidXQgaGF2ZSBpbnZlcnNpb24gcmVsYXRpb25zaGlwLlxuICAgIC8vIGhvcml6b250YWw6IChhIGlzIHRvIHJpZ2h0IG9mIGIgYnV0IGEncyBnb2FsIGlzIHRvIGxlZnQgb2YgYidzIGdvYWwpXG4gICAgLy8gdmVydGljYWw6IHNhbWUgYnV0IHdpdGggYm90dG9tIGFuZCB0b3AgaW5zdGVhZCBvZiByaWdodCBhbmQgbGVmdFxuICAgIC8vIFRvIHJlYWNoIGdvYWwgcG9zaXRpb25zLCBvbmUgb2YgdGhlIHRpbGVzIGluIHRoZSBwYWlyIGhhcyB0byBtb3ZlIG91dCBvZiB0aGUgd2F5XG4gICAgLy8gZm9yIHRoZSBvdGhlciB0aWxlIHRvIHJlYWNoIHRoZWlyIGdvYWwuIFRoZSBtb3ZlZCB0aWxlIGhhcyB0byBtb3ZlIGJhY2sgaW50byB0aGVpclxuICAgIC8vIGdvYWwgcm93L2NvbCB0byByZWFjaCB0aGVpciBnb2Fscy5cbiAgICAvL1xuICAgIC8vIExpbmVhciBjb25mbGljdCBpcyBjYWxjdWxhdGVkIG9uIGV2ZXJ5IHJvdyBhbmQgY29sdW1uLCBhbmQgY2FuIGJlIGNvbWJpbmVkIHdpdGhcbiAgICAvLyBtYW5oYXR0YW4gZGlzdGFuY2UgaGV1cmlzdGljIHRvIG1ha2UgYmV0dGVyIGFkbWlzc2libGUgaGV1cmlzdGljLFxuICAgIC8vIGFzIG1hbmhhdHRhbiBkaXN0YW5jZSBoZXVyaXN0aWMgZG9lc24ndCBhY2NvdW50IGZvciBtb3ZpbmcgdGlsZXMgb3V0IG9mIHRoZSB3YXlcbiAgICAvLyBhbmQgbGluZWFyIGNvbmZsY3QgZG9lc24ndCBhY2NvdW50IGZvciBtb3ZpbmcgdG8gdGhlIGNvcnJlY3QgdGlsZSBwb3NpdGlvbiBcbiAgICAvL1xuICAgIC8vIFdBUk5JTkc6IFlvdSBjYW4ndCBqdXN0IGFkZCAyIHRvIHRoZSBoZXVyaXN0aWMgdmFsdWUgZm9yIGVhY2ggaW52ZXJzaW9uIGZvdW5kLFxuICAgIC8vIGFzIG1vdmluZyBvbmUgdGlsZSBvdXQgb2YgdGhlIHdheSBjYW4gYWxsb3cgMiB0aWxlcyBpdCBjb25mbGljdHMgd2l0aCB0byBtb3ZlIGludG8gdGhlaXIgZ29hbHNcbiAgICAvLyBleDogWzMsIDEsIDJdIGhhcyBnb2FsIHBvc2l0aW9ucyBvZiBbMSwgMiwgM11cbiAgICAvLyB0byByZWFjaCB0aGUgZ29hbCwgbW92ZSAzIGRvd24gYW5kIHNsaWRlIDEgYW5kIDIgb3ZlciwgYW5kIHRoZW4gbW92ZSAzIHRvIHRoZSBnb2FsXG4gICAgLy8gd2hpbGUgdGhlcmUgYXJlIDIgaW52ZXJzaW9ucyAoMywgMSkgYW5kICgzLCAyKSwgbW92aW5nIDMgb3V0IG9mIHRoZSB3YXkgZm9yIDEgbWVhbnNcbiAgICAvLyB0aGF0IGl0IGlzIG91dCBvZiB0aGUgd2F5IGZvciAyIGFzIHdlbGwuXG4gICAgLy8gSWYgeW91IGFkZGVkIDIgZm9yIGVhY2ggaW52ZXJzaW9uLCBoZXVyaXN0aWMgPSBMQyA9ICgyICsgMikgKyBNRCA9ICgyICsgMSArIDEpID0gOFxuICAgIC8vIHdoZW4gdGhlIG9wdGltYWwgc29sdXRpb24gb25seSB0YWtlcyA2IG1vdmVzIChcIjNcIiBkb3duLCBcIjFcIiBsZWZ0LCBcIjJcIiBsZWZ0LCBcIjNcIiByaWdodCB4MiwgXCIzXCIgdXApXG4gICAgY2FsY3VsYXRlKGdyaWQpIHtcbiAgICAgICAgbGV0IGhldXJpc3RpY1ZhbHVlID0gMDtcblxuICAgICAgICAvLyBjYW5kaWRhdGVUaWxlcy5nZXQoaSkgPSBtYXAgb2YgdGlsZXMgb2Ygcm93L2NvbCBpIHRoYXQgYXJlIGluIHRoZWlyIGdvYWwgcm93L2NvbFxuICAgICAgICAvLyBtYXAgPSB7aW5kOiB7Z29hbEluZCwgY29uZmxpY3RzfX1cbiAgICAgICAgLy8gLSBpbmQgPSBjdXJyZW50IGluZGV4IGluIGZsYXR0ZW5lZCBwdXp6bGUgYXJyYXlcbiAgICAgICAgLy8gLSBnb2FsSW5kID0gdmFsdWUgYXQgaW5kID0gaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIGdvYWwgcHV6emxlXG4gICAgICAgIC8vIC0gY29uZmxpY3RzIGlzIGEgc2V0IG9mIGNvbmZsaWN0aW5nIGluZGljZXMgKGluaXRpYWxseSBlbXB0eSlcbiAgICAgICAgLy8gTk9URTogY29scyBhY2Nlc3NlZCBhdCBrZXkgPSBjb2x1bW4gaW5kZXggKyBncmlkLm51bVJvd3NcbiAgICAgICAgLy8gKGZpcnN0IGdyaWQubnVtUm93cyBlbnRyaWVzIGFyZSBmb3Igcm93cywgbmV4dCBncmlkLm51bUNvbHMgZW50cmllcyBmb3IgY29sdW1ucylcbiAgICAgICAgbGV0IGNhbmRpZGF0ZVRpbGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8vIGRldGVybWluZXMgd2hpY2ggdGlsZXMgYXJlIGluIHRoZWlyIGdvYWwgcm93IGFuZC9vciBjb2x1bW5cbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5udW1Sb3dzOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5udW1Db2xzOyBjb2wrKykge1xuXG4gICAgICAgICAgICAgICAgbGV0IGluZCA9IGdyaWQuZ2V0SW5kZXgocm93LCBjb2wpO1xuICAgICAgICAgICAgICAgIGxldCBnb2FsSW5kID0gZ3JpZC50aWxlc1tpbmRdLFxuICAgICAgICAgICAgICAgICAgICBnb2FsUm93ID0gZ3JpZC5nZXRUaWxlUm93KGdvYWxJbmQpLFxuICAgICAgICAgICAgICAgICAgICBnb2FsQ29sID0gZ3JpZC5nZXRUaWxlQ29sKGdvYWxJbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZCAhPT0gZ3JpZC5lbXB0eVBvcykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBtYW5oYXR0YW4gZGlzdGFuY2UgdG8gaGV1cmlzdGljIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV1cmlzdGljVmFsdWUgKz0gdGhpcy5fbWQuZ2V0KGluZCwgZ29hbEluZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXVyaXN0aWNWYWx1ZSArPSBNYXRoLmFicyhyb3cgLSBnb2FsUm93KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgTWF0aC5hYnMoY29sIC0gZ29hbENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogc2luZ2xlIHRpbGUgY2FuIGJlIGNhbmRpZGF0ZSBmb3IgYm90aCByb3cgYW5kIGNvbCBjb25mbGljdFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyB0aWxlIGNhbiBiZSBwYXJ0IG9mIGNvbmZsaWN0IGV2ZW4gd2hlbiBpdCdzIGluIGl0cyBnb2FsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkLmdldFRpbGVSb3coZ29hbEluZCkgPT09IHJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVUaWxlcy5oYXMocm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVUaWxlcy5zZXQocm93LCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVRpbGVzLmdldChyb3cpLnB1c2goZ29hbENvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlVGlsZXMuaGFzKHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMuc2V0KHJvdywgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMuZ2V0KHJvdykuc2V0KGluZCwge2dvYWxJbmQsIGNvbmZsaWN0czogbmV3IFNldCgpfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyaWQuZ2V0VGlsZUNvbChnb2FsSW5kKSA9PT0gY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gZ3JpZC5udW1Sb3dzICsgY29sO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVUaWxlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVUaWxlcy5zZXQoa2V5LCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVRpbGVzLmdldChrZXkpLnB1c2goZ29hbFJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlVGlsZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMuc2V0KGtleSwgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMuZ2V0KGtleSkuc2V0KGluZCwge2dvYWxJbmQsIGNvbmZsaWN0czogbmV3IFNldCgpfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBtYWtpbmcgY3VzdG9tIGZ1bmN0aW9uIGZvciB1cGRhdGUgc2luY2Ugb25seSBuZWVkIHRvIGV4YW1pbmVcbiAgICAgICAgLy8gaWYgdGlsZSBpbiAxIChrbm93bikgZ29hbCBkaW1lbnNpb24gYW5kIG1hcCBhbHNvIHVubmVjZXNzYXJ5XG4gICAgICAgIC8vIG1heWJlIGhlbHBlciBmdW5jdGlvbnMgZm9yIHByb2Nlc3NpbmcgZWFjaCByb3cvY29sP1xuICAgICAgICAvLyBkb24ndCB1c2UgaGVscGVycyBmb3IgcmVndWxhciBjYWxjdWxhdGUoKSB0aG91Z2ggKHByb2JhYmx5IGxlc3MgZWZmaWNpZW50XG4gICAgICAgIC8vIHNpbmNlIGVhY2ggdGlsZSB3b3VsZCBiZSBpdGVyYXRlZCBvdmVyIHR3aWNlIChzZXBhcmF0ZWx5IGZvciByb3cgYW5kIGNvbCkpXG4gICAgICAgIGlmICh0aGlzLl9sYykge1xuICAgICAgICAgICAgLy8gVE9ETzogdXNlIHZhbHVlcyBzaW5jZSBrZXlzIHVubmVjZXNzYXJ5IG5vd1xuICAgICAgICAgICAgZm9yIChsZXQgWywgYXJyXSBvZiBjYW5kaWRhdGVUaWxlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBoZXVyaXN0aWNWYWx1ZSArPSB0aGlzLl9sY1thcnIubGVuZ3RoXS5nZXQoLi4uYXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJvdy9ncmlkLm51bVJvd3MgKyBjb2wgbm8gbG9uZ2VyIHJlbGV2YW50IGFuZCBjYW4gYmUgZGlzY2FyZGVkIFxuICAgICAgICAgICAgZm9yIChsZXQgWywgbWFwXSBvZiBjYW5kaWRhdGVUaWxlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBoZXVyaXN0aWNWYWx1ZSArPSB0aGlzLl9jYWxjdWxhdGVGb3JNYXAobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZXVyaXN0aWNWYWx1ZTtcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlRm9yTWFwKG1hcCkge1xuICAgICAgICBpZiAobWFwLnNpemUgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoZXVyaXN0aWNWYWx1ZSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgW2luZDEsIHtnb2FsSW5kOiBnb2FsSW5kMSwgY29uZmxpY3RzOiBjb25mbGljdHMxfV0gb2YgbWFwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBbaW5kMiwge2dvYWxJbmQ6IGdvYWxJbmQyLCBjb25mbGljdHM6IGNvbmZsaWN0czJ9XSBvZiBtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kMiA+IGluZDEgJiYgZ29hbEluZDIgPCBnb2FsSW5kMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXAuZ2V0KGluZDEpLmNvbmZsaWN0cy5hZGQoaW5kMik7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5nZXQoaW5kMikuY29uZmxpY3RzLmFkZChpbmQxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29uZmxpY3RUcmVlID0gbmV3IEFWTFRyZWUoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhLmluZCA9PT0gYi5pbmQpIHJldHVybiAwO1xuXG4gICAgICAgICAgICBsZXQgZGlmZiA9IGEuY29uZmxpY3RzLnNpemUgLSBiLmNvbmZsaWN0cy5zaXplO1xuXG4gICAgICAgICAgICAgICAgLy8gc29ydHMgYnkgaW5kIGFzY2VuZGluZyBpZiBjb25mbGljdHMgZXF1YWxcbiAgICAgICAgICAgICAgICAvLyBuZWNlc3NhcnkgdG8gaWRlbnRpZnkgb2JqZWN0IGJ5IGluZCBpbiB0cmVlLCBhcyBub2RlIHdpdGggc2FtZSAjIGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgIC8vIGFzIGRlc2lyZWQgbm9kZSBjYW4gYXBwZWFyIGJlZm9yZSBkZXNpcmVkIG5vZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA9PT0gMCA/IGEuaW5kIC0gYi5pbmQgOiBkaWZmO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChsZXQgW2luZCwge2dvYWxJbmQsIGNvbmZsaWN0c31dIG9mIG1hcCkge1xuXG4gICAgICAgICAgICBpZiAoY29uZmxpY3RzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uZmxpY3RUcmVlLmluc2VydCh7Y29uZmxpY3RzLCBpbmR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0aWxlO1xuXG4gICAgICAgIHdoaWxlIChjb25mbGljdFRyZWUuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRpbGUgPSBjb25mbGljdFRyZWUubWF4KCk7XG4gICAgICAgICAgICAvLyBOT1RFOiBsaWJyYXJ5IGhhcyBubyBvcHRpb24gZm9yIGZpbmRpbmcgYW5kIHJlbW92aW5nIGxhcmdlc3QgaXRlbSBpbiBvbmUgc3RlcFxuICAgICAgICAgICAgLy8gY291bGQgdXNlIHBvcCgpIHdvcmthcm91bmQgd2l0aCBvcHBvc2l0ZSBjb21wYXJhdG9yLCBidXQgcG9wIGFsc28gY2FsbHNcbiAgICAgICAgICAgIC8vIHJlbW92ZSgpIGFmdGVyIGZpbmRpbmcgbWluIGluIGN1cnJlbnQgdmVyc2lvbiAoMS40LjQpXG4gICAgICAgICAgICBjb25mbGljdFRyZWUucmVtb3ZlKHRpbGUpO1xuXG4gICAgICAgICAgICAvLyBoZXVyaXN0aWMgKz0gMiBmb3IgZWFjaCB0aWxlIHRoYXQgbXVzdCBiZSByZW1vdmVkIGJlZm9yZSB0aGVyZSBhcmUgbm8gY29uZmxpY3RzXG4gICAgICAgICAgICBoZXVyaXN0aWNWYWx1ZSArPSAyO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBjb25mbGljdCBvZiB0aWxlLmNvbmZsaWN0cykge1xuICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgY29uZmxpY3RzIG9mIGNvbmZsaWN0aW5nIHRpbGVcbiAgICAgICAgICAgICAgICAvLyBleDogYS5jb25mbGljdHMgPSBbYixjXSwgYi5jb25mbGljdHMgPSBbYV0sIGNvcnJDb25mbGljdHMgb2YgYSA9IChTZXQpIFthXVxuICAgICAgICAgICAgICAgIGxldCBjb3JyQ29uZmxpY3RzID0gbWFwLmdldChjb25mbGljdCkuY29uZmxpY3RzO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNvcnJPYmogPSB7Y29uZmxpY3RzOiBjb3JyQ29uZmxpY3RzLCBpbmQ6IGNvbmZsaWN0fTtcblxuICAgICAgICAgICAgICAgIGNvbmZsaWN0VHJlZS5yZW1vdmUoY29yck9iaik7XG5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB0cmVlIHVzZXMgcmVmZXJlbmNlIHRvIHNhbWUgY29uZmxpY3RzIG9iamVjdCwgc28gY29uZmxpY3RzIHVwZGF0ZWQgdGhlcmUgYXMgd2VsbFxuICAgICAgICAgICAgICAgIGNvcnJDb25mbGljdHMuZGVsZXRlKHRpbGUuaW5kKTtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQgYW5kIGluc2VydGVkIHRvIHJlb3JkZXIgYmFzZWQgb24gbmV3IG51bWJlciBvZiBjb25mbGljdHNcbiAgICAgICAgICAgICAgICBpZiAoY29yckNvbmZsaWN0cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25mbGljdFRyZWUuaW5zZXJ0KGNvcnJPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV1cmlzdGljVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlcyBMQyBmb3IgZ2l2ZW4gcm93IGluZGV4XG4gICAgLy8gTk9URTogZG9lc24ndCBpbmNvcnBvcmF0ZSBNRFxuICAgIF9jYWxjdWxhdGVGb3JSb3coZ3JpZCwgcm93KSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGVUaWxlcyA9IHRoaXMuX2xjID8gW10gOiBuZXcgTWFwKCk7XG5cbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5udW1Db2xzOyBjb2wrKykge1xuICAgICAgICAgICAgbGV0IGluZCA9IGNvbCArIHRoaXMubnVtQ29scyAqIHJvdztcblxuICAgICAgICAgICAgaWYgKGluZCAhPT0gZ3JpZC5lbXB0eVBvcykge1xuICAgICAgICAgICAgICAgIGxldCBnb2FsSW5kID0gZ3JpZC50aWxlc1tpbmRdLFxuICAgICAgICAgICAgICAgICAgICBnb2FsUm93ID0gZ3JpZC5nZXRUaWxlUm93KGdvYWxJbmQpLFxuICAgICAgICAgICAgICAgICAgICBnb2FsQ29sID0gZ3JpZC5nZXRUaWxlQ29sKGdvYWxJbmQpO1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPT09IGdvYWxSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVUaWxlcy5wdXNoKGdvYWxDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMuc2V0KGNvbCwge2dvYWxJbmQ6IGdvYWxDb2wsIGNvbmZsaWN0czogbmV3IFNldCgpfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbGMpIHtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGVUaWxlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGNbY2FuZGlkYXRlVGlsZXMubGVuZ3RoXS5nZXQoLi4uY2FuZGlkYXRlVGlsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUZvck1hcChjYW5kaWRhdGVUaWxlcyk7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlcyBMQyBmb3IgZ2l2ZW4gY29sdW1uIGluZGV4XG4gICAgLy8gTk9URTogZG9lc24ndCBpbmNvcnBvcmF0ZSBNRFxuICAgIF9jYWxjdWxhdGVGb3JDb2woZ3JpZCwgY29sKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGVUaWxlcyA9IHRoaXMuX2xjID8gW10gOiBuZXcgTWFwKCk7XG5cbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5udW1Sb3dzOyByb3crKykge1xuICAgICAgICAgICAgbGV0IGluZCA9IGNvbCArIHRoaXMubnVtQ29scyAqIHJvdztcblxuICAgICAgICAgICAgaWYgKGluZCAhPT0gZ3JpZC5lbXB0eVBvcykge1xuICAgICAgICAgICAgICAgIGxldCBnb2FsSW5kID0gZ3JpZC50aWxlc1tpbmRdLFxuICAgICAgICAgICAgICAgICAgICBnb2FsUm93ID0gZ3JpZC5nZXRUaWxlUm93KGdvYWxJbmQpLFxuICAgICAgICAgICAgICAgICAgICBnb2FsQ29sID0gZ3JpZC5nZXRUaWxlQ29sKGdvYWxJbmQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2wgPT09IGdvYWxDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVUaWxlcy5wdXNoKGdvYWxSb3cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMuc2V0KHJvdywge2dvYWxJbmQ6IGdvYWxSb3csIGNvbmZsaWN0czogbmV3IFNldCgpfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbGMpIHtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGVUaWxlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGNbY2FuZGlkYXRlVGlsZXMubGVuZ3RoXS5nZXQoLi4uY2FuZGlkYXRlVGlsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUZvck1hcChjYW5kaWRhdGVUaWxlcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlKG5ld0dyaWQsIHN0YXJ0SW5kLCBlbmRJbmQsIG1vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VXBkYXRlRGVsdGEobmV3R3JpZCwgc3RhcnRJbmQsIGVuZEluZCwgbW92ZSkgKyBuZXdHcmlkLmhldXJpc3RpY1ZhbHVlO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGNvbnNpZGVyIHNwbGl0dGluZyB1cGRhdGUgaW50byAyIHBhcnRzIHNvIG5ld0dyaWQgaXNuJ3Qgc3dpdGNoZWQgYmFjayBhbmQgZm9ydGggaW4gSURBKlxuICAgIC8vIChvciBjcmVhdGUgaGVscGVyIHRoYXQgYWxzbyB0YWtlcyBpbiBzdGFydCBhbmQgZW5kIGxvY2F0aW9ucyBvZiB0aWxlIGFzIHdlbGwgYXMgbmV3R3JpZFxuICAgIC8vIGZvciB1c2UgaW4gSURBKilcblxuICAgIC8vIFRPRE86IGhhdmUgdXBkYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1cGRhdGVkIGdyaWQgZm9yIHVzZSBpbiBpZGEqXG4gICAgLy8gVE9ETzogc2VlIGlmIGNhbGN1bGF0ZSgpIG5lZWRzIGFueXRoaW5nIGNoYW5nZWQgYmVzaWRlcyBlbXB0eVBvcyBhbmQgdGlsZSBzd2FwXG5cbiAgICAvLyByZXR1cm5zIGNoYW5nZSBpbiBoZXVyaXN0aWMgZGlzdGFuY2UgZnJvbSBtb3ZlXG4gICAgLy8gbmV3R3JpZCA9IEdyaWQgYWZ0ZXIgbW92ZSAoZGlzdGluY3Qgb2JqZWN0KSwgd2l0aCBhbGwgcHJvcGVydGllcyB1cGRhdGVkIGJlc2lkZXMgaGV1cmlzdGljVmFsdWVcbiAgICAvLyBzdGFydEluZCA9IGluZCBtb3ZlZCB0aWxlIHN0YXJ0ZWQgaW5cbiAgICAvLyBlbmRJbmQgPSBpbmQgbW92ZWQgdGlsZSBlbmRlZCB1cCBpblxuICAgIC8vIG1vdmUgPSBzaW5nbGUtbGV0dGVyIG1vdmUgd2l0aGluICdsL3IvdS9kJ1xuICAgIGdldFVwZGF0ZURlbHRhKG5ld0dyaWQsIHN0YXJ0SW5kLCBlbmRJbmQsIG1vdmUpIHtcblxuICAgICAgICBsZXQgc3RhcnRSb3cgPSBuZXdHcmlkLmdldFRpbGVSb3coc3RhcnRJbmQpLFxuICAgICAgICAgICAgc3RhcnRDb2wgPSBuZXdHcmlkLmdldFRpbGVDb2woc3RhcnRJbmQpO1xuXG4gICAgICAgIGxldCBzdGFydFZhbCA9IDAsXG4gICAgICAgICAgICBlbmRWYWwgPSAwO1xuXG4gICAgICAgIGxldCBmdW5jO1xuICAgICAgICBsZXQgaW5kcztcblxuICAgICAgICBzd2l0Y2ggKG1vdmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgIGZ1bmMgPSB0aGlzLl9jYWxjdWxhdGVGb3JDb2w7XG4gICAgICAgICAgICAgICAgaW5kcyA9IFtzdGFydENvbCwgc3RhcnRDb2wgLSAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgIGZ1bmMgPSB0aGlzLl9jYWxjdWxhdGVGb3JDb2w7XG4gICAgICAgICAgICAgICAgaW5kcyA9IFtzdGFydENvbCwgc3RhcnRDb2wgKyAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgIGZ1bmMgPSB0aGlzLl9jYWxjdWxhdGVGb3JSb3c7XG4gICAgICAgICAgICAgICAgaW5kcyA9IFtzdGFydFJvdywgc3RhcnRSb3cgLSAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIGZ1bmMgPSB0aGlzLl9jYWxjdWxhdGVGb3JSb3c7XG4gICAgICAgICAgICAgICAgaW5kcyA9IFtzdGFydFJvdywgc3RhcnRSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hbmhhdHRhbiBkaXN0YW5jZSBub3QgY2FsY3VsYXRlZCBpbiBmdW5jIGFzIG9ubHkgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZFxuICAgICAgICAvLyBmb3Igc2luZ2xlIHRpbGUgbW92ZWQgKG1vcmUgZWZmaWNpZW50IHRvIGNhbGN1bGF0ZSBzZXBhcmF0ZWx5KVxuICAgICAgICBlbmRWYWwgKz0gZnVuYy5jYWxsKHRoaXMsIG5ld0dyaWQsIGluZHNbMF0pO1xuICAgICAgICBlbmRWYWwgKz0gZnVuYy5jYWxsKHRoaXMsIG5ld0dyaWQsIGluZHNbMV0pO1xuXG4gICAgICAgIC8vIHJldHVybnMgZ3JpZCBwYXJ0aWFsbHkgdG8gcHJlLW1vdmUgc3RhdGUgdG8gY2FsY3VsYXRlIExDIGZvciByZWxldmFudCBjb2xzIHByZS1tb3ZlXG4gICAgICAgIG5ld0dyaWQuc3dhcChzdGFydEluZCwgZW5kSW5kKTtcbiAgICAgICAgbmV3R3JpZC5lbXB0eVBvcyA9IGVuZEluZDtcblxuICAgICAgICBzdGFydFZhbCArPSBmdW5jLmNhbGwodGhpcywgbmV3R3JpZCwgaW5kc1swXSk7XG4gICAgICAgIHN0YXJ0VmFsICs9IGZ1bmMuY2FsbCh0aGlzLCBuZXdHcmlkLCBpbmRzWzFdKTtcblxuICAgICAgICAvLyByZXR1cm4gZ3JpZCB0byBvcmlnaW5hbCBzdGF0ZVxuICAgICAgICBuZXdHcmlkLnN3YXAoc3RhcnRJbmQsIGVuZEluZCk7XG4gICAgICAgIG5ld0dyaWQuZW1wdHlQb3MgPSBzdGFydEluZDtcblxuICAgICAgICByZXR1cm4gZW5kVmFsIC0gc3RhcnRWYWwgKyBzdXBlci5nZXRVcGRhdGVEZWx0YShuZXdHcmlkLCBzdGFydEluZCwgZW5kSW5kLCBtb3ZlKTtcbiAgICB9XG5cblxuICAgIC8vIHJldHVybnMgd2hldGhlciBoZXVyaXN0aWMgdmFsdWUgaW5kaWNhdGVzIGlmIHB1enpsZSBpcyBzb2x2ZWRcbiAgICBpc1NvbHZlZChoZXVyaXN0aWNWYWx1ZSkge1xuICAgICAgICByZXR1cm4gaGV1cmlzdGljVmFsdWUgPT09IDA7XG4gICAgfVxufVxuXG4vLyBOT1RFOiBzZXBhcmF0ZSBmcm9tIHB1enpsZS1ncmFwaGljJ3MgUHV6emxlcyB0byBlYXNlIHRlc3RpbmcgYW5kIHJlZHVjZSBtZW1vcnkgY29zdCBpbiBBKlxuY2xhc3MgUHV6emxlIHtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgbmV3IFB1enpsZSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBudW1Sb3dzICMgcm93cyBpbiBncmlkXG4gICAgICogQHBhcmFtIG51bUNvbHMgIyBjb2x1bW5zIGluIGdyaWRcbiAgICAgKiBAcGFyYW0gdGlsZXMgZmxhdHRlbmVkIGFycmF5IG9mIHRpbGUgaWRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlaXIgbG9jYXRpb25zIGluIHRoZSB1bnNvbHZlZCBwdXp6bGVcbiAgICAgKiAod2hlcmUgaWRzID0gdGlsZSBwb3NpdGlvbnMgaW4gdGhlIHNvbHZlZCBwdXp6bGUgbGVmdCB0byByaWdodCwgdG9wIHRvIGJvdHRvbSwgMCBpbmRleGVkKVxuICAgICAqIC0gZXg6IHN0YXJ0R3JpZCA9IFtiLCBhLCBjXSwgZ29hbEdyaWQgPSBbYSwgYiwgY10sIHJldHVybiA9IFsxLCAwLCAyXVxuICAgICAqIC0gZXhwbGFuYXRpb246IGIgPSBnb2FsR3JpZFsxXSwgYSA9IGdvYWxHcmlkWzBdLCBjID0gZ29hbEdyaWRbMl1cbiAgICAgKiBAcGFyYW0gZW1wdHlQb3MgcG9zaXRpb24gb2YgZW1wdHkgdGlsZSBpbiBncmlkXG4gICAgICogQHBhcmFtIGhldXJpc3RpYyBoZXVyaXN0aWMgdXNlZCB0byBkZXRlcm1pbmUgaG93IGZhciBncmlkIGlzIGZyb20gZ29hbCBzdGF0ZS5cbiAgICAgKiBEZWZhdWx0IGhldXJpc3RpYyBpcyBMaW5lYXIgQ29uZmxpY3QsIHBvc3NpYmxlIHZhbHVlcyBhcmUgJ01EJyBhbmQgJ0xDJ1xuICAgICAqIGNvcnJlc3BvbmRpbmcgd2l0aCBtYW5oYXR0YW4gZGlzdGFuY2UgYW5kIGxpbmVhciBjb25mbGljdCByZXNwZWN0aXZlbHlcbiAgICAgKiBAcGFyYW0gc29sdmVyIHNvbHZpbmcgYWxnb3JpdGhtIHRvIHVzZSAoJ0lEQSonIG9yICdBKicpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobnVtUm93cywgbnVtQ29scywgdGlsZXMsIGVtcHR5UG9zLCBcbiAgICAgICAge2hldXJpc3RpYyA9ICdMQycsIHNvbHZlciA9IG51bVJvd3MgKiBudW1Db2xzID4gOSA/ICdJREEqJyA6ICdBKid9ID0ge30pIHtcblxuICAgICAgICB0aGlzLm51bVJvd3MgPSBudW1Sb3dzO1xuICAgICAgICB0aGlzLm51bUNvbHMgPSBudW1Db2xzO1xuICAgICAgICAvLyB1c2UgbGVzcyBtZW1vcnkgaWYgcG9zc2libGVcbiAgICAgICAgdGhpcy50aWxlcyA9IHRpbGVzLmxlbmd0aCA+IDI1NiA/IFVpbnQxNkFycmF5LmZyb20odGlsZXMpOiBVaW50OEFycmF5LmZyb20odGlsZXMpO1xuICAgICAgICB0aGlzLmVtcHR5UG9zID0gZW1wdHlQb3M7XG5cbiAgICAgICAgbGV0IGhldXJpc3RpY0NsYXNzO1xuICAgICAgICBzd2l0Y2ggKGhldXJpc3RpYykge1xuICAgICAgICAgICAgY2FzZSAnTUQnOlxuICAgICAgICAgICAgICAgIGhldXJpc3RpY0NsYXNzICA9IE1hbmhhdHRhbkhldXJpc3RpYztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaGV1cmlzdGljQ2xhc3MgPSBMaW5lYXJDb25mbGljdEhldXJpc3RpYztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGV1cmlzdGljID0gbmV3IGhldXJpc3RpY0NsYXNzKG51bVJvd3MsIG51bUNvbHMpO1xuICAgICAgICB0aGlzLnNvbHZlciA9IHNvbHZlcjtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zXG4gICAgLy8gLSBzb2x1dGlvbiBhcyBhcnJheSBvZiBtb3ZlcyB3aXRoaW4gKGwvci91L2QpXG4gICAgLy8gLSAtMSBpZiBzb2x1dGlvbiB0b29rIHRvbyBsb25nIHRvIGZpbmRcbiAgICAvLyAtIG51bGwgaWYgc29sdXRpb24gY291bGQgbm90IGJlIGZvdW5kXG4gICAgLy8gTk9URTogbWF4SXRlcmF0aW9ucyBpZ25vcmVkIGZvciAnc3RyYXRlZ2ljJyBvcHRpb25cbiAgICBzb2x2ZShtYXhJdGVyYXRpb25zID0gMTAwMDAwKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuc29sdmVyID09PSAnQSonKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb2x2ZUFTdGFyKG1heEl0ZXJhdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc29sdmVyID09PSAnSURBKicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvbHZlSURBU3RhcihtYXhJdGVyYXRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNvbHZlciA9PT0gJ3N0cmF0ZWdpYycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvbHZlU3RyYXRlZ2ljYWxseSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgICAgICAgICB7dGhpcy5zb2x2ZXJ9IGlzIG5vdCBhIHZhbGlkIG9wdGlvbi4gQ2hvb3NlIGJldHdlZW4gJ0EqJywgJ0lEQSonLCBhbmQgJ3N0cmF0ZWdpYycuYClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICBzb2x2ZUFTdGFyKG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgYnVja2V0IHF1ZXVlIGluc3RlYWQgb2YgcHJpb3JpdHkgcXVldWVcbiAgICAgICAgLy8gZS5nLiBhcnJheSB3aGVyZSBrZXkgPSB0b3RhbCBkaXN0YW5jZSwgdmFsdWUgPSBub2RlIHdpdGggdGhhdCBkaXN0YW5jZVxuICAgICAgICAvLyBhbHNvIGNvbnNpZGVyIG5lc3RlZCBidWNrZXQgcXVldWUgdG8gYWxsb3cgb3JkZXJpbmcgYnkgdHJhdmVsZWREaXN0IHRvIHRpZS1icmVha1xuICAgICAgICBsZXQgcSA9IG5ldyBGYXN0UHJpb3JpdHlRdWV1ZShcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBOT1RFOiBjb21wYXJhdG9yIHB1dHMgZ3JpZDEgZmlyc3QgaWYgcmV0dXJuIFwidHJ1ZVwiIChncmlkMSBsZXNzIHRoYW4gZ3JpZDIpXG4gICAgICAgICAgICAoZ3JpZDEsIGdyaWQyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsMSA9IGdyaWQxLmhldXJpc3RpY1ZhbHVlICsgZ3JpZDEudHJhdmVsZWREaXN0LFxuICAgICAgICAgICAgICAgICAgICB0b3RhbDIgPSBncmlkMi5oZXVyaXN0aWNWYWx1ZSArIGdyaWQyLnRyYXZlbGVkRGlzdDtcblxuICAgICAgICAgICAgICAgIC8vIGZhdm9yIGdyaWRzIHdpdGggbW9yZSB0cmF2ZWxlZCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIC8vIGV4cGxhbmF0aW9uOiBzaW5jZSBhZG1pc3Npc2libGUgaGV1cmlzdGljc1xuICAgICAgICAgICAgICAgIC8vIHVuZGVyZXN0aW1hdGUgb3IgbWF0Y2ggYWN0dWFsIGRpc3RhbmNlIHRvIGdvYWwsXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsIGRpc3RhbmNlIG9mIGdyaWQgd2l0aCBtb3JlIHRyYXZlbGVkIGRpc3RhbmNlIGlzIGxpa2VseSB0byBiZSA8PVxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbCBkaXN0YW5jZSBvZiBncmlkIHdpdGggbGVzcyB0cmF2ZWxlZCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdG90YWwgZGlzdGFuY2UgaXMgZXF1YWxcbiAgICAgICAgICAgICAgICByZXR1cm4gdG90YWwxID09PSB0b3RhbDIgPyBcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDEudHJhdmVsZWREaXN0ID4gZ3JpZDIudHJhdmVsZWREaXN0IDogXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsMSA8IHRvdGFsMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICk7XG4gICAgICAgIGxldCBncmlkID0gbmV3IEdyaWQodGhpcy5udW1Sb3dzLCB0aGlzLm51bUNvbHMsIHRoaXMudGlsZXMsIHRoaXMuZW1wdHlQb3MsIHRoaXMuaGV1cmlzdGljLCAwKTtcbiAgICAgICAgcS5hZGQoZ3JpZCk7XG5cbiAgICAgICAgbGV0IGN1cnI7XG4gICAgICAgIFxuICAgICAgICAvLyBtYXBzIEdyaWQgc3RhdGUgdG8gYmVzdC9zaG9ydGVzdCAoaGV1cmlzdGljICsgZGlzdGFuY2UgdHJhdmVsZWQpIGZvdW5kIHNvIGZhclxuICAgICAgICBsZXQgYmVzdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChxLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0aW9ucyA+IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnIgPSBxLnBvbGwoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnIuaXNTb2x2ZWQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZXJhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyLnJlY29uc3RydWN0UGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBtb3ZlIG9mIGN1cnIuZ2V0VmFsaWRNb3ZlcygpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJzaW5nIGEgbW92ZSB3aWxsIG5ldmVyIGxlYWQgdG8gYW4gb3B0aW1hbCBwYXRoXG4gICAgICAgICAgICAgICAgaWYgKG1vdmUgIT09IEdyaWQuZ2V0UmV2ZXJzZWRNb3ZlKGN1cnIubGFzdE1vdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdHcmlkID0gY3Vyci5jbG9uZUFuZEFwcGx5TW92ZShtb3ZlKTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgc2NvcmUgPSBuZXdHcmlkLnRyYXZlbGVkRGlzdCArIG5ld0dyaWQuaGV1cmlzdGljVmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IG5ld0dyaWQudGlsZXMudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gcXVldWUgYW5kIHJlcGxhY2UgYmVzdCBzY29yZSBpZiBzY29yZSBiZXR0ZXIgdGhhbiBwcmV2aW91cyBiZXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IG5vdCB1c2luZyA8LCBhcyBwcmV2aW91cyBiZXN0IGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlcyBpZiBiZXN0IGVpdGhlciB1bmRlZmluZWQgb3IgPj0gY3VycmVudCBzY29yZVxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBvYnZpYXRlcyBuZWVkIGZvciB2aXNpdGVkIHNldCwgYXMgb25seSBhZGRzIG5vZGUgd2hlblxuICAgICAgICAgICAgICAgICAgICAvLyBiZXR0ZXIgdGhhbiBiZXN0IGZvdW5kIHNvIGZhciB2cy4gYWRkaW5nIHdoZW4gYmV0dGVyIHRoYW4gYmVzdCBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyAoYnkgdGhlIHRpbWUgYmVzdCBwb3NzaWJsZSBpcyBmb3VuZCwgc2V2ZXJhbCBub2RlcyBjb3VsZCBiZSBkaXNjYXJkZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgYmVpbmcgd29yc2UgdGhhbiBwcmV2aW91cyBkaXNjb3ZlcmVkIG5vdC15ZXQtcG9wcGVkIG5vZGVzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShzY29yZSA+PSBiZXN0LmdldChrZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5zZXQoa2V5LCBzY29yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmFkZChuZXdHcmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBzb2x1dGlvbiBmb3VuZFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBtYWtlIHVzZSBvZiBtYXhJdGVyYXRpb25zIG9yIHNvbWUgb3RoZXIgbGltaXRpbmcgZnVuY3Rpb24gdG8gc3RvcCBmcmVlemluZyBicm93c2VyXG4gICAgc29sdmVJREFTdGFyKG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgbGV0IGdyaWQgPSBuZXcgR3JpZCh0aGlzLm51bVJvd3MsIHRoaXMubnVtQ29scywgdGhpcy50aWxlcywgdGhpcy5lbXB0eVBvcywgdGhpcy5oZXVyaXN0aWMsIDApO1xuXG4gICAgICAgIC8vIHVwcGVyIGJvdW5kIG9mIHRvdGFsIGRpc3RhbmNlIGZvciB3aGVuIHRvIHN0b3AgZXhwbG9yaW5nIG5vZGVzIGluIGdpdmVuIGl0ZXJhdGlvbiBvZiBkZnNcbiAgICAgICAgbGV0IGJvdW5kID0gZ3JpZC5oZXVyaXN0aWNWYWx1ZTtcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcblxuICAgICAgICB3aGlsZSAodHJ1ZSl7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5fc2VhcmNoSURBU3RhcihncmlkLCBwYXRoLCAwLCBib3VuZCk7XG4gICAgICAgICAgICBpZiAob3V0cHV0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dHB1dCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwcGVyIGJvdW5kIG9mIHNlYXJjaCB1cGRhdGVkIHRvIG1pbiB0b3RhbCBkaXN0YW5jZSBleHBsb3JlZCB0aGF0IHdhc1xuICAgICAgICAgICAgLy8gZ3JlYXRlciB0aGFuIHByZXZpb3VzIGJvdW5kXG4gICAgICAgICAgICBib3VuZCA9IG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfc2VhcmNoSURBU3RhcihncmlkLCBwYXRoLCB0cmF2ZWxlZERpc3QsIGJvdW5kKSB7XG5cbiAgICAgICAgbGV0IHRvdGFsRGlzdCA9IHRyYXZlbGVkRGlzdCArIGdyaWQuaGV1cmlzdGljVmFsdWU7XG5cbiAgICAgICAgaWYgKHRvdGFsRGlzdCA+IGJvdW5kKSByZXR1cm4gdG90YWxEaXN0O1xuICAgICAgICBpZiAoZ3JpZC5pc1NvbHZlZCgpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyB0cmFja3MgbWluIHRvdGFsIGRpc3RhbmNlIG9mIGFsbCBub2RlcyBleHBsb3JlZFxuICAgICAgICBsZXQgbWluVG90YWxEaXN0ID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IG1vdmUgb2YgZ3JpZC5nZXRWYWxpZE1vdmVzKCkpIHtcbiAgICAgICAgICAgIC8vIHJldmVyc2luZyBwcmV2aW91cyBtb3ZlIG5ldmVyIGxlYWRzIHRvIG9wdGltYWwgc29sdXRpb25cbiAgICAgICAgICAgIGlmIChtb3ZlICE9PSBHcmlkLmdldFJldmVyc2VkTW92ZShwYXRoW3BhdGgubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vdmVSZWNvcmQgPSBncmlkLmFwcGx5TW92ZShtb3ZlKTtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobW92ZSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5fc2VhcmNoSURBU3RhcihncmlkLCBwYXRoLCB0cmF2ZWxlZERpc3QgKyAxLCBib3VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCA9PT0gdHJ1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCA8IG1pblRvdGFsRGlzdCkgbWluVG90YWxEaXN0ID0gb3V0cHV0O1xuXG4gICAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBncmlkLnJldmVyc2VNb3ZlKG1vdmVSZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW5Ub3RhbERpc3Q7XG4gICAgfSBcblxuICAgIC8vIFRPRE86IGNvbnNpZGVyIG1vdmluZyBmdW5jdGlvbnMgaW50byBjbG9zdXJlIC8gYXZvaWQgbmVzdGluZyBmb3Igc2xpZ2h0bHkgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgLy8gKG5vIHJlLWluc3RhbnRpYXRpb24gb24gZWFjaCBjYWxsIHRvIHNvbHZlU3RyYXRlZ2ljYWxseSgpKVxuICAgIC8vIGdlbmVyYWwgc3RyYXRlZ3k6XG4gICAgLy8gIyByb3dzICYgIyBjb2x1bW5zID4gMzpcbiAgICAvLyAtIHNvbHZlIGFsbCByb3dzIGJ1dCBcbiAgICBzb2x2ZVN0cmF0ZWdpY2FsbHkoKSB7XG5cbiAgICAgICAgbGV0IGdyaWQgPSBuZXcgU3RyYXRlZ2ljR3JpZCh0aGlzLm51bVJvd3MsIHRoaXMubnVtQ29scywgdGhpcy50aWxlcywgdGhpcy5lbXB0eVBvcyk7XG4gICAgICAgIGxldCBtb3ZlcyA9IFtdO1xuXG4gICAgICAgIGxldCBbZW1wdHlSb3csIGVtcHR5Q29sXSA9IFtncmlkLmdldFRpbGVSb3coZ3JpZC5lbXB0eVBvcyksIGdyaWQuZ2V0VGlsZUNvbChncmlkLmVtcHR5UG9zKV07XG5cbiAgICAgICAgLy8gV0FSTklORzogZG9lcyBOT1QgdXBkYXRlIFtyb3csIGNvbF1cbiAgICAgICAgZnVuY3Rpb24gbW92ZShtb3ZlTGlzdCkge1xuICAgICAgICAgICAgZm9yIChsZXQgbW92ZSBvZiBtb3ZlTGlzdCkge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2gobW92ZSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5hcHBseU1vdmUobW92ZSk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eUNvbCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHlDb2wtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5Um93Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eVJvdy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlcyB0aWxlIGludG8gaXRzIGdvYWxcbiAgICAgICAgLy8gTk9URTogYXNzdW1lcyBwdXp6bGUgZmlsbGVkIGZyb20gdG9wIG9yIGJvdHRvbSwgbGVmdCB0byByaWdodFxuICAgICAgICAvLyBXQVJOSU5HOiBzaG91bGQgTk9UIGJlIHVzZWQgZm9yIGZpbGxpbmcgaW4gY29sdW1ucyBpbnN0ZWFkIG9mIHJvd3MsIGFzIGFzc3VtcHRpb25zXG4gICAgICAgIC8vIHdpbGwgb2Z0ZW4gcmVzdWx0IGluIGludmFsaWQgbW92ZXMvYmFkIHNvbHV0aW9uc1xuICAgICAgICAvLyBzaG91bGQgTk9UIGJlIHVzZWQgZm9yIGxhc3QgMiByb3dzIG9mIHB1enpsZXMgYXMgd2VsbCwgYXMgdGhvc2UgbXVzdCBiZSBzb2x2ZWRcbiAgICAgICAgLy8gY29sdW1uIGJ5IGNvbHVtbiAoc29sdmluZyBhIHNpbmdsZSByb3cgbGVhdmVzIHJlbWFpbmluZyByb3cgbm8gcm9vbSB0byBtYW5ldXZlcilcbiAgICAgICAgZnVuY3Rpb24gbW92ZVRpbGUoaW5kLCBnb2FsSW5kKSB7XG4gICAgICAgICAgICBpZiAoaW5kID09PSBnb2FsSW5kKSByZXR1cm47XG5cbiAgICAgICAgICAgIFtlbXB0eVJvdywgZW1wdHlDb2xdID0gW2dyaWQuZ2V0VGlsZVJvdyhncmlkLmVtcHR5UG9zKSwgZ3JpZC5nZXRUaWxlQ29sKGdyaWQuZW1wdHlQb3MpXTtcblxuICAgICAgICAgICAgbGV0IFtyb3csIGNvbF0gPSBbZ3JpZC5nZXRUaWxlUm93KGluZCksIGdyaWQuZ2V0VGlsZUNvbChpbmQpXTtcbiAgICAgICAgICAgIGxldCBbZ29hbFJvdywgZ29hbENvbF0gPSBbZ3JpZC5nZXRUaWxlUm93KGdvYWxJbmQpLCBncmlkLmdldFRpbGVDb2woZ29hbEluZCldO1xuXG4gICAgICAgICAgICAvLyBtb3ZlcyBlbXB0eSBvdXQgb2YgdGhlIHdheSBvZiBhbHJlYWR5IHNvbHZlZCB0aWxlc1xuICAgICAgICAgICAgLy8gZXhwbGFuYXRpb246IGlmIGVtcHR5IGlzIGluIHJvdyB3aXRoIHNvbHZlZCB0aWxlcywgaXQgbXVzdCBiZSB0byB0aGVpciByaWdodFxuICAgICAgICAgICAgLy8gbW9yZSBzcGVjaWZpY2FsbHksIGl0IHdpbGwgYmUgaW4gdGhlIGdvYWwgY29sIG9mIHRoZSBjdXJyZW50IHRpbGVcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHRpbGUgaXMgdG8gdGhlIGxlZnQgb2YgaXRzIGdvYWwsIGVtcHR5IHdpbGwgbmVlZFxuICAgICAgICAgICAgLy8gdG8gbW92ZSBsZWZ0IHRvIGdldCB0byBpdHMgbGVmdCwgZGlzcGxhY2luZyBzb2x2ZWQgdGlsZXNcbiAgICAgICAgICAgIC8vIHVubGVzcyBpdCBtb3ZlcyBkb3duIChvciBhIHRpbGUgbW92ZXMgdXAgaW50byBpdCkgZmlyc3RcbiAgICAgICAgICAgIGlmIChjb2wgPCBnb2FsQ29sICYmIGVtcHR5Um93ID09PSBnb2FsUm93KSB7XG4gICAgICAgICAgICAgICAgZW1wdHlSb3cgPT09IGdyaWQucm93RW5kIC0gMSA/IG1vdmUoJ2QnKSA6IG1vdmUgKCd1Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChjb2wgPiBnb2FsQ29sKSB7XG4gICAgICAgICAgICAgICAgLy8gdGlsZSBuZWVkcyB0byBtb3ZlIGxlZnQsIHNvIGVtcHR5IHRpbGUgbmVlZHMgdG8gYmUgbW92ZWQgdG8gbGVmdCBvZiB0aWxlXG5cbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBuZWVkcyB0byBtb3ZlIG91dCB0aGUgd2F5IHRvIGdldCB0byB0aGUgbGVmdCBzaWRlIG9mIHRoZSB0aWxlXG4gICAgICAgICAgICAgICAgaWYgKHJvdyA9PT0gZW1wdHlSb3cgJiYgZW1wdHlDb2wgPiBjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBlbXB0eSBhcm91bmQgdGlsZSB0byBhdm9pZCBtb3Zpbmcgc29sdmVkIHRpbGVzXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmlsbGluZyB0b3AsIHRyeSB0byBtb3ZlIGFyb3VuZCBib3R0b20gb2YgdGlsZSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZ29hbFJvdyA9PT0gZ3JpZC5yb3dTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93ID09PSBncmlkLnJvd0VuZCAtIDEgPyBtb3ZlKCdkJykgOiBtb3ZlKCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ29hbFJvdyA9PT0gZ3JpZC5yb3dFbmQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBmaWxsaW5nIGJvdHRvbSwgdHJ5IHRvIG1vdmUgYXJvdW5kIHRvcCBvZiB0aWxlIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgPT09IGdyaWQucm93U3RhcnQgPyBtb3ZlKCd1JykgOiBtb3ZlKCdkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHkgdG8gY29sIGxlZnQgb2YgdGlsZVxuICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eUNvbCA+PSBjb2wpIG1vdmUoJ3InKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPCBjb2wgLSAxKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGVtcHR5IHRvIHJvdyBvZiB0aWxlXG4gICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Um93ID4gcm93KSBtb3ZlICgnZCcpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eVJvdyA8IHJvdykgbW92ZSAoJ3UnKTtcblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGlsZSBsZWZ0XG4gICAgICAgICAgICAgICAgbW92ZSgnbCcpO1xuICAgICAgICAgICAgICAgIGNvbC0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoY29sIDwgZ29hbENvbCkge1xuICAgICAgICAgICAgICAgIC8vIHRpbGUgbmVlZHMgdG8gbW92ZSByaWdodCwgc28gZW1wdHkgdGlsZSBuZWVkcyB0byBiZSBtb3ZlZCB0byByaWdodCBvZiB0aWxlXG5cbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBuZWVkcyB0byBtb3ZlIG91dCB0aGUgd2F5IHRvIGdldCB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdGlsZVxuICAgICAgICAgICAgICAgIGlmIChyb3cgPT09IGVtcHR5Um93ICYmIGVtcHR5Q29sIDwgY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHkgYXJvdW5kIHRpbGUgdG8gYXZvaWQgbW92aW5nIHNvbHZlZCB0aWxlc1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGZpbGxpbmcgdG9wLCB0cnkgdG8gbW92ZSBhcm91bmQgYm90dG9tIG9mIHRpbGUgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdvYWxSb3cgPT09IGdyaWQucm93U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9PT0gZ3JpZC5yb3dFbmQgLSAxID8gbW92ZSgnZCcpIDogbW92ZSgndScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdvYWxSb3cgPT09IGdyaWQucm93RW5kIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmlsbGluZyBib3R0b20sIHRyeSB0byBtb3ZlIGFyb3VuZCB0b3Agb2YgdGlsZSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93ID09PSBncmlkLnJvd1N0YXJ0ID8gbW92ZSgndScpIDogbW92ZSgnZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSBlbXB0eSB0byByaWdodCBvZiB0aWxlXG4gICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sIDw9IGNvbCkgbW92ZSgnbCcpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eUNvbCA+IGNvbCArIDEpIG1vdmUoJ3InKTtcblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHkgdG8gcm93IG9mIHRpbGVcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlSb3cgPiByb3cpIG1vdmUgKCdkJyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Um93IDwgcm93KSBtb3ZlICgndScpO1xuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aWxlIHJpZ2h0XG4gICAgICAgICAgICAgICAgbW92ZSgncicpO1xuICAgICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aWxlIG5vdyBpbiBjb3JyZWN0IGNvbHVtblxuXG4gICAgICAgICAgICB3aGlsZSAocm93ID4gZ29hbFJvdykge1xuICAgICAgICAgICAgICAgIC8vIHRpbGUgbmVlZHMgdG8gbW92ZSB1cCwgc28gdGhlIGVtcHR5IHRpbGUgbmVlZHMgdG8gYmUgbW92ZWQgdG8gdG9wIG9mIHRpbGVcblxuICAgICAgICAgICAgICAgIC8vIGNhbiBtb3ZlIHVwIG5vcm1hbGx5IGFzIGxvbmcgYXNcbiAgICAgICAgICAgICAgICAvLyAtIG5vdCBsYXN0IHRpbGUgaW4gcm93XG4gICAgICAgICAgICAgICAgLy8gLSB0aWxlIGlzIG1vcmUgdGhhbiAyIHRpbGVzIGJlbG93IGdvYWxcbiAgICAgICAgICAgICAgICBpZiAoY29sICE9PSBncmlkLmNvbEVuZCAtIDEgfHwgcm93IC0gMiA+IGdvYWxSb3cpe1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiByb3cgaXMgMSBiZWxvdyBnb2FsIGFuZCBlbXB0eSBpcyB0byB0aGUgbGVmdCBvciBiZWxvdyB0aWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5IG11c3Qgcm90YXRlIGFyb3VuZCB0aGUgYm90dG9tIG9mIHRoZSB0aWxlIHRvIGdldCB0byB0aGUgdG9wXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGFzIG5vdCB0byBkaXNwbGFjZSBwcmV2aW91c2x5IHBsYWNlZCB0aWxlc1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93IC0gMSA9PT0gZ29hbFJvdyAmJiBlbXB0eUNvbCA8PSBjb2wgJiYgZW1wdHlSb3cgPj0gcm93KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHlSb3cgYmVsb3cgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlSb3cgPD0gcm93KSBtb3ZlKCd1Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHlDb2wgdG8gcmlnaHQgb2YgdGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sIDw9IGNvbCkgbW92ZSgnbCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogbmVjZXNzYXJ5IGRlc3BpdGUgY29kZSBibG9jayBhYm92ZSBhcyB0aWxlIGNvdWxkIGJlIGFnYWluc3Qgd2FsbFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGVtcHR5IHVuZGVyIHRpbGUsIG1vdmUgdG8gdGhlIHJpZ2h0IGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGRpc3BsYWNpbmcgcHJldmlvdXNseSBwbGFjZWQgdGlsZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5Um93ID4gcm93ICYmIGVtcHR5Q29sID09PSBjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9PT0gZ3JpZC5jb2xFbmQgLSAxID8gbW92ZSgncicpIDogbW92ZSgnbCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBlbXB0eSByb3cgdG8ganVzdCBhYm92ZSB0aWxlXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eVJvdyA+PSByb3cpIG1vdmUoJ2QnKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Um93IDwgcm93IC0gMSkgbW92ZSgndScpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHkgY29sIHRvIG1hdGNoIHRpbGUnc1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPiBjb2wpIG1vdmUoJ3InKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sIDwgY29sKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB0aWxlIHVwXG4gICAgICAgICAgICAgICAgICAgIG1vdmUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LS07XG4gICAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICAgICAgLy8gbGFzdCB0aWxlIG9mIHJvdyBtdXN0IGJlIHJvdGF0ZWQgaW4gYWxvbmcgd2l0aCBwcmV2aW91cyB0aWxlIGluIHJvd1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugcm90YXRpbmcgYWZmZWN0cyB0aWxlcyBvbiBvbmUgc2lkZSBvZiBhIHRpbGVcbiAgICAgICAgICAgICAgICAvLyBhbmQgYXQgdGhlIGxhc3QgY29sdW1uLCBvbmx5IHRoZSBsZWZ0IGNvbHVtbidzIHRpbGVzIGNhbiBiZSB1c2VkIGZvciByb3RhdGlvblxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aWxlIGluIGxhc3QgY29sIGFuZCByb3cgLSAyIDw9IGdvYWxSb3dcblxuICAgICAgICAgICAgICAgICAgICBpZiAocm93IC0gMSA9PT0gZ29hbFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBkaXJlY3RseSBpbnRvIGdvYWw6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBlbXB0eSBpbiBnb2FsUm93LCBtdXN0IGJlIGRpcmVjdGx5IGFib3ZlIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHByZXZpb3VzbHkgdGlsZXMgYWxyZWFkeSBzb2x2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eVJvdyA9PT0gZ29hbFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgdGlsZSBkb3duIG9uZSB0byBnaXZlIHJvb20gdG8gbWFuZXV2ZXIgcHJldmlvdXMgdGlsZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhYm92ZSBpdFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogZW1wdHkgbXVzdCBiZSB0byBsZWZ0IGFuZC9vciBiZWxvdyB0aWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGlsZSBpcyBpbiByaWdodG1vc3QgY29sdW1uIGFuZCAxIHNwYWNlIGJlbG93IHRoZSB0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZW1wdHkgaXMgbm90IGFib3ZlIGl0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiBlbXB0eSBiZWxvdyB0aWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Um93IDw9IHJvdykgbW92ZSgndScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eUNvbCA8IGNvbCkgbW92ZSgnbCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB0aWxlIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKCdkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB0aWxlIGlzIGluIGxhc3QgY29sIGFuZCByb3cgLSAyID09PSBnb2FsUm93XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBwcmV2aW91cyB0aWxlIGludG8gY3VycmVudCBnb2FsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBlbXB0eSBhcm91bmQgdGlsZSB0byBnZXQgdXAgdG8gcHJldmlvdXMgdGlsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHlSb3cgPiByb3cgJiYgZW1wdHlDb2wgPT09IGNvbCkgbW92ZSgncicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGF2b2lkIHByZXZpb3VzbHkgc29sdmVkIHRpbGVzIHdoaWxlIGdvaW5nIHVwIGFuZCBhcm91bmQgdGlsZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlSb3cgPiBnb2FsUm93ICsgMSkgbW92ZSgnZCcpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPCBnb2FsQ29sKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBlbXB0eSB0byBnb2FsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eVJvdyA+IGdvYWxSb3cpIG1vdmUoJ2QnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHN0YXRlOlxuICAgICAgICAgICAgICAgICAgICAvLyB0aWxlIDIgc3BhY2VzIGJlbG93IGdvYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgdGlsZXMgaW4gdGhlaXIgZ29hbHNcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHkgdGlsZSAxIHNwYWNlIHJpZ2h0IG9mIHByZXZpb3VzIHRpbGUgKGN1cnJlbnQgdGlsZSdzIGdvYWwgcG9zaXRpb24pXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcm90YXRlIGxhc3QgMiB0aWxlcyBpbiByb3cgaW50byBwbGFjZVxuICAgICAgICAgICAgICAgICAgICBtb3ZlKCdydWx1cmRkbHUnKTtcblxuICAgICAgICAgICAgICAgICAgICByb3cgPSBnb2FsUm93O1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChyb3cgPCBnb2FsUm93KSB7XG4gICAgICAgICAgICAgICAgLy8gdGlsZSBuZWVkcyB0byBtb3ZlIGRvd24sIHNvIHRoZSBlbXB0eSB0aWxlIG5lZWRzIHRvIGJlIG1vdmVkIHRvIGJvdHRvbSBvZiB0aWxlXG5cbiAgICAgICAgICAgICAgICBpZiAoY29sICE9PSBncmlkLmNvbEVuZCAtIDEgfHwgcm93ICsgMiA8IGdvYWxSb3cpe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5IG5lZWRzIHRvIG1vdmUgb3V0IG9mIHRoZSB3YXkgdG8gZ2V0IHRvIHRoZSBib3R0b20gb2YgdGhlIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXMgY3VycmVudGx5IHRvIHRpbGUncyB0b3AvbGVmdCBhbmQgbmVlZHMgdG8gbW92ZSB0byB0aWxlJ3MgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cgKyAxID09PSBnb2FsUm93ICYmIGVtcHR5Q29sIDw9IGNvbCAmJiBlbXB0eVJvdyA8PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eVJvdyA+PSByb3cpIG1vdmUoJ2QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eUNvbCA8PSBjb2wpIG1vdmUoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHkgYXJvdW5kIHRpbGUgaWYgaW4gc2FtZSBjb2x1bW4gYW5kIGVtcHR5IGFib3ZlIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gKGRpZmZlcmVudCBmcm9tIGFib3ZlLCBhcyBhYm92ZSBvbmx5IG5lY2Vzc2FyeSBpZiB0aWxlIGlzIHRvb1xuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSB0byBnb2FsIGFuZCBub3QgYXMgZ29vZCBhIHNvbHV0aW9uIHdoZW4gdGlsZSBpcyBmYXJ0aGVyIGF3YXkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2wgPT09IGVtcHR5Q29sICYmIGVtcHR5Um93IDwgcm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgPT09IGdyaWQuY29sRW5kIC0gMSA/IG1vdmUoJ3InKSA6IG1vdmUoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHkgdG8gYm90dG9tIG9mIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Um93IDw9IHJvdykgbW92ZSgndScpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlSb3cgPiByb3cgKyAxKSBtb3ZlKCdkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBlbXB0eSB0byBjb2wgb2YgdGlsZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPiBjb2wpIG1vdmUoJ3InKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sIDwgY29sKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB0aWxlIGRvd25cbiAgICAgICAgICAgICAgICAgICAgbW92ZSgnZCcpO1xuICAgICAgICAgICAgICAgICAgICByb3crKzsgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxhc3QgdGlsZSBvZiBib3R0b20gcm93IG5lZWRzIHRvIGJlIHJvdGF0ZWQgaW4gYWxvbmcgd2l0aCBwcmV2aW91cyB0aWxlLFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW1pbGFyIHRvIGxhc3QgdGlsZSBvZiB0b3Agcm93XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGlsZSBpbiBjb3JyZWN0IGNvbCBhbmQgZWl0aGVyIDEgb3IgMiBzcGFjZXMgYWJvdmUgZ29hbFxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cgKyAxID09PSBnb2FsUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHRpbGUgZGlyZWN0bHkgaW50byBwbGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5Um93ID09PSBnb2FsUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZSgnZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB0aWxlIHVwIHRvIGdpdmUgcm9vbSBmb3IgcHJldmlvdXMgdGlsZSB0byBtYW5ldXZlclxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Um93ID49IHJvdykgbW92ZSgnZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eUNvbCA8IGNvbCkgbW92ZSgnbCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZSgndScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGlsZSBpcyBub3cgMiBzcGFjZXMgYWJvdmUgZ29hbFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgcHJldmlvdXMgdGlsZSBpbnRvIGN1cnJlbnQgZ29hbFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHkgYXJvdW5kIHRpbGUgdG8gZ2V0IHVwIHRvIHByZXZpb3VzIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5Um93IDwgcm93ICYmIGVtcHR5Q29sID09PSBjb2wpIG1vdmUoJ3InKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlSb3cgPCBnb2FsUm93IC0gMSkgbW92ZSgndScpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPCBnb2FsQ29sKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBlbXB0eSB0byBnb2FsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eVJvdyA8IGdvYWxSb3cpIG1vdmUoJ3UnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJlbnQgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRpbGUgMiBzcGFjZXMgYWJvdmUgZ29hbFxuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB0aWxlcyBpbiBnb2FsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5IHRpbGUgMSBzcGFjZSByaWdodCBvZiBwcmV2aW91cyB0aWxlIChjdXJyZW50IHRpbGUncyBnb2FsIHBvc2l0aW9uKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJvdGF0ZSBsYXN0IDIgdGlsZXMgaW50byBwbGFjZVxuICAgICAgICAgICAgICAgICAgICBtb3ZlKCdyZGxkcnV1bGQnKTtcblxuICAgICAgICAgICAgICAgICAgICByb3cgPSBnb2FsUm93O1xuICAgICAgICAgICAgICAgIH0gICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVtcHR5R29hbCA9IGdyaWQudGlsZXNbZ3JpZC5lbXB0eVBvc107XG5cbiAgICAgICAgLy8gc29sdmVzIDEgZGltZW5zaW9uYWwgcHV6emxlc1xuICAgICAgICBpZiAoZ3JpZC5udW1Sb3dzID09PSAxKSB7XG4gICAgICAgICAgICB3aGlsZSAoZ3JpZC5lbXB0eVBvcyA8IGVtcHR5R29hbCkgbW92ZSgnbCcpO1xuICAgICAgICAgICAgd2hpbGUgKGdyaWQuZW1wdHlQb3MgPiBlbXB0eUdvYWwpIG1vdmUoJ3InKTtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlcztcbiAgICAgICAgfSBlbHNlIGlmIChncmlkLm51bUNvbHMgPT09IDEpIHtcbiAgICAgICAgICAgIHdoaWxlIChncmlkLmVtcHR5UG9zIDwgZW1wdHlHb2FsKSBtb3ZlICgndScpO1xuICAgICAgICAgICAgd2hpbGUgKGdyaWQuZW1wdHlQb3MgPiBlbXB0eUdvYWwpIG1vdmUoJ2QnKTtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlbXB0eUdvYWxSb3cgPSBncmlkLmdldFRpbGVSb3coZW1wdHlHb2FsKTtcbiAgICAgICAgbGV0IGVtcHR5R29hbENvbCA9IGdyaWQuZ2V0VGlsZUNvbChlbXB0eUdvYWwpO1xuXG4gICAgICAgIC8vIGZpbGwgZWFjaCByb3cgbGVmdCB0byByaWdodCwgdG9wIHRvIGJvdHRvbSB1bnRpbCBlbXB0eSB0aWxlJ3Mgcm93IHJlYWNoXG4gICAgICAgIC8vIG9yIDIgcm93cyByZW1haW5pbmdcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgTWF0aC5taW4oZW1wdHlHb2FsUm93LCBncmlkLm51bVJvd3MgLSAyKTsgcm93KyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGdyaWQubnVtQ29scyAqIHJvdztcblxuICAgICAgICAgICAgZm9yIChsZXQgZ29hbCA9IHN0YXJ0OyBnb2FsIDwgc3RhcnQgKyBncmlkLm51bUNvbHM7IGdvYWwrKykge1xuICAgICAgICAgICAgICAgIGxldCBpbmQgPSBncmlkLmdvYWxzW2dvYWxdO1xuXG4gICAgICAgICAgICAgICAgbW92ZVRpbGUoaW5kLCBnb2FsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JpZC5yb3dTdGFydCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcm93ID0gZ3JpZC5udW1Sb3dzIC0gMTsgcm93ID4gZW1wdHlHb2FsUm93ICsgMTsgcm93LS0pIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGdyaWQubnVtQ29scyAqIHJvdztcblxuICAgICAgICAgICAgZm9yIChsZXQgZ29hbCA9IHN0YXJ0OyBnb2FsIDwgc3RhcnQgKyBncmlkLm51bUNvbHM7IGdvYWwrKykge1xuICAgICAgICAgICAgICAgIGxldCBpbmQgPSBncmlkLmdvYWxzW2dvYWxdO1xuXG4gICAgICAgICAgICAgICAgbW92ZVRpbGUoaW5kLCBnb2FsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWQucm93RW5kLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1haW5pbmcgdW5zb2x2ZWQgcHV6emxlIGlzIG5vdyAyeE4gKHdoZXJlIE4gaXMgYXJiaXRyYXJ5IGludGVnZXIpXG5cbiAgICAgICAgY29uc29sZS5sb2coZ3JpZC5yb3dTdGFydCwgZ3JpZC5yb3dFbmQsIGdyaWQuY29sU3RhcnQsIGdyaWQuY29sRW5kKTtcbiAgICAgICAgY29uc29sZS5sb2cobW92ZXMpO1xuXG4gICAgICAgIGxldCBlbXB0eUNvbEdvYWwgPSBncmlkLmdldFRpbGVDb2woZ3JpZC50aWxlc1tncmlkLmVtcHR5UG9zXSk7XG5cbiAgICAgICAgLy8gZmlsbCBpbiBmcm9tIGxlZnQgdG8gcmlnaHQgdW50aWwgZW1wdHkgdGlsZSBjb2wgcmVhY2hlZCBvciAyeDIgc3F1YXJlIHJlbWFpbmluZ1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBNYXRoLm1pbihncmlkLm51bUNvbHMgLSAyLCBlbXB0eUNvbEdvYWwpOyBjb2wrKykge1xuXG4gICAgICAgICAgICAvLyBnb2FsIGFuZCBjdXJyZW50IGluZGljZXMgb2YgdG9wIHRpbGUgb2YgbGVmdG1vc3QgY29sdW1uXG4gICAgICAgICAgICBsZXQgdG9wR29hbCA9IGdyaWQuZ2V0SW5kZXgoZ3JpZC5yb3dTdGFydCwgZ3JpZC5jb2xTdGFydCk7XG4gICAgICAgICAgICBsZXQgdG9wSW5kID0gZ3JpZC5nb2Fsc1t0b3BHb2FsXTtcblxuICAgICAgICAgICAgLy8gbW92ZSB0b3AgdGlsZSB0byBpdHMgZ29hbFxuICAgICAgICAgICAgbW92ZVRpbGUodG9wSW5kLCB0b3BHb2FsKTtcblxuICAgICAgICAgICAgLy8gZ29hbCBhbmQgY3VycmVudCBpbmRpY2VzIG9mIGJvdHRvbSB0aWxlIG9mIGxlZnRtb3N0IGNvbHVtblxuICAgICAgICAgICAgbGV0IGJvdHRvbUdvYWwgPSB0b3BHb2FsICsgZ3JpZC5udW1Db2xzO1xuICAgICAgICAgICAgbGV0IGJvdHRvbUluZCA9IGdyaWQuZ29hbHNbYm90dG9tR29hbF07XG5cbiAgICAgICAgICAgIGlmIChib3R0b21JbmQgPT09IGJvdHRvbUdvYWwpIHtcbiAgICAgICAgICAgICAgICBncmlkLmNvbFN0YXJ0Kys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGN1cnJlbnQgY29vcmRzIG9mIHRpbGUgdGhhdCBiZWxvbmdzIG9uIHRoZSBib3R0b20gb2YgdGhlIGxlZnRtb3N0IGNvbHVtblxuICAgICAgICAgICAgbGV0IGJvdHRvbUNvbCA9IGdyaWQuZ2V0VGlsZUNvbChib3R0b21JbmQpO1xuICAgICAgICAgICAgbGV0IGJvdHRvbVJvdyA9IGdyaWQuZ2V0VGlsZVJvdyhib3R0b21JbmQpO1xuXG4gICAgICAgICAgICAvLyB0b3AgdGlsZSBpcyBvY2N1cGllZCwgc28gZW1wdHlDb2wgbXVzdCBiZSBpbiBib3R0b20gbGVmdCBjb3JuZXJcbiAgICAgICAgICAgIC8vIGlmIGJvdHRvbSB0aWxlIGlzIG9uZSBhd2F5LCBjYW4gbW92ZSBkaXJlY3RseSBpbnRvIGdvYWxcbiAgICAgICAgICAgIGlmIChlbXB0eUNvbCA9PT0gZ3JpZC5jb2xTdGFydCAmJiBncmlkLmVtcHR5UG9zICsgMSA9PT0gYm90dG9tSW5kKSB7XG4gICAgICAgICAgICAgICAgbW92ZSgnbCcpO1xuICAgICAgICAgICAgICAgIGdyaWQuY29sU3RhcnQrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlOlxuICAgICAgICAgICAgLy8gdGlsZSBuZWVkcyB0byBiZSByb3RhdGVkIGluIHNpbWlsYXJseSB0byB0b3AgYW5kIGJvdHRvbSB0aWxlc1xuICAgICAgICAgICAgLy8gY2Fubm90IHVzZSBtb3ZlVGlsZSgpIGFzIGFib3ZlLCBhcyBjZXJ0YWluIGFzc3VtcHRpb25zIG9uXG4gICAgICAgICAgICAvLyBmaWxsIG9yZGVyIG5vIGxvbmdlciBob2xkIHRydWVcblxuICAgICAgICAgICAgLy8gbW92ZSBib3R0b20gdGlsZSB0byAyIHNwYWNlcyByaWdodCBvZiBpdHMgZ29hbFxuXG4gICAgICAgICAgICAvLyBmaXJzdCBtb3ZlIHRpbGUgaW50byBib3R0b20gcm93XG5cbiAgICAgICAgICAgIHdoaWxlIChib3R0b21Sb3cgPCBncmlkLnJvd0VuZCAtIDEpIHtcblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBib3R0b20gcm93XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5Um93ID09PSBncmlkLnJvd1N0YXJ0KSBtb3ZlKCd1Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGJlbG93IHRpbGVcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPiBib3R0b21Db2wpIG1vdmUoJ3InKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPCBib3R0b21Db2wpIG1vdmUoJ2wnKTtcblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGlsZSBpbnRvIGJvdHRvbSByb3dcbiAgICAgICAgICAgICAgICBtb3ZlKCdkJyk7XG4gICAgICAgICAgICAgICAgYm90dG9tUm93Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZW4gbW92ZSB0aWxlIGludG8gY29ycmVjdCBjb2xcblxuICAgICAgICAgICAgLy8gdGlsZSBpcyBtb3JlIHRoYW4gMiBzcGFjZXMgcmlnaHQgZnJvbSBmaW5hbCBnb2FsXG4gICAgICAgICAgICB3aGlsZSAoYm90dG9tQ29sID4gY29sICsgMikge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgZW1wdHkgYXJvdW5kIHRpbGUgdG8gZ2V0IHRvIGl0cyBsZWZ0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmIChlbXB0eVJvdyA9PT0gYm90dG9tUm93ICYmIGVtcHR5Q29sID4gYm90dG9tQ29sKSBtb3ZlKCdkJyk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPj0gYm90dG9tQ29sKSBtb3ZlKCdyJyk7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5Um93IDwgYm90dG9tUm93KSBtb3ZlKCd1Jyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sIDwgYm90dG9tQ29sKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgICAgICBib3R0b21Db2wtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGlsZSBpcyBvbmUgcmlnaHQgb2YgZmluYWwgZ29hbCAoMSB0aWxlIGxlZnQgb2YgaW50ZXJtZWRpYXRlIGdvYWwpXG4gICAgICAgICAgICB3aGlsZSAoYm90dG9tQ29sIDwgY29sICsgMikge1xuXG4gICAgICAgICAgICAgICAgLy8gbWFuZXV2ZXIgZW1wdHkgdG8gcmlnaHQgb2YgZ29hbFxuICAgICAgICAgICAgICAgIGlmIChlbXB0eUNvbCA9PT0gYm90dG9tQ29sKSBtb3ZlKCdsJyk7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5Um93ID09PSBncmlkLnJvd1N0YXJ0KSBtb3ZlKCd1Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGJvdHRvbSBjb2wgb25lIHJpZ2h0XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sID4gYm90dG9tQ29sKSBtb3ZlKCdyJyk7XG5cbiAgICAgICAgICAgICAgICBib3R0b21Db2wrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGlsZSBpcyBub3cgMiBzcGFjZXMgcmlnaHQgb2YgZ29hbFxuXG4gICAgICAgICAgICAvLyBuZWVkIHRvIG1vdmUgdG9wIHRpbGUgb25lIGRvd24gaW4gcHJlcGFyYXRpb24gZm9yIHJvdGF0aW5nIDIgdGlsZXMgaW5cblxuICAgICAgICAgICAgLy8gbW92ZSBhcm91bmQgdGlsZSB0byBnZXQgYmVsb3cgdG9wIHRpbGUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAoZW1wdHlDb2wgPiBib3R0b21Db2wgJiYgZW1wdHlSb3cgPT09IGJvdHRvbVJvdykgbW92ZSgnZCcpO1xuICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sID49IGJvdHRvbUNvbCkgbW92ZSgncicpO1xuXG4gICAgICAgICAgICBpZiAoZW1wdHlSb3cgPT09IGdyaWQucm93U3RhcnQpIG1vdmUoJ3UnKTtcbiAgICAgICAgICAgIHdoaWxlIChlbXB0eUNvbCA+IGdyaWQuY29sU3RhcnQpIG1vdmUoJ3InKTtcblxuICAgICAgICAgICAgLy8gY3VycmVudCBzdGF0ZTpcbiAgICAgICAgICAgIC8vIGVtcHR5IHRpbGUgaW4gYm90dG9tIGdvYWxcbiAgICAgICAgICAgIC8vIHRvcCB0aWxlIGluIHRvcCBnb2FsXG4gICAgICAgICAgICAvLyBib3R0b20gdGlsZSAyIHRpbGVzIHJpZ2h0IG9mIGJvdHRvbSBnb2FsXG5cbiAgICAgICAgICAgIC8vIHJvdGF0ZSBib3RoIHRpbGVzIGludG8gcGxhY2VcbiAgICAgICAgICAgIG1vdmUoJ2RsdWxkcnJ1bCcpO1xuXG4gICAgICAgICAgICBncmlkLmNvbFN0YXJ0Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvLyBmaWxsIGluIGZyb20gcmlnaHQgdG8gbGVmdCB1bnRpbCAyeDIgc3F1YXJlIHJlbWFpbmluZ1xuICAgICAgICBmb3IgKGxldCBjb2wgPSBncmlkLm51bUNvbHMgLSAxOyBjb2wgPiBlbXB0eUNvbEdvYWwgKyAxOyBjb2wtLSkge1xuXG4gICAgICAgICAgICAvLyBnb2FsIGFuZCBjdXJyZW50IGluZGljZXMgb2YgdG9wIHRpbGUgb2YgbGVmdG1vc3QgY29sdW1uXG4gICAgICAgICAgICBsZXQgdG9wR29hbCA9IGdyaWQuZ2V0SW5kZXgoZ3JpZC5yb3dTdGFydCwgZ3JpZC5jb2xFbmQgLSAxKTtcbiAgICAgICAgICAgIGxldCB0b3BJbmQgPSBncmlkLmdvYWxzW3RvcEdvYWxdO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIHRvcCB0aWxlIHRvIGl0cyBnb2FsXG4gICAgICAgICAgICAvLyBOT1RFOiBjYW4ndCB1c2UgbW92ZVRpbGUgYXMgcmVsaWVzIG9uIGFzc3VtcHRpb25zIGxpa2U6XG4gICAgICAgICAgICAvLyB0aWxlcyB0byBsZWZ0IGluIGdvYWxSb3cgYXJlIGZpbGxlZCBpbiBhbmQgY2FuJ3QgYmUgbW9kaWZpZWRcbiAgICAgICAgICAgIC8vIG1vZGlmeWluZyBtb3ZlVGlsZSgpIHRvIHdvcmsgd2l0aCByaWdodC10by1sZWZ0IHdvdWxkXG4gICAgICAgICAgICAvLyBtYWtlIHRoZSBmdW5jdGlvbiBtb3JlIGNvbmZ1c2luZ1xuXG4gICAgICAgICAgICBsZXQgdG9wQ29sID0gZ3JpZC5nZXRUaWxlQ29sKHRvcEluZCk7XG4gICAgICAgICAgICBsZXQgdG9wUm93ID0gZ3JpZC5nZXRUaWxlUm93KHRvcEluZCk7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgdG9wIHRpbGUgaW50byBjb3JyZWN0IHJvd1xuICAgICAgICAgICAgaWYgKHRvcFJvdyA+IGdyaWQucm93U3RhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHlSb3cgPT09IGdyaWQucm93RW5kIC0gMSkgbW92ZSgnZCcpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eUNvbCA8IHRvcENvbCkgbW92ZSgnbCcpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eUNvbCA+IHRvcENvbCkgbW92ZSgncicpO1xuXG4gICAgICAgICAgICAgICAgbW92ZSgndScpO1xuICAgICAgICAgICAgICAgIHRvcFJvdy0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb3ZlIHRvcCB0aWxlIGludG8gY29ycmVjdCBjb2xcbiAgICAgICAgICAgIHdoaWxlICh0b3BDb2wgPCBncmlkLmNvbEVuZCAtIDEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGVtcHR5IGFyb3VuZCB0aWxlIHRvIGdldCB0byByaWdodCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHlDb2wgPCB0b3BDb2wgJiYgZW1wdHlSb3cgPT09IHRvcFJvdykgbW92ZSgndScpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sIDw9IHRvcENvbCkgbW92ZSgnbCcpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbXB0eUNvbCA+IHRvcENvbCArIDEpIG1vdmUoJ3InKTtcblxuICAgICAgICAgICAgICAgIGlmIChlbXB0eVJvdyA+IHRvcFJvdykgbW92ZSgnZCcpO1xuXG4gICAgICAgICAgICAgICAgbW92ZSgncicpO1xuICAgICAgICAgICAgICAgIHRvcENvbCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnb2FsIGFuZCBjdXJyZW50IGluZGljZXMgb2YgYm90dG9tIHRpbGUgb2YgbGVmdG1vc3QgY29sdW1uXG4gICAgICAgICAgICBsZXQgYm90dG9tR29hbCA9IHRvcEdvYWwgKyBncmlkLm51bUNvbHM7XG4gICAgICAgICAgICBsZXQgYm90dG9tSW5kID0gZ3JpZC5nb2Fsc1tib3R0b21Hb2FsXTtcblxuICAgICAgICAgICAgaWYgKGJvdHRvbUluZCA9PT0gYm90dG9tR29hbCkge1xuICAgICAgICAgICAgICAgIGdyaWQuY29sRW5kLS07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGN1cnJlbnQgY29vcmRzIG9mIHRpbGUgdGhhdCBiZWxvbmdzIG9uIHRoZSBib3R0b20gb2YgdGhlIGxlZnRtb3N0IGNvbHVtblxuICAgICAgICAgICAgbGV0IGJvdHRvbUNvbCA9IGdyaWQuZ2V0VGlsZUNvbChib3R0b21JbmQpO1xuICAgICAgICAgICAgbGV0IGJvdHRvbVJvdyA9IGdyaWQuZ2V0VGlsZVJvdyhib3R0b21JbmQpO1xuXG4gICAgICAgICAgICAvLyB0b3AgdGlsZSBpcyBvY2N1cGllZCwgc28gZW1wdHlDb2wgbXVzdCBiZSBpbiBib3R0b20gcmlnaHQgY29ybmVyXG4gICAgICAgICAgICAvLyBpZiBib3R0b20gdGlsZSBpcyBvbmUgYXdheSwgY2FuIG1vdmUgZGlyZWN0bHkgaW50byBnb2FsXG4gICAgICAgICAgICBpZiAoZW1wdHlDb2wgPT09IGdyaWQuY29sRW5kIC0gMSAmJiBncmlkLmVtcHR5UG9zIC0gMSA9PT0gYm90dG9tSW5kKSB7XG4gICAgICAgICAgICAgICAgbW92ZSgncicpO1xuICAgICAgICAgICAgICAgIGdyaWQuY29sRW5kLS07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1vdmUgYm90dG9tIHRpbGUgMiB0aWxlcyBsZWZ0IG9mIGdvYWwgaW4gcHJlcGFyYXRpb24gb2Ygcm90YXRpbmcgMiB0aWxlcyBpblxuXG4gICAgICAgICAgICAvLyBmaXJzdCBtb3ZlIHRpbGUgaW50byBib3R0b20gcm93XG5cbiAgICAgICAgICAgIHdoaWxlIChib3R0b21Sb3cgPCBncmlkLnJvd0VuZCAtIDEpIHtcblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBib3R0b20gcm93XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5Um93ID09PSBncmlkLnJvd1N0YXJ0KSBtb3ZlKCd1Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGJlbG93IHRpbGVcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPiBib3R0b21Db2wpIG1vdmUoJ3InKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPCBib3R0b21Db2wpIG1vdmUoJ2wnKTtcblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGlsZSBpbnRvIGJvdHRvbSByb3dcbiAgICAgICAgICAgICAgICBtb3ZlKCdkJyk7XG4gICAgICAgICAgICAgICAgYm90dG9tUm93Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZW4gbW92ZSB0aWxlIGludG8gY29ycmVjdCBjb2xcblxuICAgICAgICAgICAgLy8gdGlsZSBpcyBtb3JlIHRoYW4gMiBzcGFjZXMgbGVmdCBmcm9tIGZpbmFsIGdvYWxcbiAgICAgICAgICAgIHdoaWxlIChib3R0b21Db2wgPCBjb2wgLSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBlbXB0eSBhcm91bmQgdGlsZSB0byBnZXQgdG8gaXRzIHJpZ2h0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmIChlbXB0eVJvdyA9PT0gYm90dG9tUm93ICYmIGVtcHR5Q29sIDwgYm90dG9tQ29sKSBtb3ZlKCdkJyk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPD0gYm90dG9tQ29sKSBtb3ZlKCdsJyk7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5Um93IDwgYm90dG9tUm93KSBtb3ZlKCd1Jyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sID4gYm90dG9tQ29sKSBtb3ZlKCdyJyk7XG5cbiAgICAgICAgICAgICAgICBib3R0b21Db2wrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGlsZSBpcyBvbmUgbGVmdCBvZiBmaW5hbCBnb2FsICgxIHRpbGUgcmlnaHQgb2YgaW50ZXJtZWRpYXRlIGdvYWwpXG4gICAgICAgICAgICB3aGlsZSAoYm90dG9tQ29sID4gY29sIC0gMikge1xuXG4gICAgICAgICAgICAgICAgLy8gbWFuZXV2ZXIgZW1wdHkgdG8gcmlnaHQgb2YgZ29hbFxuICAgICAgICAgICAgICAgIGlmIChlbXB0eUNvbCA9PT0gYm90dG9tQ29sKSBtb3ZlKCdyJyk7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5Um93ID09PSBncmlkLnJvd1N0YXJ0KSBtb3ZlKCd1Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGJvdHRvbSBjb2wgb25lIHJpZ2h0XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sIDwgYm90dG9tQ29sKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgICAgICBib3R0b21Db2wtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGlsZSBpcyBub3cgMiBzcGFjZXMgbGVmdCBvZiBnb2FsXG5cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gbW92ZSB0b3AgdGlsZSBvbmUgZG93biBpbiBwcmVwYXJhdGlvbiBmb3Igcm90YXRpbmcgMiB0aWxlcyBpblxuXG4gICAgICAgICAgICAvLyBtb3ZlIGFyb3VuZCB0aWxlIHRvIGdldCBiZWxvdyB0b3AgdGlsZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGlmIChlbXB0eUNvbCA8IGJvdHRvbUNvbCAmJiBlbXB0eVJvdyA9PT0gYm90dG9tUm93KSBtb3ZlKCdkJyk7XG4gICAgICAgICAgICB3aGlsZSAoZW1wdHlDb2wgPD0gYm90dG9tQ29sKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgIGlmIChlbXB0eVJvdyA9PT0gZ3JpZC5yb3dTdGFydCkgbW92ZSgndScpO1xuICAgICAgICAgICAgd2hpbGUgKGVtcHR5Q29sIDwgZ3JpZC5jb2xFbmQgLSAxKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgIC8vIGN1cnJlbnQgc3RhdGU6XG4gICAgICAgICAgICAvLyBlbXB0eSB0aWxlIGluIGJvdHRvbSBnb2FsXG4gICAgICAgICAgICAvLyB0b3AgdGlsZSBpbiB0b3AgZ29hbFxuICAgICAgICAgICAgLy8gYm90dG9tIHRpbGUgMiB0aWxlcyBsZWZ0IG9mIGJvdHRvbSBnb2FsXG5cbiAgICAgICAgICAgIC8vIHJvdGF0ZSBib3RoIHRpbGVzIGludG8gcGxhY2VcbiAgICAgICAgICAgIG1vdmUoJ2RydXJkbGx1cicpO1xuXG4gICAgICAgICAgICBncmlkLmNvbEVuZC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc29sdmUgcmVtYWluaW5nIDJ4MiBwdXp6bGVcblxuICAgICAgICAvLyBPbmNlIDIgdGlsZXMgKGluY2x1ZGluZyBlbXB0eSkgYXJlIHNvbHZlZCwgXG4gICAgICAgIC8vIHJlbWFpbmluZyAyIG11c3QgYmUgYWxyZWFkeSBzb2x2ZWQgaWYgcHV6emxlIGlzIHNvbHZhYmxlXG5cbiAgICAgICAgLy8gTk9URTogbW92ZVRpbGUgaXMgb25seSB1c2VkIGZvciB0b3AtbGVmdCBhbmQgYm90dG9tLWxlZnQgdGlsZXNcbiAgICAgICAgLy8gYXMgZmlsbC1vcmRlciBhc3N1bXB0aW9ucyBtZWFuIHVzaW5nIGl0IGZvciB0aWxlcyBvbiB0aGUgcmlnaHRcbiAgICAgICAgLy8gd29uJ3Qgd29ya1xuXG4gICAgICAgIGxldCB0b3BMZWZ0R29hbCA9IGdyaWQuZ2V0SW5kZXgoZ3JpZC5yb3dTdGFydCwgZ3JpZC5jb2xTdGFydCk7XG4gICAgICAgIGlmICh0b3BMZWZ0R29hbCAhPT0gZW1wdHlHb2FsKSB7XG4gICAgICAgICAgICAvLyBzb2x2ZSB0b3AtbGVmdCB0aWxlXG4gICAgICAgICAgICBtb3ZlVGlsZShncmlkLmdvYWxzW3RvcExlZnRHb2FsXSwgdG9wTGVmdEdvYWwpO1xuXG4gICAgICAgICAgICAvLyBpZiBlbXB0eSBuZWVkcyB0byBtb3ZlIGxlZnQsIGl0cyBnb2FsIGlzIGJvdHRvbS1sZWZ0IHRpbGVcbiAgICAgICAgICAgIGlmIChlbXB0eUNvbCA+IGVtcHR5R29hbENvbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eVJvdyA8IGVtcHR5R29hbFJvdykgbW92ZSgndScpO1xuICAgICAgICAgICAgICAgIG1vdmUoJ3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbXB0eUNvbCA8IGVtcHR5R29hbENvbCkgbW92ZSgnbCcpO1xuXG4gICAgICAgICAgICBpZiAoZW1wdHlSb3cgPiBlbXB0eUdvYWxSb3cpIG1vdmUoJ2QnKTtcbiAgICAgICAgICAgIGlmIChlbXB0eVJvdyA8IGVtcHR5R29hbFJvdykgbW92ZSgndScpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGJvdHRvbUxlZnRHb2FsID0gdG9wTGVmdEdvYWwgKyBncmlkLm51bUNvbHM7XG4gICAgICAgIGlmIChib3R0b21MZWZ0R29hbCAhPT0gZW1wdHlHb2FsKSB7XG4gICAgICAgICAgICAvLyBzb2x2ZSBib3R0b20tbGVmdCB0aWxlXG4gICAgICAgICAgICBtb3ZlVGlsZShncmlkLmdvYWxzW2JvdHRvbUxlZnRHb2FsXSwgYm90dG9tTGVmdEdvYWwpO1xuXG4gICAgICAgICAgICAvLyBpZiBlbXB0eSBuZWVkcyB0byBtb3ZlIGxlZnQsIGl0cyBnb2FsIGlzIHRvcC1sZWZ0IHRpbGVcbiAgICAgICAgICAgIGlmIChlbXB0eUNvbCA+IGVtcHR5R29hbENvbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eVJvdyA+IGVtcHR5R29hbFJvdykgbW92ZSgnZCcpO1xuICAgICAgICAgICAgICAgIG1vdmUoJ3InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVtcHR5Q29sIDwgZW1wdHlHb2FsQ29sKSBtb3ZlKCdsJyk7XG5cbiAgICAgICAgICAgIGlmIChlbXB0eVJvdyA+IGVtcHR5R29hbFJvdykgbW92ZSgnZCcpO1xuICAgICAgICAgICAgaWYgKGVtcHR5Um93IDwgZW1wdHlHb2FsUm93KSBtb3ZlKCd1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBtb3ZlcztcbiAgICB9XG5cbn1cblxuY2xhc3MgQmFzZUdyaWQge1xuICAgIGNvbnN0cnVjdG9yKG51bVJvd3MsIG51bUNvbHMsIHRpbGVzLCBlbXB0eVBvcykge1xuICAgICAgICB0aGlzLm51bVJvd3MgPSBudW1Sb3dzO1xuICAgICAgICB0aGlzLm51bUNvbHMgPSBudW1Db2xzO1xuICAgICAgICB0aGlzLnRpbGVzID0gdGlsZXM7XG4gICAgICAgIHRoaXMuZW1wdHlQb3MgPSBlbXB0eVBvcztcbiAgICB9XG5cbiAgICBnZXRUaWxlQ29sKGluZCkge1xuICAgICAgICByZXR1cm4gaW5kICUgdGhpcy5udW1Db2xzO1xuICAgIH1cblxuICAgIGdldFRpbGVSb3coaW5kKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGluZCAvIHRoaXMubnVtQ29scyk7XG4gICAgfVxuXG4gICAgZ2V0SW5kZXgocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHJvdyAqIHRoaXMubnVtQ29scyArIGNvbDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UmV2ZXJzZWRNb3ZlKG1vdmUpIHtcbiAgICAgICAgcmV0dXJuIFJFVkVSU0VfTU9WRV9NQVBbbW92ZV07XG4gICAgfVxuXG4gICAgc3dhcChwb3MxLCBwb3MyKSB7XG4gICAgICAgIFt0aGlzLnRpbGVzW3BvczFdLCB0aGlzLnRpbGVzW3BvczJdXSA9IFt0aGlzLnRpbGVzW3BvczJdLCB0aGlzLnRpbGVzW3BvczFdXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGNoYW5nZSBpbiBpbmRleCBvZiB0aWxlIHRvIGJlIG1vdmVkIGFmdGVyIG1vdmVcbiAgICBnZXRNb3ZlRGVsdGEobW92ZSkge1xuICAgICAgICBsZXQgbW92ZURlbHRhTWFwID0ge1xuICAgICAgICAgICAgJ3InOiAxLFxuICAgICAgICAgICAgJ2wnOiAtMSxcbiAgICAgICAgICAgICd1JzogLXRoaXMubnVtQ29scyxcbiAgICAgICAgICAgICdkJzogdGhpcy5udW1Db2xzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVEZWx0YU1hcFttb3ZlXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb25zaWRlciBpbnN0ZWFkIGNhY2hpbmcgbW92ZWRJbmQgZm9yIGV2ZXJ5IG1vdmUgKyBlbXB0eVBvcyBjb21ibyBPKG4pXG4gICAgLy8gcmV0dXJucyBpbmRleCBvZiB0aWxlIHRoYXQgd291bGQgYmUgbW92ZWQgYnkgc3BlY2lmaWVkIG1vdmVcbiAgICBnZXRNb3ZlZEluZChtb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtcHR5UG9zIC0gdGhpcy5nZXRNb3ZlRGVsdGEobW92ZSk7XG4gICAgfVxuXG4gICAgYXBwbHlNb3ZlKG1vdmUpIHtcbiAgICAgICAgbGV0IG1vdmVkSW5kID0gdGhpcy5nZXRNb3ZlZEluZChtb3ZlKTtcbiAgICAgICAgbGV0IGVuZEluZCA9IHRoaXMuZW1wdHlQb3M7XG5cbiAgICAgICAgdGhpcy5zd2FwKGVuZEluZCwgbW92ZWRJbmQpO1xuICAgICAgICB0aGlzLmVtcHR5UG9zID0gbW92ZWRJbmQ7XG4gICAgfVxufVxuXG4vLyBHcmlkIG9wdGltaXplZCBmb3Igc3RyYXRlZ2ljIHNvbHZlclxuY2xhc3MgU3RyYXRlZ2ljR3JpZCBleHRlbmRzIEJhc2VHcmlke1xuICAgIGNvbnN0cnVjdG9yKG51bVJvd3MsIG51bUNvbHMsIHRpbGVzLCBlbXB0eVBvcykge1xuICAgICAgICBzdXBlcihudW1Sb3dzLCBudW1Db2xzLCB0aWxlcywgZW1wdHlQb3MpO1xuXG4gICAgICAgIC8vIG1hcHMgZ29hbCBpbmRleCB0byBjdXJyZW50IGluZGV4XG4gICAgICAgIC8vIGV4OiBhcnJbMF0gPSAyIC0+IHRpbGUgd2l0aCBnb2FsIGluZGV4IDAgaXMgbm93IGF0IGluZGV4IDJcbiAgICAgICAgdGhpcy5nb2FscyA9IHRpbGVzLmxlbmd0aCA+IDI1NiA/XG4gICAgICAgICAgICBuZXcgVWludDE2QXJyYXkodGlsZXMubGVuZ3RoKTogbmV3IFVpbnQ4QXJyYXkodGlsZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy50aWxlcy5mb3JFYWNoKChnb2FsLCBpbmQpID0+IHRoaXMuZ29hbHNbZ29hbF0gPSBpbmQpO1xuXG4gICAgICAgIC8vIG1hcmtzIGJvdW5kcyBvZiB1bnNvbHZlZCBncmlkIChzdGFydCBpbmNsdXNpdmUsIGVuZCBleGNsdXNpdmUpXG4gICAgICAgIC8vIE5PVEU6IGJvdW5kcyBkbyBOT1QgYWZmZWN0IGFueSB0aWxlIHBvc2l0aW9ucy9pbmRpY2VzXG4gICAgICAgIC8vIGkuZS4gaW5kaWNlcy9yb3dzL2NvbHMgYXJlIHRoZSBzYW1lIGFzIGlmIG5vIGJvdW5kcyBleGlzdFxuICAgICAgICB0aGlzLnJvd1N0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5yb3dFbmQgPSBudW1Sb3dzO1xuICAgICAgICB0aGlzLmNvbFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5jb2xFbmQgPSBudW1Db2xzO1xuICAgICAgICB0aGlzLmNvbEJvdW5kcyA9IFswLCBudW1Db2xzXTtcbiAgICB9XG5cbiAgICBzd2FwKHBvczEsIHBvczIpIHtcbiAgICAgICAgLy8gZWFjaCBnb2FsIHBvc2l0aW9uIG5vdyBjb3JyZXNwb25kcyB3aXRoIHRoZSBvcHBvc2l0ZSB0aWxlJ3Mgc3dhcHBlZCBwb3NpdGlvblxuICAgICAgICBbdGhpcy5nb2Fsc1t0aGlzLnRpbGVzW3BvczFdXSwgdGhpcy5nb2Fsc1t0aGlzLnRpbGVzW3BvczJdXV0gPVxuICAgICAgICBbcG9zMiwgcG9zMV07XG5cbiAgICAgICAgc3VwZXIuc3dhcChwb3MxLCBwb3MyKTtcbiAgICB9XG59XG5cbi8vIFRPRE86IGNvbnNpZGVyIG1vdmluZyB2YWxpZE1vdmVzIHRvIGZpZWxkIG9mIENsYXNzIGluc3RlYWQgb2YgaW5zdGFuY2Vcbi8vIChpbmRleGVkIHVuZGVyIGdyaWQgZGltZW5zaW9ucylcblxuLy8gVE9ETzogY29uc2lkZXIgaGF2aW5nIGJvdGggdGhpcyBhbmQgZ3JhcGhpY2FsIGdyaWQgZXh0ZW5kIGZyb20gQmFzZUdyaWQgdG8gcmV1c2UgbW92ZSBmdW5jdGlvbnNcbi8vIHByb3M6IGNsZWFuZXIsIGxlc3MgcmVkdW5kYW5jeVxuLy8gY29uczogcGVyZm9ybWFuY2UgaGl0IGFzIGNhbGxlZCBmdW5jdGlvbnMgbm93IGhhdmUgdG8gbW92ZSB1cCBwcm90b3R5cGUgY2hhaW5cbi8vIChub3QgYSBodWdlIHByb2JsZW0gZm9yIHN0cmF0ZWdpYyBzb2x2ZXIsIGJ1dCBJREEqIGV4cGxvcmVzIGEgbG90IG1vcmUgbm9kZXMpXG5cbi8vIEdyaWQgb3B0aW1pemVkIGZvciBBKiBhbmQgSURBKlxuY2xhc3MgR3JpZCB7XG5cbiAgICBjb25zdHJ1Y3RvcihudW1Sb3dzLCBudW1Db2xzLCB0aWxlcywgZW1wdHlQb3MsIGhldXJpc3RpYywgdHJhdmVsZWREaXN0LCBoZXVyaXN0aWNWYWx1ZSA9IG51bGwsIFxuICAgICAgICBsYXN0TW92ZSA9IG51bGwsIGxhc3RHcmlkID0gbnVsbCwgdmFsaWRNb3ZlcyA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gbnVtUm93cztcbiAgICAgICAgdGhpcy5udW1Db2xzID0gbnVtQ29scztcbiAgICAgICAgdGhpcy50aWxlcyA9IHRpbGVzO1xuICAgICAgICB0aGlzLmVtcHR5UG9zID0gZW1wdHlQb3M7XG5cbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBoZXVyaXN0aWM7XG4gICAgICAgIHRoaXMudHJhdmVsZWREaXN0ID0gdHJhdmVsZWREaXN0O1xuICAgICAgICB0aGlzLmhldXJpc3RpY1ZhbHVlID0gaGV1cmlzdGljVmFsdWUgPT09IG51bGwgPyBoZXVyaXN0aWMuY2FsY3VsYXRlKHRoaXMpIDogaGV1cmlzdGljVmFsdWU7XG5cbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IGxhc3RNb3ZlO1xuICAgICAgICB0aGlzLmxhc3RHcmlkID0gbGFzdEdyaWQ7XG5cbiAgICAgICAgLy8gVE9ETzogYXR0YWNoIHRvIGV4dGVybmFsIG9iaiBvciBwYXNzIGJldHdlZW4gZ3JpZHMgdG8gYXZvaWQgcmVjb21wdXRpbmcgZXZlcnkgbmV3IGdyaWRcbiAgICAgICAgLy8gcHJlY29tcHV0aW5nIHZhbHVlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICAgIC8vIElERUE6IGRvIGFsbCBwcmVjb21wdXRpbmcgaW5zaWRlIFB1enpsZSgpIHRvIGJlIHJlZmVyZW5jZWQgYnkgR3JpZFxuICAgICAgICAvLyAocGFzc2luZyBhbG9uZyB0YWtlcyB1cCBtZW1vcnkpXG4gICAgICAgIHRoaXMudmFsaWRNb3ZlcyA9IHZhbGlkTW92ZXMgPT09IG51bGwgPyB0aGlzLl9wcmVjb21wdXRlVmFsaWRNb3ZlcygpIDogdmFsaWRNb3ZlcztcbiAgICB9XG5cbiAgICBnZXRUaWxlQ29sKGluZCkge1xuICAgICAgICByZXR1cm4gaW5kICUgdGhpcy5udW1Db2xzO1xuICAgIH1cblxuICAgIGdldFRpbGVSb3coaW5kKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGluZCAvIHRoaXMubnVtQ29scyk7XG4gICAgfVxuXG4gICAgZ2V0SW5kZXgocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHJvdyAqIHRoaXMubnVtQ29scyArIGNvbDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGNoYW5nZSBpbiBpbmRleCBvZiB0aWxlIHRvIGJlIG1vdmVkIGFmdGVyIG1vdmVcbiAgICBnZXRNb3ZlRGVsdGEobW92ZSkge1xuICAgICAgICBsZXQgbW92ZURlbHRhTWFwID0ge1xuICAgICAgICAgICAgJ3InOiAxLFxuICAgICAgICAgICAgJ2wnOiAtMSxcbiAgICAgICAgICAgICd1JzogLXRoaXMubnVtQ29scyxcbiAgICAgICAgICAgICdkJzogdGhpcy5udW1Db2xzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVEZWx0YU1hcFttb3ZlXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb25zaWRlciBpbnN0ZWFkIGNhY2hpbmcgbW92ZWRJbmQgZm9yIGV2ZXJ5IG1vdmUgKyBlbXB0eVBvcyBjb21ibyBPKG4pXG4gICAgLy8gcmV0dXJucyBpbmRleCBvZiB0aWxlIHRoYXQgd291bGQgYmUgbW92ZWQgYnkgc3BlY2lmaWVkIG1vdmVcbiAgICBnZXRNb3ZlZEluZChtb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtcHR5UG9zIC0gdGhpcy5nZXRNb3ZlRGVsdGEobW92ZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFJldmVyc2VkTW92ZShtb3ZlKSB7XG4gICAgICAgIHJldHVybiBSRVZFUlNFX01PVkVfTUFQW21vdmVdO1xuICAgIH1cblxuICAgIGdldFRpbGVEaXN0KHRpbGUxLCB0aWxlMikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5nZXRUaWxlUm93KHRpbGUxKSAtIHRoaXMuZ2V0VGlsZVJvdyh0aWxlMikpICtcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZ2V0VGlsZUNvbCh0aWxlMSkgLSB0aGlzLmdldFRpbGVDb2wodGlsZTIpKTtcbiAgICB9XG5cbiAgICByZWNvbnN0cnVjdFBhdGgoKSB7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGxldCBjdXJyID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGN1cnIubGFzdE1vdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChjdXJyLmxhc3RNb3ZlKTtcbiAgICAgICAgICAgIGN1cnIgPSBjdXJyLmxhc3RHcmlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgZGVlcCBjb3B5IG9mIGdyaWQgaWdub3JpbmcgbGFzdEdyaWQgKG51bGwpXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR3JpZCh0aGlzLm51bVJvd3MsIHRoaXMubnVtQ29scywgdGhpcy50aWxlcy5zbGljZSgpLCB0aGlzLmVtcHR5UG9zLCB0aGlzLmhldXJpc3RpYyxcbiAgICAgICAgICAgIHRoaXMudHJhdmVsZWREaXN0LCB0aGlzLmhldXJpc3RpY1ZhbHVlLCB0aGlzLmxhc3RNb3ZlLCBudWxsLCB0aGlzLnZhbGlkTW92ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgY29weSBvZiBjdXJyZW50IGdyaWQgd2l0aCBzcGVjaWZpZWQgZGlyZWN0aW9uYWwgbW92ZSBhcHBsaWVkIHRvIHRpbGUgbW92aW5nIGludG8gZW1wdHkgcG9zaXRpb25cbiAgICAgKiBhbHNvIHVwZGF0ZXMgYWxsIGFmZmVjdGVkIEdyaWQgZmllbGRzIGluIG5ldyBHcmlkIChlbXB0eVBvcywgaGV1cmlzdGljL3RyYXZlbCBkaXN0YW5jZSwgZXRjLilcbiAgICAgKiBAcGFyYW0gbW92ZSBkaXJlY3Rpb24gdG8gbW92ZSB0aWxlIGludG8gZW1wdHkgc3BhY2VcbiAgICAgKiBAcmV0dXJuIHJldHVybnMgY29weSBvZiBjdXJyZW50IGdyaWQgd2l0aCBzcGVjaWZpZWQgbW92ZSBhcHBsaWVkIHRvIHRpbGUgaW50byBlbXB0eSBwb3NpdGlvblxuICAgICAqL1xuICAgIGNsb25lQW5kQXBwbHlNb3ZlKG1vdmUpIHtcbiAgICAgICAgbGV0IG5ld0dyaWQgPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgbmV3R3JpZC5sYXN0R3JpZCA9IHRoaXM7XG4gICAgICAgIG5ld0dyaWQubGFzdE1vdmUgPSBtb3ZlO1xuXG4gICAgICAgIHJldHVybiBHcmlkLl9hcHBseU1vdmVIZWxwZXIobW92ZSwgbmV3R3JpZCk7XG4gICAgfVxuXG4gICAgLy8gQXBwbGllcyBtb3ZlIHRvIGdyaWQgTk9UIGNsb25lIG9uIGdyaWRcbiAgICAvLyBSZXR1cm5zIG1vdmVSZWNvcmQgb2JqZWN0IHN0b3Jpbmcgb2xkIGhldXJpc3RpY1ZhbHVlIGFuZCBlbXB0eVBvcyAoZm9yIHVzZSBpbiByZXZlcnNlTW92ZSgpKVxuICAgIC8vICh1c2VmdWwgZm9yIElEQSogYXMgbWVtb3J5IGFsbG9jYXRpb24gY2FuIGJlIGF2b2lkZWQpXG4gICAgLy8gTk9URTogc2VwYXJhdGUgZnVuY3Rpb24gaW5zdGVhZCBvZiBjb25zb2xpZGF0aW9uIHdpdGggXCJjbG9uZVwiIHBhcmFtIGZvciBzbGlnaHRseSBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAvLyBOT1RFOiBkb2VzIE5PVCB1cGRhdGUgbGFzdE1vdmUgb3IgbGFzdEdyaWRcbiAgICBhcHBseU1vdmUobW92ZSkge1xuICAgICAgICBsZXQgb2xkSGV1cmlzdGljVmFsdWUgPSB0aGlzLmhldXJpc3RpY1ZhbHVlO1xuICAgICAgICBsZXQgb2xkRW1wdHlQb3MgPSB0aGlzLmVtcHR5UG9zO1xuXG4gICAgICAgIEdyaWQuX2FwcGx5TW92ZUhlbHBlcihtb3ZlLCB0aGlzKTtcblxuICAgICAgICAvLyBUT0RPOyBjb25zaWRlciBjaGFuZ2luZyB0byB0eXBlZEFycmF5IGZvciBzbGlnaHRseSBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgICAgcmV0dXJuIHtoZXVyaXN0aWNWYWx1ZTogb2xkSGV1cmlzdGljVmFsdWUsIGVtcHR5UG9zOiBvbGRFbXB0eVBvc307XG4gICAgfVxuXG4gICAgcmV2ZXJzZU1vdmUobW92ZVJlY29yZCkge1xuICAgICAgICB0aGlzLnRyYXZlbGVkRGlzdC0tO1xuXG4gICAgICAgIHRoaXMuaGV1cmlzdGljVmFsdWUgPSBtb3ZlUmVjb3JkLmhldXJpc3RpY1ZhbHVlO1xuXG4gICAgICAgIHRoaXMuc3dhcCh0aGlzLmVtcHR5UG9zLCBtb3ZlUmVjb3JkLmVtcHR5UG9zKTtcbiAgICAgICAgdGhpcy5lbXB0eVBvcyA9IG1vdmVSZWNvcmQuZW1wdHlQb3M7XG4gICAgfVxuXG4gICAgLy8gYXBwbGllcyBtb3ZlIHRvIHNwZWNpZmllZCBncmlkIFdJVEhPVVQgdXBkYXRpbmcgbGFzdE1vdmUgb3IgbGFzdEdyaWRcbiAgICBzdGF0aWMgX2FwcGx5TW92ZUhlbHBlcihtb3ZlLCBncmlkKSB7XG4gICAgICAgIGxldCBtb3ZlZEluZCA9IGdyaWQuZ2V0TW92ZWRJbmQobW92ZSk7XG4gICAgICAgIGxldCBlbmRJbmQgPSBncmlkLmVtcHR5UG9zO1xuXG4gICAgICAgIGdyaWQuc3dhcChlbmRJbmQsIG1vdmVkSW5kKTtcbiAgICAgICAgZ3JpZC5lbXB0eVBvcyA9IG1vdmVkSW5kO1xuXG4gICAgICAgIGdyaWQudHJhdmVsZWREaXN0Kys7XG5cbiAgICAgICAgZ3JpZC5oZXVyaXN0aWNWYWx1ZSA9IGdyaWQuaGV1cmlzdGljLnVwZGF0ZShncmlkLCBtb3ZlZEluZCwgZW5kSW5kLCBtb3ZlKTtcbiAgICAgICAgcmV0dXJuIGdyaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV0FSTklORzogRG9lcyBOT1QgdXBkYXRlIGhldXJpc3RpY1ZhbHVlLCBsYXN0TW92ZSwgZW1wdHlQb3MsIG9yIGxhc3RHcmlkXG4gICAgICogc3dhcHMgMiBwb3NpdGlvbnMgaW4gZ3JpZC5cbiAgICAgKi9cbiAgICBzd2FwKHBvczEsIHBvczIpIHtcbiAgICAgICAgW3RoaXMudGlsZXNbcG9zMV0sIHRoaXMudGlsZXNbcG9zMl1dID0gW3RoaXMudGlsZXNbcG9zMl0sIHRoaXMudGlsZXNbcG9zMV1dO1xuICAgIH1cblxuICAgIC8vIHByZWNvbXB1dGVzIHZhbGlkIG1vdmVzIGZvciBlYWNoIHBvc3NpYmxlIGVtcHR5UG9zIHRvIGdpdmUgc2xpZ2h0IHBlcmZvcm1hbmNlIGJlbmVmaXRcbiAgICBfcHJlY29tcHV0ZVZhbGlkTW92ZXMoKSB7XG4gICAgICAgIGxldCBtb3ZlcztcbiAgICAgICAgbGV0IHZhbGlkTW92ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZW1wdHlQb3MgPSAwOyBlbXB0eVBvcyA8IHRoaXMudGlsZXMubGVuZ3RoOyBlbXB0eVBvcysrKSB7XG4gICAgICAgICAgICBtb3ZlcyA9IFtdO1xuXG4gICAgICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRUaWxlUm93KGVtcHR5UG9zKTtcbiAgICAgICAgICAgIGxldCBjb2wgPSB0aGlzLmdldFRpbGVDb2woZW1wdHlQb3MpO1xuXG4gICAgICAgICAgICBpZiAocm93IDwgdGhpcy5udW1Sb3dzIC0gMSkge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2goJ3UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgbW92ZXMucHVzaCgnZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbCA8IHRoaXMubnVtQ29scyAtIDEpIHtcbiAgICAgICAgICAgICAgICBtb3Zlcy5wdXNoKCdsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sID4gMCkge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2goJ3InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsaWRNb3Zlc1tlbXB0eVBvc10gPSBtb3ZlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRNb3ZlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGFycmF5IG9mIHZhbGlkIG1vdmVzLCB3aGVyZSAnbCcgPSBsZWZ0LCAncicgPSByaWdodCwgJ2QnID0gZG93biwgYW5kICd1JyA9IHVwLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2YgdmFsaWQgbW92ZXMsIHdoZXJlIG1vdmVzIGFyZSBkZWZpbmVkIGJ5IHRpbGVzIG1vdmluZyBpbnRvIHRoZSBlbXB0eSBzcGFjZSBpbiB0aGUgZ3JpZFxuICAgICAqL1xuICAgIGdldFZhbGlkTW92ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkTW92ZXNbdGhpcy5lbXB0eVBvc107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGdyaWQgaXMgc29sdmVkIGFzc3VtaW5nIGdvYWwgaXMgWzAsIDEsIC4uLiB0aWxlcy5sZW5ndGggLSAxXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHB1enpsZSBpcyBzb2x2ZWRcbiAgICAgKi9cbiAgICBpc1NvbHZlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGV1cmlzdGljLmlzU29sdmVkKHRoaXMuaGV1cmlzdGljVmFsdWUpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBhY2NvdW50cyBmb3IgaWYgY2FuJ3QgZGV0ZXJtaW5lIGlmIHB1enpsZSBzb2x2ZWQgdXNpbmcgaGV1cmlzdGljIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVzLmV2ZXJ5KChnb2FsSW5kLCBpbmQpID0+IGdvYWxJbmQgPT09IGluZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0TGluZWFyQ29uZmxpY3RIZXVyaXN0aWMoKSB7XG4gICAgY29uc3QgdGVzdENhc2VzID0gW1xuICAgICAgICBbWzAsMiwxLDcsNCw1LDYsMyw4XSwgMF0sXG4gICAgICAgIFtbMCwyLDEsNSw0LDMsNiw3LDhdLCAwXSxcbiAgICAgICAgW1s0LDMsNiw4LDAsNyw1LDIsMV0sIDRdLFxuICAgICAgICBbWzIsNywwLDUsNCwzLDgsMSw2XSwgMl1dO1xuXG4gICAgY29uc3QgYW5zID0gWzgsIDEyLCAyMiwgMjRdO1xuXG4gICAgZm9yIChsZXQgW2luZCwgdGVzdENhc2VdIG9mIHRlc3RDYXNlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgbGV0IHRlc3RHcmlkID0gbmV3IEdyaWQoMywgMywgLi4udGVzdENhc2UsIG5ldyBMaW5lYXJDb25mbGljdEhldXJpc3RpYygzLCAzKSwgMCk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRlc3RHcmlkLmhldXJpc3RpY1ZhbHVlID09PSBhbnNbaW5kXSwgXG4gICAgICAgICAgICBgaW5jb3JyZWN0IGFuc3dlcjogYW5zd2VyID0gJHt0ZXN0R3JpZC5oZXVyaXN0aWNWYWx1ZX0sIGNvcnJlY3QgYW5zd2VyID0gJHthbnNbaW5kXX1gKTtcbiAgICB9XG59XG5cbi8vIFRPRE86IHJlbW92ZSBhZnRlciBkb25lIHRlc3Rpbmdcbi8vIHRlc3RMaW5lYXJDb25mbGljdEhldXJpc3RpYygpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFB1enpsZTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/sliding-puzzle-algorithms.js\n");

/***/ })

/******/ });
//# sourceMappingURL=puzzle-solver.worker.js.map