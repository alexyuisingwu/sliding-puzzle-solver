/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/script.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/avl/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/avl/src/index.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AVLTree; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/avl/src/utils.js\");\n\n\n\n// function createNode (parent, left, right, height, key, data) {\n//   return { parent, left, right, balanceFactor: height, key, data };\n// }\n\n/**\n * @typedef {{\n *   parent:        ?Node,\n *   left:          ?Node,\n *   right:         ?Node,\n *   balanceFactor: number,\n *   key:           Key,\n *   data:          Value\n * }} Node\n */\n\n/**\n * @typedef {*} Key\n */\n\n/**\n * @typedef {*} Value\n */\n\n/**\n * Default comparison function\n * @param {Key} a\n * @param {Key} b\n * @returns {number}\n */\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n\n/**\n * Single left rotation\n * @param  {Node} node\n * @return {Node}\n */\nfunction rotateLeft (node) {\n  var rightNode = node.right;\n  node.right    = rightNode.left;\n\n  if (rightNode.left) rightNode.left.parent = node;\n\n  rightNode.parent = node.parent;\n  if (rightNode.parent) {\n    if (rightNode.parent.left === node) {\n      rightNode.parent.left = rightNode;\n    } else {\n      rightNode.parent.right = rightNode;\n    }\n  }\n\n  node.parent    = rightNode;\n  rightNode.left = node;\n\n  node.balanceFactor += 1;\n  if (rightNode.balanceFactor < 0) {\n    node.balanceFactor -= rightNode.balanceFactor;\n  }\n\n  rightNode.balanceFactor += 1;\n  if (node.balanceFactor > 0) {\n    rightNode.balanceFactor += node.balanceFactor;\n  }\n  return rightNode;\n}\n\n\nfunction rotateRight (node) {\n  var leftNode = node.left;\n  node.left = leftNode.right;\n  if (node.left) node.left.parent = node;\n\n  leftNode.parent = node.parent;\n  if (leftNode.parent) {\n    if (leftNode.parent.left === node) {\n      leftNode.parent.left = leftNode;\n    } else {\n      leftNode.parent.right = leftNode;\n    }\n  }\n\n  node.parent    = leftNode;\n  leftNode.right = node;\n\n  node.balanceFactor -= 1;\n  if (leftNode.balanceFactor > 0) {\n    node.balanceFactor -= leftNode.balanceFactor;\n  }\n\n  leftNode.balanceFactor -= 1;\n  if (node.balanceFactor < 0) {\n    leftNode.balanceFactor += node.balanceFactor;\n  }\n\n  return leftNode;\n}\n\n\n// function leftBalance (node) {\n//   if (node.left.balanceFactor === -1) rotateLeft(node.left);\n//   return rotateRight(node);\n// }\n\n\n// function rightBalance (node) {\n//   if (node.right.balanceFactor === 1) rotateRight(node.right);\n//   return rotateLeft(node);\n// }\n\n\nclass AVLTree {\n  /**\n   * Callback for comparator\n   * @callback comparatorCallback\n   * @param {Key} a\n   * @param {Key} b\n   * @returns {number}\n   */\n\n  /**\n   * @class AVLTree\n   * @constructor\n   * @param  {comparatorCallback} [comparator]\n   * @param  {boolean}            [noDuplicates=false] Disallow duplicates\n   */\n  constructor (comparator, noDuplicates = false) {\n    this._comparator = comparator || DEFAULT_COMPARE;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  }\n\n\n  /**\n   * Clear the tree\n   * @return {AVLTree}\n   */\n  destroy() {\n    return this.clear();\n  }\n\n\n  /**\n   * Clear the tree\n   * @return {AVLTree}\n   */\n  clear() {\n    this._root = null;\n    this._size = 0;\n    return this;\n  }\n\n  /**\n   * Number of nodes\n   * @return {number}\n   */\n  get size () {\n    return this._size;\n  }\n\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param  {Key} key\n   * @return {boolean} true/false\n   */\n  contains (key) {\n    if (this._root)  {\n      var node       = this._root;\n      var comparator = this._comparator;\n      while (node)  {\n        var cmp = comparator(key, node.key);\n        if      (cmp === 0) return true;\n        else if (cmp < 0)   node = node.left;\n        else                node = node.right;\n      }\n    }\n    return false;\n  }\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor.left) successor = successor.left;\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  }\n\n\n  /**\n   * Predecessor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor.right) predecessor = predecessor.right;\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  }\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * Callback for forEach\n   * @callback forEachCallback\n   * @param {Node} node\n   * @param {number} index\n   */\n\n  /**\n   * @param  {forEachCallback} callback\n   * @return {AVLTree}\n   */\n  forEach(callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range(low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._comparator;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Returns node with the minimum key\n   * @return {?Node}\n   */\n  minNode () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.left) node = node.left;\n    return node;\n  }\n\n\n  /**\n   * Returns node with the max key\n   * @return {?Node}\n   */\n  maxNode () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.right) node = node.right;\n    return node;\n  }\n\n\n  /**\n   * Min key\n   * @return {?Key}\n   */\n  min () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.left) node = node.left;\n    return node.key;\n  }\n\n\n  /**\n   * Max key\n   * @return {?Key}\n   */\n  max () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.right) node = node.right;\n    return node.key;\n  }\n\n\n  /**\n   * @return {boolean} true/false\n   */\n  isEmpty() {\n    return !this._root;\n  }\n\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) node = node.left;\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  }\n\n\n  /**\n   * Find node by key\n   * @param  {Key} key\n   * @return {?Node}\n   */\n  find (key) {\n    var root = this._root;\n    // if (root === null)    return null;\n    // if (key === root.key) return root;\n\n    var subtree = root, cmp;\n    var compare = this._comparator;\n    while (subtree) {\n      cmp = compare(key, subtree.key);\n      if      (cmp === 0) return subtree;\n      else if (cmp < 0)   subtree = subtree.left;\n      else                subtree = subtree.right;\n    }\n\n    return null;\n  }\n\n\n  /**\n   * Insert a node into the tree\n   * @param  {Key} key\n   * @param  {Value} [data]\n   * @return {?Node}\n   */\n  insert (key, data) {\n    if (!this._root) {\n      this._root = {\n        parent: null, left: null, right: null, balanceFactor: 0,\n        key, data\n      };\n      this._size++;\n      return this._root;\n    }\n\n    var compare = this._comparator;\n    var node    = this._root;\n    var parent  = null;\n    var cmp     = 0;\n\n    if (this._noDuplicates) {\n      while (node) {\n        cmp = compare(key, node.key);\n        parent = node;\n        if      (cmp === 0) return null;\n        else if (cmp < 0)   node = node.left;\n        else                node = node.right;\n      }\n    } else {\n      while (node) {\n        cmp = compare(key, node.key);\n        parent = node;\n        if      (cmp <= 0)  node = node.left; //return null;\n        else                node = node.right;\n      }\n    }\n\n    var newNode = {\n      left: null,\n      right: null,\n      balanceFactor: 0,\n      parent, key, data\n    };\n    var newRoot;\n    if (cmp <= 0) parent.left  = newNode;\n    else         parent.right = newNode;\n\n    while (parent) {\n      cmp = compare(parent.key, key);\n      if (cmp < 0) parent.balanceFactor -= 1;\n      else         parent.balanceFactor += 1;\n\n      if        (parent.balanceFactor === 0) break;\n      else if   (parent.balanceFactor < -1) {\n        // inlined\n        //var newRoot = rightBalance(parent);\n        if (parent.right.balanceFactor === 1) rotateRight(parent.right);\n        newRoot = rotateLeft(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        break;\n      } else if (parent.balanceFactor > 1) {\n        // inlined\n        // var newRoot = leftBalance(parent);\n        if (parent.left.balanceFactor === -1) rotateLeft(parent.left);\n        newRoot = rotateRight(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        break;\n      }\n      parent = parent.parent;\n    }\n\n    this._size++;\n    return newNode;\n  }\n\n\n  /**\n   * Removes the node from the tree. If not found, returns null.\n   * @param  {Key} key\n   * @return {?Node}\n   */\n  remove (key) {\n    if (!this._root) return null;\n\n    var node = this._root;\n    var compare = this._comparator;\n    var cmp = 0;\n\n    while (node) {\n      cmp = compare(key, node.key);\n      if      (cmp === 0) break;\n      else if (cmp < 0)   node = node.left;\n      else                node = node.right;\n    }\n    if (!node) return null;\n\n    var returnValue = node.key;\n    var max, min;\n\n    if (node.left) {\n      max = node.left;\n\n      while (max.left || max.right) {\n        while (max.right) max = max.right;\n\n        node.key = max.key;\n        node.data = max.data;\n        if (max.left) {\n          node = max;\n          max = max.left;\n        }\n      }\n\n      node.key  = max.key;\n      node.data = max.data;\n      node = max;\n    }\n\n    if (node.right) {\n      min = node.right;\n\n      while (min.left || min.right) {\n        while (min.left) min = min.left;\n\n        node.key  = min.key;\n        node.data = min.data;\n        if (min.right) {\n          node = min;\n          min = min.right;\n        }\n      }\n\n      node.key  = min.key;\n      node.data = min.data;\n      node = min;\n    }\n\n    var parent = node.parent;\n    var pp     = node;\n    var newRoot;\n\n    while (parent) {\n      if (parent.left === pp) parent.balanceFactor -= 1;\n      else                    parent.balanceFactor += 1;\n\n      if        (parent.balanceFactor < -1) {\n        // inlined\n        //var newRoot = rightBalance(parent);\n        if (parent.right.balanceFactor === 1) rotateRight(parent.right);\n        newRoot = rotateLeft(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        parent = newRoot;\n      } else if (parent.balanceFactor > 1) {\n        // inlined\n        // var newRoot = leftBalance(parent);\n        if (parent.left.balanceFactor === -1) rotateLeft(parent.left);\n        newRoot = rotateRight(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        parent = newRoot;\n      }\n\n      if (parent.balanceFactor === -1 || parent.balanceFactor === 1) break;\n\n      pp     = parent;\n      parent = parent.parent;\n    }\n\n    if (node.parent) {\n      if (node.parent.left === node) node.parent.left  = null;\n      else                           node.parent.right = null;\n    }\n\n    if (node === this._root) this._root = null;\n\n    this._size--;\n    return returnValue;\n  }\n\n\n  /**\n   * Bulk-load items\n   * @param  {Array<Key>}  keys\n   * @param  {Array<Value>}  [values]\n   * @return {AVLTree}\n   */\n  load(keys = [], values = [], presort) {\n    if (this._size !== 0) throw new Error('bulk-load: tree is not empty');\n    const size = keys.length;\n    if (presort) Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"sort\"])(keys, values, 0, size - 1, this._comparator);\n    this._root = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"loadRecursive\"])(null, keys, values, 0, size);\n    Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"markBalance\"])(this._root);\n    this._size = size;\n    return this;\n  }\n\n\n  /**\n   * Returns true if the tree is balanced\n   * @return {boolean}\n   */\n  isBalanced() {\n    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isBalanced\"])(this._root);\n  }\n\n\n  /**\n   * String representation of the tree - primitive horizontal print-out\n   * @param  {Function(Node):string} [printNode]\n   * @return {string}\n   */\n  toString (printNode) {\n    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"print\"])(this._root, printNode);\n  }\n}\n\nAVLTree.default = AVLTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXZsL3NyYy9pbmRleC5qcz8wMTNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUE4RTs7O0FBRzlFO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLEVBQUU7QUFDZjs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLElBQUk7QUFDZixhQUFhO0FBQ2I7QUFDQSxpQ0FBaUMsbUNBQW1DOzs7QUFHcEU7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsSUFBSTtBQUNqQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakMsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixjQUFjLElBQUk7QUFDbEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsR0FBRztBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLGFBQWE7QUFDM0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFJO0FBQ3JCLGlCQUFpQiw0REFBYTtBQUM5QixJQUFJLDBEQUFXO0FBQ2Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXLHlEQUFVO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXLG9EQUFLO0FBQ2hCO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXZsL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByaW50LCBpc0JhbGFuY2VkLCBsb2FkUmVjdXJzaXZlLCBtYXJrQmFsYW5jZSwgc29ydCB9IGZyb20gJy4vdXRpbHMnO1xuXG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZU5vZGUgKHBhcmVudCwgbGVmdCwgcmlnaHQsIGhlaWdodCwga2V5LCBkYXRhKSB7XG4vLyAgIHJldHVybiB7IHBhcmVudCwgbGVmdCwgcmlnaHQsIGJhbGFuY2VGYWN0b3I6IGhlaWdodCwga2V5LCBkYXRhIH07XG4vLyB9XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgcGFyZW50OiAgICAgICAgP05vZGUsXG4gKiAgIGxlZnQ6ICAgICAgICAgID9Ob2RlLFxuICogICByaWdodDogICAgICAgICA/Tm9kZSxcbiAqICAgYmFsYW5jZUZhY3RvcjogbnVtYmVyLFxuICogICBrZXk6ICAgICAgICAgICBLZXksXG4gKiAgIGRhdGE6ICAgICAgICAgIFZhbHVlXG4gKiB9fSBOb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Kn0gS2V5XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Kn0gVmFsdWVcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvblxuICogQHBhcmFtIHtLZXl9IGFcbiAqIEBwYXJhbSB7S2V5fSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBERUZBVUxUX0NPTVBBUkUgKGEsIGIpIHsgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwOyB9XG5cblxuLyoqXG4gKiBTaW5nbGUgbGVmdCByb3RhdGlvblxuICogQHBhcmFtICB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZnVuY3Rpb24gcm90YXRlTGVmdCAobm9kZSkge1xuICB2YXIgcmlnaHROb2RlID0gbm9kZS5yaWdodDtcbiAgbm9kZS5yaWdodCAgICA9IHJpZ2h0Tm9kZS5sZWZ0O1xuXG4gIGlmIChyaWdodE5vZGUubGVmdCkgcmlnaHROb2RlLmxlZnQucGFyZW50ID0gbm9kZTtcblxuICByaWdodE5vZGUucGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gIGlmIChyaWdodE5vZGUucGFyZW50KSB7XG4gICAgaWYgKHJpZ2h0Tm9kZS5wYXJlbnQubGVmdCA9PT0gbm9kZSkge1xuICAgICAgcmlnaHROb2RlLnBhcmVudC5sZWZ0ID0gcmlnaHROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodE5vZGUucGFyZW50LnJpZ2h0ID0gcmlnaHROb2RlO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUucGFyZW50ICAgID0gcmlnaHROb2RlO1xuICByaWdodE5vZGUubGVmdCA9IG5vZGU7XG5cbiAgbm9kZS5iYWxhbmNlRmFjdG9yICs9IDE7XG4gIGlmIChyaWdodE5vZGUuYmFsYW5jZUZhY3RvciA8IDApIHtcbiAgICBub2RlLmJhbGFuY2VGYWN0b3IgLT0gcmlnaHROb2RlLmJhbGFuY2VGYWN0b3I7XG4gIH1cblxuICByaWdodE5vZGUuYmFsYW5jZUZhY3RvciArPSAxO1xuICBpZiAobm9kZS5iYWxhbmNlRmFjdG9yID4gMCkge1xuICAgIHJpZ2h0Tm9kZS5iYWxhbmNlRmFjdG9yICs9IG5vZGUuYmFsYW5jZUZhY3RvcjtcbiAgfVxuICByZXR1cm4gcmlnaHROb2RlO1xufVxuXG5cbmZ1bmN0aW9uIHJvdGF0ZVJpZ2h0IChub2RlKSB7XG4gIHZhciBsZWZ0Tm9kZSA9IG5vZGUubGVmdDtcbiAgbm9kZS5sZWZ0ID0gbGVmdE5vZGUucmlnaHQ7XG4gIGlmIChub2RlLmxlZnQpIG5vZGUubGVmdC5wYXJlbnQgPSBub2RlO1xuXG4gIGxlZnROb2RlLnBhcmVudCA9IG5vZGUucGFyZW50O1xuICBpZiAobGVmdE5vZGUucGFyZW50KSB7XG4gICAgaWYgKGxlZnROb2RlLnBhcmVudC5sZWZ0ID09PSBub2RlKSB7XG4gICAgICBsZWZ0Tm9kZS5wYXJlbnQubGVmdCA9IGxlZnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0Tm9kZS5wYXJlbnQucmlnaHQgPSBsZWZ0Tm9kZTtcbiAgICB9XG4gIH1cblxuICBub2RlLnBhcmVudCAgICA9IGxlZnROb2RlO1xuICBsZWZ0Tm9kZS5yaWdodCA9IG5vZGU7XG5cbiAgbm9kZS5iYWxhbmNlRmFjdG9yIC09IDE7XG4gIGlmIChsZWZ0Tm9kZS5iYWxhbmNlRmFjdG9yID4gMCkge1xuICAgIG5vZGUuYmFsYW5jZUZhY3RvciAtPSBsZWZ0Tm9kZS5iYWxhbmNlRmFjdG9yO1xuICB9XG5cbiAgbGVmdE5vZGUuYmFsYW5jZUZhY3RvciAtPSAxO1xuICBpZiAobm9kZS5iYWxhbmNlRmFjdG9yIDwgMCkge1xuICAgIGxlZnROb2RlLmJhbGFuY2VGYWN0b3IgKz0gbm9kZS5iYWxhbmNlRmFjdG9yO1xuICB9XG5cbiAgcmV0dXJuIGxlZnROb2RlO1xufVxuXG5cbi8vIGZ1bmN0aW9uIGxlZnRCYWxhbmNlIChub2RlKSB7XG4vLyAgIGlmIChub2RlLmxlZnQuYmFsYW5jZUZhY3RvciA9PT0gLTEpIHJvdGF0ZUxlZnQobm9kZS5sZWZ0KTtcbi8vICAgcmV0dXJuIHJvdGF0ZVJpZ2h0KG5vZGUpO1xuLy8gfVxuXG5cbi8vIGZ1bmN0aW9uIHJpZ2h0QmFsYW5jZSAobm9kZSkge1xuLy8gICBpZiAobm9kZS5yaWdodC5iYWxhbmNlRmFjdG9yID09PSAxKSByb3RhdGVSaWdodChub2RlLnJpZ2h0KTtcbi8vICAgcmV0dXJuIHJvdGF0ZUxlZnQobm9kZSk7XG4vLyB9XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQVZMVHJlZSB7XG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgY29tcGFyYXRvclxuICAgKiBAY2FsbGJhY2sgY29tcGFyYXRvckNhbGxiYWNrXG4gICAqIEBwYXJhbSB7S2V5fSBhXG4gICAqIEBwYXJhbSB7S2V5fSBiXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgQVZMVHJlZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7Y29tcGFyYXRvckNhbGxiYWNrfSBbY29tcGFyYXRvcl1cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICBbbm9EdXBsaWNhdGVzPWZhbHNlXSBEaXNhbGxvdyBkdXBsaWNhdGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29tcGFyYXRvciwgbm9EdXBsaWNhdGVzID0gZmFsc2UpIHtcbiAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvciB8fCBERUZBVUxUX0NPTVBBUkU7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5fbm9EdXBsaWNhdGVzID0gISFub0R1cGxpY2F0ZXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgdHJlZVxuICAgKiBAcmV0dXJuIHtBVkxUcmVlfVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGVhcigpO1xuICB9XG5cblxuICAvKipcbiAgICogQ2xlYXIgdGhlIHRyZWVcbiAgICogQHJldHVybiB7QVZMVHJlZX1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBub2Rlc1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB0cmVlIGNvbnRhaW5zIGEgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXlcbiAgICogQHBhcmFtICB7S2V5fSBrZXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZS9mYWxzZVxuICAgKi9cbiAgY29udGFpbnMgKGtleSkge1xuICAgIGlmICh0aGlzLl9yb290KSAge1xuICAgICAgdmFyIG5vZGUgICAgICAgPSB0aGlzLl9yb290O1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgICAgd2hpbGUgKG5vZGUpICB7XG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGtleSwgbm9kZS5rZXkpO1xuICAgICAgICBpZiAgICAgIChjbXAgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuXG4gIC8qKlxuICAgKiBTdWNjZXNzb3Igbm9kZVxuICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgbmV4dCAobm9kZSkge1xuICAgIHZhciBzdWNjZXNzb3IgPSBub2RlO1xuICAgIGlmIChzdWNjZXNzb3IpIHtcbiAgICAgIGlmIChzdWNjZXNzb3IucmlnaHQpIHtcbiAgICAgICAgc3VjY2Vzc29yID0gc3VjY2Vzc29yLnJpZ2h0O1xuICAgICAgICB3aGlsZSAoc3VjY2Vzc29yLmxlZnQpIHN1Y2Nlc3NvciA9IHN1Y2Nlc3Nvci5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VjY2Vzc29yID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChzdWNjZXNzb3IgJiYgc3VjY2Vzc29yLnJpZ2h0ID09PSBub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IHN1Y2Nlc3Nvcjsgc3VjY2Vzc29yID0gc3VjY2Vzc29yLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VjY2Vzc29yO1xuICB9XG5cblxuICAvKipcbiAgICogUHJlZGVjZXNzb3Igbm9kZVxuICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgcHJldiAobm9kZSkge1xuICAgIHZhciBwcmVkZWNlc3NvciA9IG5vZGU7XG4gICAgaWYgKHByZWRlY2Vzc29yKSB7XG4gICAgICBpZiAocHJlZGVjZXNzb3IubGVmdCkge1xuICAgICAgICBwcmVkZWNlc3NvciA9IHByZWRlY2Vzc29yLmxlZnQ7XG4gICAgICAgIHdoaWxlIChwcmVkZWNlc3Nvci5yaWdodCkgcHJlZGVjZXNzb3IgPSBwcmVkZWNlc3Nvci5yaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWRlY2Vzc29yID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwcmVkZWNlc3NvciAmJiBwcmVkZWNlc3Nvci5sZWZ0ID09PSBub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IHByZWRlY2Vzc29yO1xuICAgICAgICAgIHByZWRlY2Vzc29yID0gcHJlZGVjZXNzb3IucGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmVkZWNlc3NvcjtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cblxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgZm9yRWFjaFxuICAgKiBAY2FsbGJhY2sgZm9yRWFjaENhbGxiYWNrXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge2ZvckVhY2hDYWxsYmFja30gY2FsbGJhY2tcbiAgICogQHJldHVybiB7QVZMVHJlZX1cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHMgPSBbXSwgZG9uZSA9IGZhbHNlLCBpID0gMDtcblxuICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgLy8gUmVhY2ggdGhlIGxlZnQgbW9zdCBOb2RlIG9mIHRoZSBjdXJyZW50IE5vZGVcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIC8vIFBsYWNlIHBvaW50ZXIgdG8gYSB0cmVlIG5vZGUgb24gdGhlIHN0YWNrXG4gICAgICAgIC8vIGJlZm9yZSB0cmF2ZXJzaW5nIHRoZSBub2RlJ3MgbGVmdCBzdWJ0cmVlXG4gICAgICAgIHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJhY2tUcmFjayBmcm9tIHRoZSBlbXB0eSBzdWJ0cmVlIGFuZCB2aXNpdCB0aGUgTm9kZVxuICAgICAgICAvLyBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjazsgaG93ZXZlciwgaWYgdGhlIHN0YWNrIGlzXG4gICAgICAgIC8vIGVtcHR5IHlvdSBhcmUgZG9uZVxuICAgICAgICBpZiAocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IHMucG9wKCk7XG4gICAgICAgICAgY2FsbGJhY2soY3VycmVudCwgaSsrKTtcblxuICAgICAgICAgIC8vIFdlIGhhdmUgdmlzaXRlZCB0aGUgbm9kZSBhbmQgaXRzIGxlZnRcbiAgICAgICAgICAvLyBzdWJ0cmVlLiBOb3csIGl0J3MgcmlnaHQgc3VidHJlZSdzIHR1cm5cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfSBlbHNlIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdhbGsga2V5IHJhbmdlIGZyb20gYGxvd2AgdG8gYGhpZ2hgLiBTdG9wcyBpZiBgZm5gIHJldHVybnMgYSB2YWx1ZS5cbiAgICogQHBhcmFtICB7S2V5fSAgICAgIGxvd1xuICAgKiBAcGFyYW0gIHtLZXl9ICAgICAgaGlnaFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtICB7Kj99ICAgICAgIGN0eFxuICAgKiBAcmV0dXJuIHtTcGxheVRyZWV9XG4gICAqL1xuICByYW5nZShsb3csIGhpZ2gsIGZuLCBjdHgpIHtcbiAgICBjb25zdCBRID0gW107XG4gICAgY29uc3QgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgbGV0IG5vZGUgPSB0aGlzLl9yb290LCBjbXA7XG5cbiAgICB3aGlsZSAoUS5sZW5ndGggIT09IDAgfHwgbm9kZSkge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgUS5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IFEucG9wKCk7XG4gICAgICAgIGNtcCA9IGNvbXBhcmUobm9kZS5rZXksIGhpZ2gpO1xuICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmUobm9kZS5rZXksIGxvdykgPj0gMCkge1xuICAgICAgICAgIGlmIChmbi5jYWxsKGN0eCwgbm9kZSkpIHJldHVybiB0aGlzOyAvLyBzdG9wIGlmIHNtdGggaXMgcmV0dXJuZWRcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBrZXlzIGluIG9yZGVyXG4gICAqIEByZXR1cm4ge0FycmF5PEtleT59XG4gICAqL1xuICBrZXlzICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHMgPSBbXSwgciA9IFtdLCBkb25lID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gcy5wb3AoKTtcbiAgICAgICAgICByLnB1c2goY3VycmVudC5rZXkpO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyBgZGF0YWAgZmllbGRzIG9mIGFsbCBub2RlcyBpbiBvcmRlci5cbiAgICogQHJldHVybiB7QXJyYXk8VmFsdWU+fVxuICAgKi9cbiAgdmFsdWVzICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHMgPSBbXSwgciA9IFtdLCBkb25lID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gcy5wb3AoKTtcbiAgICAgICAgICByLnB1c2goY3VycmVudC5kYXRhKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfSBlbHNlIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgbm9kZSBhdCBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgYXQgKGluZGV4KSB7XG4gICAgLy8gcmVtb3ZlZCBhZnRlciBhIGNvbnNpZGVyYXRpb24sIG1vcmUgbWlzbGVhZGluZyB0aGFuIHVzZWZ1bFxuICAgIC8vIGluZGV4ID0gaW5kZXggJSB0aGlzLnNpemU7XG4gICAgLy8gaWYgKGluZGV4IDwgMCkgaW5kZXggPSB0aGlzLnNpemUgLSBpbmRleDtcblxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgcyA9IFtdLCBkb25lID0gZmFsc2UsIGkgPSAwO1xuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBzLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IHMucG9wKCk7XG4gICAgICAgICAgaWYgKGkgPT09IGluZGV4KSByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5vZGUgd2l0aCB0aGUgbWluaW11bSBrZXlcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBtaW5Ob2RlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgICB3aGlsZSAobm9kZS5sZWZ0KSBub2RlID0gbm9kZS5sZWZ0O1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyBub2RlIHdpdGggdGhlIG1heCBrZXlcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBtYXhOb2RlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgICB3aGlsZSAobm9kZS5yaWdodCkgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBNaW4ga2V5XG4gICAqIEByZXR1cm4gez9LZXl9XG4gICAqL1xuICBtaW4gKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcbiAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICAgIHdoaWxlIChub2RlLmxlZnQpIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgcmV0dXJuIG5vZGUua2V5O1xuICB9XG5cblxuICAvKipcbiAgICogTWF4IGtleVxuICAgKiBAcmV0dXJuIHs/S2V5fVxuICAgKi9cbiAgbWF4ICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgICB3aGlsZSAobm9kZS5yaWdodCkgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgcmV0dXJuIG5vZGUua2V5O1xuICB9XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZS9mYWxzZVxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuX3Jvb3Q7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBub2RlIHdpdGggc21hbGxlc3Qga2V5XG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgcG9wICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3QsIHJldHVyblZhbHVlID0gbnVsbDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgd2hpbGUgKG5vZGUubGVmdCkgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgIHJldHVyblZhbHVlID0geyBrZXk6IG5vZGUua2V5LCBkYXRhOiBub2RlLmRhdGEgfTtcbiAgICAgIHRoaXMucmVtb3ZlKG5vZGUua2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cblxuICAvKipcbiAgICogRmluZCBub2RlIGJ5IGtleVxuICAgKiBAcGFyYW0gIHtLZXl9IGtleVxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIGZpbmQgKGtleSkge1xuICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcbiAgICAvLyBpZiAocm9vdCA9PT0gbnVsbCkgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gaWYgKGtleSA9PT0gcm9vdC5rZXkpIHJldHVybiByb290O1xuXG4gICAgdmFyIHN1YnRyZWUgPSByb290LCBjbXA7XG4gICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgIHdoaWxlIChzdWJ0cmVlKSB7XG4gICAgICBjbXAgPSBjb21wYXJlKGtleSwgc3VidHJlZS5rZXkpO1xuICAgICAgaWYgICAgICAoY21wID09PSAwKSByZXR1cm4gc3VidHJlZTtcbiAgICAgIGVsc2UgaWYgKGNtcCA8IDApICAgc3VidHJlZSA9IHN1YnRyZWUubGVmdDtcbiAgICAgIGVsc2UgICAgICAgICAgICAgICAgc3VidHJlZSA9IHN1YnRyZWUucmlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBub2RlIGludG8gdGhlIHRyZWVcbiAgICogQHBhcmFtICB7S2V5fSBrZXlcbiAgICogQHBhcmFtICB7VmFsdWV9IFtkYXRhXVxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIGluc2VydCAoa2V5LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLl9yb290KSB7XG4gICAgICB0aGlzLl9yb290ID0ge1xuICAgICAgICBwYXJlbnQ6IG51bGwsIGxlZnQ6IG51bGwsIHJpZ2h0OiBudWxsLCBiYWxhbmNlRmFjdG9yOiAwLFxuICAgICAgICBrZXksIGRhdGFcbiAgICAgIH07XG4gICAgICB0aGlzLl9zaXplKys7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICB9XG5cbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgdmFyIG5vZGUgICAgPSB0aGlzLl9yb290O1xuICAgIHZhciBwYXJlbnQgID0gbnVsbDtcbiAgICB2YXIgY21wICAgICA9IDA7XG5cbiAgICBpZiAodGhpcy5fbm9EdXBsaWNhdGVzKSB7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjbXAgPSBjb21wYXJlKGtleSwgbm9kZS5rZXkpO1xuICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICBpZiAgICAgIChjbXAgPT09IDApIHJldHVybiBudWxsO1xuICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGNtcCA9IGNvbXBhcmUoa2V5LCBub2RlLmtleSk7XG4gICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgIGlmICAgICAgKGNtcCA8PSAwKSAgbm9kZSA9IG5vZGUubGVmdDsgLy9yZXR1cm4gbnVsbDtcbiAgICAgICAgZWxzZSAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Tm9kZSA9IHtcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICByaWdodDogbnVsbCxcbiAgICAgIGJhbGFuY2VGYWN0b3I6IDAsXG4gICAgICBwYXJlbnQsIGtleSwgZGF0YVxuICAgIH07XG4gICAgdmFyIG5ld1Jvb3Q7XG4gICAgaWYgKGNtcCA8PSAwKSBwYXJlbnQubGVmdCAgPSBuZXdOb2RlO1xuICAgIGVsc2UgICAgICAgICBwYXJlbnQucmlnaHQgPSBuZXdOb2RlO1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgY21wID0gY29tcGFyZShwYXJlbnQua2V5LCBrZXkpO1xuICAgICAgaWYgKGNtcCA8IDApIHBhcmVudC5iYWxhbmNlRmFjdG9yIC09IDE7XG4gICAgICBlbHNlICAgICAgICAgcGFyZW50LmJhbGFuY2VGYWN0b3IgKz0gMTtcblxuICAgICAgaWYgICAgICAgIChwYXJlbnQuYmFsYW5jZUZhY3RvciA9PT0gMCkgYnJlYWs7XG4gICAgICBlbHNlIGlmICAgKHBhcmVudC5iYWxhbmNlRmFjdG9yIDwgLTEpIHtcbiAgICAgICAgLy8gaW5saW5lZFxuICAgICAgICAvL3ZhciBuZXdSb290ID0gcmlnaHRCYWxhbmNlKHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnQucmlnaHQuYmFsYW5jZUZhY3RvciA9PT0gMSkgcm90YXRlUmlnaHQocGFyZW50LnJpZ2h0KTtcbiAgICAgICAgbmV3Um9vdCA9IHJvdGF0ZUxlZnQocGFyZW50KTtcblxuICAgICAgICBpZiAocGFyZW50ID09PSB0aGlzLl9yb290KSB0aGlzLl9yb290ID0gbmV3Um9vdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5iYWxhbmNlRmFjdG9yID4gMSkge1xuICAgICAgICAvLyBpbmxpbmVkXG4gICAgICAgIC8vIHZhciBuZXdSb290ID0gbGVmdEJhbGFuY2UocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudC5sZWZ0LmJhbGFuY2VGYWN0b3IgPT09IC0xKSByb3RhdGVMZWZ0KHBhcmVudC5sZWZ0KTtcbiAgICAgICAgbmV3Um9vdCA9IHJvdGF0ZVJpZ2h0KHBhcmVudCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcy5fcm9vdCkgdGhpcy5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICB0aGlzLl9zaXplKys7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBub2RlIGZyb20gdGhlIHRyZWUuIElmIG5vdCBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgKiBAcGFyYW0gIHtLZXl9IGtleVxuICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICovXG4gIHJlbW92ZSAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLl9yb290KSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgdmFyIGNtcCA9IDA7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgY21wID0gY29tcGFyZShrZXksIG5vZGUua2V5KTtcbiAgICAgIGlmICAgICAgKGNtcCA9PT0gMCkgYnJlYWs7XG4gICAgICBlbHNlIGlmIChjbXAgPCAwKSAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICBlbHNlICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgIH1cbiAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHJldHVyblZhbHVlID0gbm9kZS5rZXk7XG4gICAgdmFyIG1heCwgbWluO1xuXG4gICAgaWYgKG5vZGUubGVmdCkge1xuICAgICAgbWF4ID0gbm9kZS5sZWZ0O1xuXG4gICAgICB3aGlsZSAobWF4LmxlZnQgfHwgbWF4LnJpZ2h0KSB7XG4gICAgICAgIHdoaWxlIChtYXgucmlnaHQpIG1heCA9IG1heC5yaWdodDtcblxuICAgICAgICBub2RlLmtleSA9IG1heC5rZXk7XG4gICAgICAgIG5vZGUuZGF0YSA9IG1heC5kYXRhO1xuICAgICAgICBpZiAobWF4LmxlZnQpIHtcbiAgICAgICAgICBub2RlID0gbWF4O1xuICAgICAgICAgIG1heCA9IG1heC5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUua2V5ICA9IG1heC5rZXk7XG4gICAgICBub2RlLmRhdGEgPSBtYXguZGF0YTtcbiAgICAgIG5vZGUgPSBtYXg7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUucmlnaHQpIHtcbiAgICAgIG1pbiA9IG5vZGUucmlnaHQ7XG5cbiAgICAgIHdoaWxlIChtaW4ubGVmdCB8fCBtaW4ucmlnaHQpIHtcbiAgICAgICAgd2hpbGUgKG1pbi5sZWZ0KSBtaW4gPSBtaW4ubGVmdDtcblxuICAgICAgICBub2RlLmtleSAgPSBtaW4ua2V5O1xuICAgICAgICBub2RlLmRhdGEgPSBtaW4uZGF0YTtcbiAgICAgICAgaWYgKG1pbi5yaWdodCkge1xuICAgICAgICAgIG5vZGUgPSBtaW47XG4gICAgICAgICAgbWluID0gbWluLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUua2V5ICA9IG1pbi5rZXk7XG4gICAgICBub2RlLmRhdGEgPSBtaW4uZGF0YTtcbiAgICAgIG5vZGUgPSBtaW47XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIHZhciBwcCAgICAgPSBub2RlO1xuICAgIHZhciBuZXdSb290O1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5sZWZ0ID09PSBwcCkgcGFyZW50LmJhbGFuY2VGYWN0b3IgLT0gMTtcbiAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgIHBhcmVudC5iYWxhbmNlRmFjdG9yICs9IDE7XG5cbiAgICAgIGlmICAgICAgICAocGFyZW50LmJhbGFuY2VGYWN0b3IgPCAtMSkge1xuICAgICAgICAvLyBpbmxpbmVkXG4gICAgICAgIC8vdmFyIG5ld1Jvb3QgPSByaWdodEJhbGFuY2UocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudC5yaWdodC5iYWxhbmNlRmFjdG9yID09PSAxKSByb3RhdGVSaWdodChwYXJlbnQucmlnaHQpO1xuICAgICAgICBuZXdSb290ID0gcm90YXRlTGVmdChwYXJlbnQpO1xuXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMuX3Jvb3QpIHRoaXMuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgICBwYXJlbnQgPSBuZXdSb290O1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnQuYmFsYW5jZUZhY3RvciA+IDEpIHtcbiAgICAgICAgLy8gaW5saW5lZFxuICAgICAgICAvLyB2YXIgbmV3Um9vdCA9IGxlZnRCYWxhbmNlKHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnQubGVmdC5iYWxhbmNlRmFjdG9yID09PSAtMSkgcm90YXRlTGVmdChwYXJlbnQubGVmdCk7XG4gICAgICAgIG5ld1Jvb3QgPSByb3RhdGVSaWdodChwYXJlbnQpO1xuXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMuX3Jvb3QpIHRoaXMuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgICBwYXJlbnQgPSBuZXdSb290O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50LmJhbGFuY2VGYWN0b3IgPT09IC0xIHx8IHBhcmVudC5iYWxhbmNlRmFjdG9yID09PSAxKSBicmVhaztcblxuICAgICAgcHAgICAgID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgIGlmIChub2RlLnBhcmVudC5sZWZ0ID09PSBub2RlKSBub2RlLnBhcmVudC5sZWZ0ICA9IG51bGw7XG4gICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQucmlnaHQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB0aGlzLl9yb290KSB0aGlzLl9yb290ID0gbnVsbDtcblxuICAgIHRoaXMuX3NpemUtLTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBCdWxrLWxvYWQgaXRlbXNcbiAgICogQHBhcmFtICB7QXJyYXk8S2V5Pn0gIGtleXNcbiAgICogQHBhcmFtICB7QXJyYXk8VmFsdWU+fSAgW3ZhbHVlc11cbiAgICogQHJldHVybiB7QVZMVHJlZX1cbiAgICovXG4gIGxvYWQoa2V5cyA9IFtdLCB2YWx1ZXMgPSBbXSwgcHJlc29ydCkge1xuICAgIGlmICh0aGlzLl9zaXplICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2J1bGstbG9hZDogdHJlZSBpcyBub3QgZW1wdHknKTtcbiAgICBjb25zdCBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKHByZXNvcnQpIHNvcnQoa2V5cywgdmFsdWVzLCAwLCBzaXplIC0gMSwgdGhpcy5fY29tcGFyYXRvcik7XG4gICAgdGhpcy5fcm9vdCA9IGxvYWRSZWN1cnNpdmUobnVsbCwga2V5cywgdmFsdWVzLCAwLCBzaXplKTtcbiAgICBtYXJrQmFsYW5jZSh0aGlzLl9yb290KTtcbiAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJlZSBpcyBiYWxhbmNlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNCYWxhbmNlZCgpIHtcbiAgICByZXR1cm4gaXNCYWxhbmNlZCh0aGlzLl9yb290KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJlZSAtIHByaW1pdGl2ZSBob3Jpem9udGFsIHByaW50LW91dFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbihOb2RlKTpzdHJpbmd9IFtwcmludE5vZGVdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nIChwcmludE5vZGUpIHtcbiAgICByZXR1cm4gcHJpbnQodGhpcy5fcm9vdCwgcHJpbnROb2RlKTtcbiAgfVxufVxuXG5BVkxUcmVlLmRlZmF1bHQgPSBBVkxUcmVlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/avl/src/index.js\n");

/***/ }),

/***/ "./node_modules/avl/src/utils.js":
/*!***************************************!*\
  !*** ./node_modules/avl/src/utils.js ***!
  \***************************************/
/*! exports provided: print, isBalanced, loadRecursive, markBalance, sort */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"print\", function() { return print; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBalanced\", function() { return isBalanced; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRecursive\", function() { return loadRecursive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"markBalance\", function() { return markBalance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sort\", function() { return sort; });\n\n/**\n * Prints tree horizontally\n * @param  {Node}                       root\n * @param  {Function(node:Node):String} [printNode]\n * @return {String}\n */\nfunction print (root, printNode = (n) => n.key) {\n  var out = [];\n  row(root, '', true, (v) => out.push(v), printNode);\n  return out.join('');\n}\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Function(in:string):void}    out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction row (root, prefix, isTail, out, printNode) {\n  if (root) {\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\n`);\n    const indent = prefix + (isTail ? '    ' : '│   ');\n    if (root.left)  row(root.left,  indent, false, out, printNode);\n    if (root.right) row(root.right, indent, true,  out, printNode);\n  }\n}\n\n\n/**\n * Is the tree balanced (none of the subtrees differ in height by more than 1)\n * @param  {Node}    root\n * @return {Boolean}\n */\nfunction isBalanced(root) {\n  if (root === null) return true; // If node is empty then return true\n\n  // Get the height of left and right sub trees\n  var lh = height(root.left);\n  var rh = height(root.right);\n\n  if (Math.abs(lh - rh) <= 1 &&\n      isBalanced(root.left)  &&\n      isBalanced(root.right)) return true;\n\n  // If we reach here then tree is not height-balanced\n  return false;\n}\n\n/**\n * The function Compute the 'height' of a tree.\n * Height is the number of nodes along the longest path\n * from the root node down to the farthest leaf node.\n *\n * @param  {Node} node\n * @return {Number}\n */\nfunction height(node) {\n  return node ? (1 + Math.max(height(node.left), height(node.right))) : 0;\n}\n\n\nfunction loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nfunction markBalance(node) {\n  if (node === null) return 0;\n  const lh = markBalance(node.left);\n  const rh = markBalance(node.right);\n\n  node.balanceFactor = lh - rh;\n  return Math.max(lh, rh) + 1;\n}\n\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  // eslint-disable-next-line no-bitwise\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXZsL3NyYy91dGlscy5qcz83MjA2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksMkJBQTJCO0FBQ3ZDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUyxFQUFFLDJCQUEyQixFQUFFLGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVk7QUFDWjtBQUNPO0FBQ1AsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXZsL3NyYy91dGlscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBQcmludHMgdHJlZSBob3Jpem9udGFsbHlcbiAqIEBwYXJhbSAge05vZGV9ICAgICAgICAgICAgICAgICAgICAgICByb290XG4gKiBAcGFyYW0gIHtGdW5jdGlvbihub2RlOk5vZGUpOlN0cmluZ30gW3ByaW50Tm9kZV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50IChyb290LCBwcmludE5vZGUgPSAobikgPT4gbi5rZXkpIHtcbiAgdmFyIG91dCA9IFtdO1xuICByb3cocm9vdCwgJycsIHRydWUsICh2KSA9PiBvdXQucHVzaCh2KSwgcHJpbnROb2RlKTtcbiAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBQcmludHMgbGV2ZWwgb2YgdGhlIHRyZWVcbiAqIEBwYXJhbSAge05vZGV9ICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICBwcmVmaXhcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgaXNUYWlsXG4gKiBAcGFyYW0gIHtGdW5jdGlvbihpbjpzdHJpbmcpOnZvaWR9ICAgIG91dFxuICogQHBhcmFtICB7RnVuY3Rpb24obm9kZTpOb2RlKTpTdHJpbmd9ICBwcmludE5vZGVcbiAqL1xuZnVuY3Rpb24gcm93IChyb290LCBwcmVmaXgsIGlzVGFpbCwgb3V0LCBwcmludE5vZGUpIHtcbiAgaWYgKHJvb3QpIHtcbiAgICBvdXQoYCR7IHByZWZpeCB9JHsgaXNUYWlsID8gJ+KUlOKUgOKUgCAnIDogJ+KUnOKUgOKUgCAnIH0keyBwcmludE5vZGUocm9vdCkgfVxcbmApO1xuICAgIGNvbnN0IGluZGVudCA9IHByZWZpeCArIChpc1RhaWwgPyAnICAgICcgOiAn4pSCICAgJyk7XG4gICAgaWYgKHJvb3QubGVmdCkgIHJvdyhyb290LmxlZnQsICBpbmRlbnQsIGZhbHNlLCBvdXQsIHByaW50Tm9kZSk7XG4gICAgaWYgKHJvb3QucmlnaHQpIHJvdyhyb290LnJpZ2h0LCBpbmRlbnQsIHRydWUsICBvdXQsIHByaW50Tm9kZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIElzIHRoZSB0cmVlIGJhbGFuY2VkIChub25lIG9mIHRoZSBzdWJ0cmVlcyBkaWZmZXIgaW4gaGVpZ2h0IGJ5IG1vcmUgdGhhbiAxKVxuICogQHBhcmFtICB7Tm9kZX0gICAgcm9vdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmFsYW5jZWQocm9vdCkge1xuICBpZiAocm9vdCA9PT0gbnVsbCkgcmV0dXJuIHRydWU7IC8vIElmIG5vZGUgaXMgZW1wdHkgdGhlbiByZXR1cm4gdHJ1ZVxuXG4gIC8vIEdldCB0aGUgaGVpZ2h0IG9mIGxlZnQgYW5kIHJpZ2h0IHN1YiB0cmVlc1xuICB2YXIgbGggPSBoZWlnaHQocm9vdC5sZWZ0KTtcbiAgdmFyIHJoID0gaGVpZ2h0KHJvb3QucmlnaHQpO1xuXG4gIGlmIChNYXRoLmFicyhsaCAtIHJoKSA8PSAxICYmXG4gICAgICBpc0JhbGFuY2VkKHJvb3QubGVmdCkgICYmXG4gICAgICBpc0JhbGFuY2VkKHJvb3QucmlnaHQpKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBJZiB3ZSByZWFjaCBoZXJlIHRoZW4gdHJlZSBpcyBub3QgaGVpZ2h0LWJhbGFuY2VkXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gQ29tcHV0ZSB0aGUgJ2hlaWdodCcgb2YgYSB0cmVlLlxuICogSGVpZ2h0IGlzIHRoZSBudW1iZXIgb2Ygbm9kZXMgYWxvbmcgdGhlIGxvbmdlc3QgcGF0aFxuICogZnJvbSB0aGUgcm9vdCBub2RlIGRvd24gdG8gdGhlIGZhcnRoZXN0IGxlYWYgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGhlaWdodChub2RlKSB7XG4gIHJldHVybiBub2RlID8gKDEgKyBNYXRoLm1heChoZWlnaHQobm9kZS5sZWZ0KSwgaGVpZ2h0KG5vZGUucmlnaHQpKSkgOiAwO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUmVjdXJzaXZlIChwYXJlbnQsIGtleXMsIHZhbHVlcywgc3RhcnQsIGVuZCkge1xuICBjb25zdCBzaXplID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChzaXplID4gMCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgTWF0aC5mbG9vcihzaXplIC8gMik7XG4gICAgY29uc3Qga2V5ICAgID0ga2V5c1ttaWRkbGVdO1xuICAgIGNvbnN0IGRhdGEgICA9IHZhbHVlc1ttaWRkbGVdO1xuICAgIGNvbnN0IG5vZGUgICA9IHsga2V5LCBkYXRhLCBwYXJlbnQgfTtcbiAgICBub2RlLmxlZnQgICAgPSBsb2FkUmVjdXJzaXZlKG5vZGUsIGtleXMsIHZhbHVlcywgc3RhcnQsIG1pZGRsZSk7XG4gICAgbm9kZS5yaWdodCAgID0gbG9hZFJlY3Vyc2l2ZShub2RlLCBrZXlzLCB2YWx1ZXMsIG1pZGRsZSArIDEsIGVuZCk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtCYWxhbmNlKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IG51bGwpIHJldHVybiAwO1xuICBjb25zdCBsaCA9IG1hcmtCYWxhbmNlKG5vZGUubGVmdCk7XG4gIGNvbnN0IHJoID0gbWFya0JhbGFuY2Uobm9kZS5yaWdodCk7XG5cbiAgbm9kZS5iYWxhbmNlRmFjdG9yID0gbGggLSByaDtcbiAgcmV0dXJuIE1hdGgubWF4KGxoLCByaCkgKyAxO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0KGtleXMsIHZhbHVlcywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcbiAgaWYgKGxlZnQgPj0gcmlnaHQpIHJldHVybjtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICBjb25zdCBwaXZvdCA9IGtleXNbKGxlZnQgKyByaWdodCkgPj4gMV07XG4gIGxldCBpID0gbGVmdCAtIDE7XG4gIGxldCBqID0gcmlnaHQgKyAxO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBkbyBpKys7IHdoaWxlIChjb21wYXJlKGtleXNbaV0sIHBpdm90KSA8IDApO1xuICAgIGRvIGotLTsgd2hpbGUgKGNvbXBhcmUoa2V5c1tqXSwgcGl2b3QpID4gMCk7XG4gICAgaWYgKGkgPj0gaikgYnJlYWs7XG5cbiAgICBsZXQgdG1wID0ga2V5c1tpXTtcbiAgICBrZXlzW2ldID0ga2V5c1tqXTtcbiAgICBrZXlzW2pdID0gdG1wO1xuXG4gICAgdG1wID0gdmFsdWVzW2ldO1xuICAgIHZhbHVlc1tpXSA9IHZhbHVlc1tqXTtcbiAgICB2YWx1ZXNbal0gPSB0bXA7XG4gIH1cblxuICBzb3J0KGtleXMsIHZhbHVlcywgIGxlZnQsICAgICBqLCBjb21wYXJlKTtcbiAgc29ydChrZXlzLCB2YWx1ZXMsIGogKyAxLCByaWdodCwgY29tcGFyZSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/avl/src/utils.js\n");

/***/ }),

/***/ "./node_modules/cropperjs/dist/cropper.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/cropperjs/dist/cropper.esm.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*!\n * Cropper.js v1.4.1\n * https://fengyuanchen.github.io/cropperjs\n *\n * Copyright 2015-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2018-07-15T09:55:31.170Z\n */\n\nvar IN_BROWSER = typeof window !== 'undefined';\nvar WINDOW = IN_BROWSER ? window : {};\nvar NAMESPACE = 'cropper';\n\n// Actions\nvar ACTION_ALL = 'all';\nvar ACTION_CROP = 'crop';\nvar ACTION_MOVE = 'move';\nvar ACTION_ZOOM = 'zoom';\nvar ACTION_EAST = 'e';\nvar ACTION_WEST = 'w';\nvar ACTION_SOUTH = 's';\nvar ACTION_NORTH = 'n';\nvar ACTION_NORTH_EAST = 'ne';\nvar ACTION_NORTH_WEST = 'nw';\nvar ACTION_SOUTH_EAST = 'se';\nvar ACTION_SOUTH_WEST = 'sw';\n\n// Classes\nvar CLASS_CROP = NAMESPACE + '-crop';\nvar CLASS_DISABLED = NAMESPACE + '-disabled';\nvar CLASS_HIDDEN = NAMESPACE + '-hidden';\nvar CLASS_HIDE = NAMESPACE + '-hide';\nvar CLASS_INVISIBLE = NAMESPACE + '-invisible';\nvar CLASS_MODAL = NAMESPACE + '-modal';\nvar CLASS_MOVE = NAMESPACE + '-move';\n\n// Data keys\nvar DATA_ACTION = NAMESPACE + 'Action';\nvar DATA_PREVIEW = NAMESPACE + 'Preview';\n\n// Drag modes\nvar DRAG_MODE_CROP = 'crop';\nvar DRAG_MODE_MOVE = 'move';\nvar DRAG_MODE_NONE = 'none';\n\n// Events\nvar EVENT_CROP = 'crop';\nvar EVENT_CROP_END = 'cropend';\nvar EVENT_CROP_MOVE = 'cropmove';\nvar EVENT_CROP_START = 'cropstart';\nvar EVENT_DBLCLICK = 'dblclick';\nvar EVENT_POINTER_DOWN = WINDOW.PointerEvent ? 'pointerdown' : 'touchstart mousedown';\nvar EVENT_POINTER_MOVE = WINDOW.PointerEvent ? 'pointermove' : 'touchmove mousemove';\nvar EVENT_POINTER_UP = WINDOW.PointerEvent ? 'pointerup pointercancel' : 'touchend touchcancel mouseup';\nvar EVENT_READY = 'ready';\nvar EVENT_RESIZE = 'resize';\nvar EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';\nvar EVENT_ZOOM = 'zoom';\n\n// RegExps\nvar REGEXP_ACTIONS = /^(?:e|w|s|n|se|sw|ne|nw|all|crop|move|zoom)$/;\nvar REGEXP_DATA_URL = /^data:/;\nvar REGEXP_DATA_URL_JPEG = /^data:image\\/jpeg;base64,/;\nvar REGEXP_TAG_NAME = /^(?:img|canvas)$/i;\n\nvar DEFAULTS = {\n  // Define the view mode of the cropper\n  viewMode: 0, // 0, 1, 2, 3\n\n  // Define the dragging mode of the cropper\n  dragMode: DRAG_MODE_CROP, // 'crop', 'move' or 'none'\n\n  // Define the initial aspect ratio of the crop box\n  initialAspectRatio: NaN,\n\n  // Define the aspect ratio of the crop box\n  aspectRatio: NaN,\n\n  // An object with the previous cropping result data\n  data: null,\n\n  // A selector for adding extra containers to preview\n  preview: '',\n\n  // Re-render the cropper when resize the window\n  responsive: true,\n\n  // Restore the cropped area after resize the window\n  restore: true,\n\n  // Check if the current image is a cross-origin image\n  checkCrossOrigin: true,\n\n  // Check the current image's Exif Orientation information\n  checkOrientation: true,\n\n  // Show the black modal\n  modal: true,\n\n  // Show the dashed lines for guiding\n  guides: true,\n\n  // Show the center indicator for guiding\n  center: true,\n\n  // Show the white modal to highlight the crop box\n  highlight: true,\n\n  // Show the grid background\n  background: true,\n\n  // Enable to crop the image automatically when initialize\n  autoCrop: true,\n\n  // Define the percentage of automatic cropping area when initializes\n  autoCropArea: 0.8,\n\n  // Enable to move the image\n  movable: true,\n\n  // Enable to rotate the image\n  rotatable: true,\n\n  // Enable to scale the image\n  scalable: true,\n\n  // Enable to zoom the image\n  zoomable: true,\n\n  // Enable to zoom the image by dragging touch\n  zoomOnTouch: true,\n\n  // Enable to zoom the image by wheeling mouse\n  zoomOnWheel: true,\n\n  // Define zoom ratio when zoom the image by wheeling mouse\n  wheelZoomRatio: 0.1,\n\n  // Enable to move the crop box\n  cropBoxMovable: true,\n\n  // Enable to resize the crop box\n  cropBoxResizable: true,\n\n  // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n  toggleDragModeOnDblclick: true,\n\n  // Size limitation\n  minCanvasWidth: 0,\n  minCanvasHeight: 0,\n  minCropBoxWidth: 0,\n  minCropBoxHeight: 0,\n  minContainerWidth: 200,\n  minContainerHeight: 100,\n\n  // Shortcuts of events\n  ready: null,\n  cropstart: null,\n  cropmove: null,\n  cropend: null,\n  crop: null,\n  zoom: null\n};\n\nvar TEMPLATE = '<div class=\"cropper-container\" touch-action=\"none\">' + '<div class=\"cropper-wrap-box\">' + '<div class=\"cropper-canvas\"></div>' + '</div>' + '<div class=\"cropper-drag-box\"></div>' + '<div class=\"cropper-crop-box\">' + '<span class=\"cropper-view-box\"></span>' + '<span class=\"cropper-dashed dashed-h\"></span>' + '<span class=\"cropper-dashed dashed-v\"></span>' + '<span class=\"cropper-center\"></span>' + '<span class=\"cropper-face\"></span>' + '<span class=\"cropper-line line-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-line line-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-line line-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-line line-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-point point-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-point point-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-point point-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-ne\" data-cropper-action=\"ne\"></span>' + '<span class=\"cropper-point point-nw\" data-cropper-action=\"nw\"></span>' + '<span class=\"cropper-point point-sw\" data-cropper-action=\"sw\"></span>' + '<span class=\"cropper-point point-se\" data-cropper-action=\"se\"></span>' + '</div>' + '</div>';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/**\n * Check if the given value is not a number.\n */\nvar isNaN = Number.isNaN || WINDOW.isNaN;\n\n/**\n * Check if the given value is a number.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a number, else `false`.\n */\nfunction isNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Check if the given value is undefined.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is undefined, else `false`.\n */\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\n\n/**\n * Check if the given value is an object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is an object, else `false`.\n */\nfunction isObject(value) {\n  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Check if the given value is a plain object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\n */\n\nfunction isPlainObject(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  try {\n    var _constructor = value.constructor;\n    var prototype = _constructor.prototype;\n\n\n    return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Check if the given value is a function.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a function, else `false`.\n */\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\n * Iterate the given data.\n * @param {*} data - The data to iterate.\n * @param {Function} callback - The process function for each element.\n * @returns {*} The original data.\n */\nfunction forEach(data, callback) {\n  if (data && isFunction(callback)) {\n    if (Array.isArray(data) || isNumber(data.length) /* array-like */) {\n        var length = data.length;\n\n        var i = void 0;\n\n        for (i = 0; i < length; i += 1) {\n          if (callback.call(data, data[i], i, data) === false) {\n            break;\n          }\n        }\n      } else if (isObject(data)) {\n      Object.keys(data).forEach(function (key) {\n        callback.call(data, data[key], key, data);\n      });\n    }\n  }\n\n  return data;\n}\n\n/**\n * Extend the given object.\n * @param {*} obj - The object to be extended.\n * @param {*} args - The rest objects which will be merged to the first object.\n * @returns {Object} The extended object.\n */\nvar assign = Object.assign || function assign(obj) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  if (isObject(obj) && args.length > 0) {\n    args.forEach(function (arg) {\n      if (isObject(arg)) {\n        Object.keys(arg).forEach(function (key) {\n          obj[key] = arg[key];\n        });\n      }\n    });\n  }\n\n  return obj;\n};\n\nvar REGEXP_DECIMALS = /\\.\\d*(?:0|9){12}\\d*$/i;\n\n/**\n * Normalize decimal number.\n * Check out {@link http://0.30000000000000004.com/}\n * @param {number} value - The value to normalize.\n * @param {number} [times=100000000000] - The times for normalizing.\n * @returns {number} Returns the normalized number.\n */\nfunction normalizeDecimalNumber(value) {\n  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;\n\n  return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;\n}\n\nvar REGEXP_SUFFIX = /^(?:width|height|left|top|marginLeft|marginTop)$/;\n\n/**\n * Apply styles to the given element.\n * @param {Element} element - The target element.\n * @param {Object} styles - The styles for applying.\n */\nfunction setStyle(element, styles) {\n  var style = element.style;\n\n\n  forEach(styles, function (value, property) {\n    if (REGEXP_SUFFIX.test(property) && isNumber(value)) {\n      value += 'px';\n    }\n\n    style[property] = value;\n  });\n}\n\n/**\n * Check if the given element has a special class.\n * @param {Element} element - The element to check.\n * @param {string} value - The class to search.\n * @returns {boolean} Returns `true` if the special class was found.\n */\nfunction hasClass(element, value) {\n  return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;\n}\n\n/**\n * Add classes to the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be added.\n */\nfunction addClass(element, value) {\n  if (!value) {\n    return;\n  }\n\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      addClass(elem, value);\n    });\n    return;\n  }\n\n  if (element.classList) {\n    element.classList.add(value);\n    return;\n  }\n\n  var className = element.className.trim();\n\n  if (!className) {\n    element.className = value;\n  } else if (className.indexOf(value) < 0) {\n    element.className = className + ' ' + value;\n  }\n}\n\n/**\n * Remove classes from the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be removed.\n */\nfunction removeClass(element, value) {\n  if (!value) {\n    return;\n  }\n\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      removeClass(elem, value);\n    });\n    return;\n  }\n\n  if (element.classList) {\n    element.classList.remove(value);\n    return;\n  }\n\n  if (element.className.indexOf(value) >= 0) {\n    element.className = element.className.replace(value, '');\n  }\n}\n\n/**\n * Add or remove classes from the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be toggled.\n * @param {boolean} added - Add only.\n */\nfunction toggleClass(element, value, added) {\n  if (!value) {\n    return;\n  }\n\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      toggleClass(elem, value, added);\n    });\n    return;\n  }\n\n  // IE10-11 doesn't support the second parameter of `classList.toggle`\n  if (added) {\n    addClass(element, value);\n  } else {\n    removeClass(element, value);\n  }\n}\n\nvar REGEXP_HYPHENATE = /([a-z\\d])([A-Z])/g;\n\n/**\n * Transform the given string from camelCase to kebab-case\n * @param {string} value - The value to transform.\n * @returns {string} The transformed value.\n */\nfunction hyphenate(value) {\n  return value.replace(REGEXP_HYPHENATE, '$1-$2').toLowerCase();\n}\n\n/**\n * Get data from the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to get.\n * @returns {string} The data value.\n */\nfunction getData(element, name) {\n  if (isObject(element[name])) {\n    return element[name];\n  }\n\n  if (element.dataset) {\n    return element.dataset[name];\n  }\n\n  return element.getAttribute('data-' + hyphenate(name));\n}\n\n/**\n * Set data to the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to set.\n * @param {string} data - The data value.\n */\nfunction setData(element, name, data) {\n  if (isObject(data)) {\n    element[name] = data;\n  } else if (element.dataset) {\n    element.dataset[name] = data;\n  } else {\n    element.setAttribute('data-' + hyphenate(name), data);\n  }\n}\n\n/**\n * Remove data from the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to remove.\n */\nfunction removeData(element, name) {\n  if (isObject(element[name])) {\n    try {\n      delete element[name];\n    } catch (e) {\n      element[name] = undefined;\n    }\n  } else if (element.dataset) {\n    // #128 Safari not allows to delete dataset property\n    try {\n      delete element.dataset[name];\n    } catch (e) {\n      element.dataset[name] = undefined;\n    }\n  } else {\n    element.removeAttribute('data-' + hyphenate(name));\n  }\n}\n\nvar REGEXP_SPACES = /\\s\\s*/;\nvar onceSupported = function () {\n  var supported = false;\n\n  if (IN_BROWSER) {\n    var once = false;\n    var listener = function listener() {};\n    var options = Object.defineProperty({}, 'once', {\n      get: function get$$1() {\n        supported = true;\n        return once;\n      },\n\n\n      /**\n       * This setter can fix a `TypeError` in strict mode\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}\n       * @param {boolean} value - The value to set\n       */\n      set: function set$$1(value) {\n        once = value;\n      }\n    });\n\n    WINDOW.addEventListener('test', listener, options);\n    WINDOW.removeEventListener('test', listener, options);\n  }\n\n  return supported;\n}();\n\n/**\n * Remove event listener from the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Function} listener - The event listener.\n * @param {Object} options - The event options.\n */\nfunction removeListener(element, type, listener) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var handler = listener;\n\n  type.trim().split(REGEXP_SPACES).forEach(function (event) {\n    if (!onceSupported) {\n      var listeners = element.listeners;\n\n\n      if (listeners && listeners[event] && listeners[event][listener]) {\n        handler = listeners[event][listener];\n        delete listeners[event][listener];\n\n        if (Object.keys(listeners[event]).length === 0) {\n          delete listeners[event];\n        }\n\n        if (Object.keys(listeners).length === 0) {\n          delete element.listeners;\n        }\n      }\n    }\n\n    element.removeEventListener(event, handler, options);\n  });\n}\n\n/**\n * Add event listener to the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Function} listener - The event listener.\n * @param {Object} options - The event options.\n */\nfunction addListener(element, type, listener) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var _handler = listener;\n\n  type.trim().split(REGEXP_SPACES).forEach(function (event) {\n    if (options.once && !onceSupported) {\n      var _element$listeners = element.listeners,\n          listeners = _element$listeners === undefined ? {} : _element$listeners;\n\n\n      _handler = function handler() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        delete listeners[event][listener];\n        element.removeEventListener(event, _handler, options);\n        listener.apply(element, args);\n      };\n\n      if (!listeners[event]) {\n        listeners[event] = {};\n      }\n\n      if (listeners[event][listener]) {\n        element.removeEventListener(event, listeners[event][listener], options);\n      }\n\n      listeners[event][listener] = _handler;\n      element.listeners = listeners;\n    }\n\n    element.addEventListener(event, _handler, options);\n  });\n}\n\n/**\n * Dispatch event on the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Object} data - The additional event data.\n * @returns {boolean} Indicate if the event is default prevented or not.\n */\nfunction dispatchEvent(element, type, data) {\n  var event = void 0;\n\n  // Event and CustomEvent on IE9-11 are global objects, not constructors\n  if (isFunction(Event) && isFunction(CustomEvent)) {\n    event = new CustomEvent(type, {\n      detail: data,\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    event = document.createEvent('CustomEvent');\n    event.initCustomEvent(type, true, true, data);\n  }\n\n  return element.dispatchEvent(event);\n}\n\n/**\n * Get the offset base on the document.\n * @param {Element} element - The target element.\n * @returns {Object} The offset data.\n */\nfunction getOffset(element) {\n  var box = element.getBoundingClientRect();\n\n  return {\n    left: box.left + (window.pageXOffset - document.documentElement.clientLeft),\n    top: box.top + (window.pageYOffset - document.documentElement.clientTop)\n  };\n}\n\nvar location = WINDOW.location;\n\nvar REGEXP_ORIGINS = /^(https?:)\\/\\/([^:/?#]+):?(\\d*)/i;\n\n/**\n * Check if the given URL is a cross origin URL.\n * @param {string} url - The target URL.\n * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.\n */\nfunction isCrossOriginURL(url) {\n  var parts = url.match(REGEXP_ORIGINS);\n\n  return parts && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);\n}\n\n/**\n * Add timestamp to the given URL.\n * @param {string} url - The target URL.\n * @returns {string} The result URL.\n */\nfunction addTimestamp(url) {\n  var timestamp = 'timestamp=' + new Date().getTime();\n\n  return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;\n}\n\n/**\n * Get transforms base on the given object.\n * @param {Object} obj - The target object.\n * @returns {string} A string contains transform values.\n */\nfunction getTransforms(_ref) {\n  var rotate = _ref.rotate,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      translateX = _ref.translateX,\n      translateY = _ref.translateY;\n\n  var values = [];\n\n  if (isNumber(translateX) && translateX !== 0) {\n    values.push('translateX(' + translateX + 'px)');\n  }\n\n  if (isNumber(translateY) && translateY !== 0) {\n    values.push('translateY(' + translateY + 'px)');\n  }\n\n  // Rotate should come first before scale to match orientation transform\n  if (isNumber(rotate) && rotate !== 0) {\n    values.push('rotate(' + rotate + 'deg)');\n  }\n\n  if (isNumber(scaleX) && scaleX !== 1) {\n    values.push('scaleX(' + scaleX + ')');\n  }\n\n  if (isNumber(scaleY) && scaleY !== 1) {\n    values.push('scaleY(' + scaleY + ')');\n  }\n\n  var transform = values.length ? values.join(' ') : 'none';\n\n  return {\n    WebkitTransform: transform,\n    msTransform: transform,\n    transform: transform\n  };\n}\n\n/**\n * Get the max ratio of a group of pointers.\n * @param {string} pointers - The target pointers.\n * @returns {number} The result ratio.\n */\nfunction getMaxZoomRatio(pointers) {\n  var pointers2 = assign({}, pointers);\n  var ratios = [];\n\n  forEach(pointers, function (pointer, pointerId) {\n    delete pointers2[pointerId];\n\n    forEach(pointers2, function (pointer2) {\n      var x1 = Math.abs(pointer.startX - pointer2.startX);\n      var y1 = Math.abs(pointer.startY - pointer2.startY);\n      var x2 = Math.abs(pointer.endX - pointer2.endX);\n      var y2 = Math.abs(pointer.endY - pointer2.endY);\n      var z1 = Math.sqrt(x1 * x1 + y1 * y1);\n      var z2 = Math.sqrt(x2 * x2 + y2 * y2);\n      var ratio = (z2 - z1) / z1;\n\n      ratios.push(ratio);\n    });\n  });\n\n  ratios.sort(function (a, b) {\n    return Math.abs(a) < Math.abs(b);\n  });\n\n  return ratios[0];\n}\n\n/**\n * Get a pointer from an event object.\n * @param {Object} event - The target event object.\n * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.\n * @returns {Object} The result pointer contains start and/or end point coordinates.\n */\nfunction getPointer(_ref2, endOnly) {\n  var pageX = _ref2.pageX,\n      pageY = _ref2.pageY;\n\n  var end = {\n    endX: pageX,\n    endY: pageY\n  };\n\n  return endOnly ? end : assign({\n    startX: pageX,\n    startY: pageY\n  }, end);\n}\n\n/**\n * Get the center point coordinate of a group of pointers.\n * @param {Object} pointers - The target pointers.\n * @returns {Object} The center point coordinate.\n */\nfunction getPointersCenter(pointers) {\n  var pageX = 0;\n  var pageY = 0;\n  var count = 0;\n\n  forEach(pointers, function (_ref3) {\n    var startX = _ref3.startX,\n        startY = _ref3.startY;\n\n    pageX += startX;\n    pageY += startY;\n    count += 1;\n  });\n\n  pageX /= count;\n  pageY /= count;\n\n  return {\n    pageX: pageX,\n    pageY: pageY\n  };\n}\n\n/**\n * Check if the given value is a finite number.\n */\nvar isFinite = Number.isFinite || WINDOW.isFinite;\n\n/**\n * Get the max sizes in a rectangle under the given aspect ratio.\n * @param {Object} data - The original sizes.\n * @param {string} [type='contain'] - The adjust type.\n * @returns {Object} The result sizes.\n */\nfunction getAdjustedSizes(_ref4) // or 'cover'\n{\n  var aspectRatio = _ref4.aspectRatio,\n      height = _ref4.height,\n      width = _ref4.width;\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';\n\n  var isValidNumber = function isValidNumber(value) {\n    return isFinite(value) && value > 0;\n  };\n\n  if (isValidNumber(width) && isValidNumber(height)) {\n    var adjustedWidth = height * aspectRatio;\n\n    if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {\n      height = width / aspectRatio;\n    } else {\n      width = height * aspectRatio;\n    }\n  } else if (isValidNumber(width)) {\n    height = width / aspectRatio;\n  } else if (isValidNumber(height)) {\n    width = height * aspectRatio;\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\n/**\n * Get the new sizes of a rectangle after rotated.\n * @param {Object} data - The original sizes.\n * @returns {Object} The result sizes.\n */\nfunction getRotatedSizes(_ref5) {\n  var width = _ref5.width,\n      height = _ref5.height,\n      degree = _ref5.degree;\n\n  degree = Math.abs(degree) % 180;\n\n  if (degree === 90) {\n    return {\n      width: height,\n      height: width\n    };\n  }\n\n  var arc = degree % 90 * Math.PI / 180;\n  var sinArc = Math.sin(arc);\n  var cosArc = Math.cos(arc);\n  var newWidth = width * cosArc + height * sinArc;\n  var newHeight = width * sinArc + height * cosArc;\n\n  return degree > 90 ? {\n    width: newHeight,\n    height: newWidth\n  } : {\n    width: newWidth,\n    height: newHeight\n  };\n}\n\n/**\n * Get a canvas which drew the given image.\n * @param {HTMLImageElement} image - The image for drawing.\n * @param {Object} imageData - The image data.\n * @param {Object} canvasData - The canvas data.\n * @param {Object} options - The options.\n * @returns {HTMLCanvasElement} The result canvas.\n */\nfunction getSourceCanvas(image, _ref6, _ref7, _ref8) {\n  var imageAspectRatio = _ref6.aspectRatio,\n      imageNaturalWidth = _ref6.naturalWidth,\n      imageNaturalHeight = _ref6.naturalHeight,\n      _ref6$rotate = _ref6.rotate,\n      rotate = _ref6$rotate === undefined ? 0 : _ref6$rotate,\n      _ref6$scaleX = _ref6.scaleX,\n      scaleX = _ref6$scaleX === undefined ? 1 : _ref6$scaleX,\n      _ref6$scaleY = _ref6.scaleY,\n      scaleY = _ref6$scaleY === undefined ? 1 : _ref6$scaleY;\n  var aspectRatio = _ref7.aspectRatio,\n      naturalWidth = _ref7.naturalWidth,\n      naturalHeight = _ref7.naturalHeight;\n  var _ref8$fillColor = _ref8.fillColor,\n      fillColor = _ref8$fillColor === undefined ? 'transparent' : _ref8$fillColor,\n      _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,\n      imageSmoothingEnabled = _ref8$imageSmoothingE === undefined ? true : _ref8$imageSmoothingE,\n      _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,\n      imageSmoothingQuality = _ref8$imageSmoothingQ === undefined ? 'low' : _ref8$imageSmoothingQ,\n      _ref8$maxWidth = _ref8.maxWidth,\n      maxWidth = _ref8$maxWidth === undefined ? Infinity : _ref8$maxWidth,\n      _ref8$maxHeight = _ref8.maxHeight,\n      maxHeight = _ref8$maxHeight === undefined ? Infinity : _ref8$maxHeight,\n      _ref8$minWidth = _ref8.minWidth,\n      minWidth = _ref8$minWidth === undefined ? 0 : _ref8$minWidth,\n      _ref8$minHeight = _ref8.minHeight,\n      minHeight = _ref8$minHeight === undefined ? 0 : _ref8$minHeight;\n\n  var canvas = document.createElement('canvas');\n  var context = canvas.getContext('2d');\n  var maxSizes = getAdjustedSizes({\n    aspectRatio: aspectRatio,\n    width: maxWidth,\n    height: maxHeight\n  });\n  var minSizes = getAdjustedSizes({\n    aspectRatio: aspectRatio,\n    width: minWidth,\n    height: minHeight\n  }, 'cover');\n  var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));\n  var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight));\n\n  // Note: should always use image's natural sizes for drawing as\n  // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90\n  var destMaxSizes = getAdjustedSizes({\n    aspectRatio: imageAspectRatio,\n    width: maxWidth,\n    height: maxHeight\n  });\n  var destMinSizes = getAdjustedSizes({\n    aspectRatio: imageAspectRatio,\n    width: minWidth,\n    height: minHeight\n  }, 'cover');\n  var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));\n  var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));\n  var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];\n\n  canvas.width = normalizeDecimalNumber(width);\n  canvas.height = normalizeDecimalNumber(height);\n  context.fillStyle = fillColor;\n  context.fillRect(0, 0, width, height);\n  context.save();\n  context.translate(width / 2, height / 2);\n  context.rotate(rotate * Math.PI / 180);\n  context.scale(scaleX, scaleY);\n  context.imageSmoothingEnabled = imageSmoothingEnabled;\n  context.imageSmoothingQuality = imageSmoothingQuality;\n  context.drawImage.apply(context, [image].concat(toConsumableArray(params.map(function (param) {\n    return Math.floor(normalizeDecimalNumber(param));\n  }))));\n  context.restore();\n  return canvas;\n}\n\nvar fromCharCode = String.fromCharCode;\n\n/**\n * Get string from char code in data view.\n * @param {DataView} dataView - The data view for read.\n * @param {number} start - The start index.\n * @param {number} length - The read length.\n * @returns {string} The read result.\n */\n\nfunction getStringFromCharCode(dataView, start, length) {\n  var str = '';\n  var i = void 0;\n\n  length += start;\n\n  for (i = start; i < length; i += 1) {\n    str += fromCharCode(dataView.getUint8(i));\n  }\n\n  return str;\n}\n\nvar REGEXP_DATA_URL_HEAD = /^data:.*,/;\n\n/**\n * Transform Data URL to array buffer.\n * @param {string} dataURL - The Data URL to transform.\n * @returns {ArrayBuffer} The result array buffer.\n */\nfunction dataURLToArrayBuffer(dataURL) {\n  var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n  var binary = atob(base64);\n  var arrayBuffer = new ArrayBuffer(binary.length);\n  var uint8 = new Uint8Array(arrayBuffer);\n\n  forEach(uint8, function (value, i) {\n    uint8[i] = binary.charCodeAt(i);\n  });\n\n  return arrayBuffer;\n}\n\n/**\n * Transform array buffer to Data URL.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\n * @param {string} mimeType - The mime type of the Data URL.\n * @returns {string} The result Data URL.\n */\nfunction arrayBufferToDataURL(arrayBuffer, mimeType) {\n  var uint8 = new Uint8Array(arrayBuffer);\n  var data = '';\n\n  // TypedArray.prototype.forEach is not supported in some browsers as IE.\n  if (isFunction(uint8.forEach)) {\n    // Use native `forEach` method first for better performance\n    uint8.forEach(function (value) {\n      data += fromCharCode(value);\n    });\n  } else {\n    forEach(uint8, function (value) {\n      data += fromCharCode(value);\n    });\n  }\n\n  return 'data:' + mimeType + ';base64,' + btoa(data);\n}\n\n/**\n * Get orientation value from given array buffer.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\n * @returns {number} The read orientation value.\n */\nfunction getOrientation(arrayBuffer) {\n  var dataView = new DataView(arrayBuffer);\n  var orientation = void 0;\n  var littleEndian = void 0;\n  var app1Start = void 0;\n  var ifdStart = void 0;\n\n  // Only handle JPEG image (start by 0xFFD8)\n  if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n    var length = dataView.byteLength;\n    var offset = 2;\n\n    while (offset < length) {\n      if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n        app1Start = offset;\n        break;\n      }\n\n      offset += 1;\n    }\n  }\n\n  if (app1Start) {\n    var exifIDCode = app1Start + 4;\n    var tiffOffset = app1Start + 10;\n\n    if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n      var endianness = dataView.getUint16(tiffOffset);\n\n      littleEndian = endianness === 0x4949;\n\n      if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n            var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n\n            if (firstIFDOffset >= 0x00000008) {\n              ifdStart = tiffOffset + firstIFDOffset;\n            }\n          }\n        }\n    }\n  }\n\n  if (ifdStart) {\n    var _length = dataView.getUint16(ifdStart, littleEndian);\n    var _offset = void 0;\n    var i = void 0;\n\n    for (i = 0; i < _length; i += 1) {\n      _offset = ifdStart + i * 12 + 2;\n\n      if (dataView.getUint16(_offset, littleEndian) === 0x0112 /* Orientation */) {\n          // 8 is the offset of the current tag's value\n          _offset += 8;\n\n          // Get the original orientation value\n          orientation = dataView.getUint16(_offset, littleEndian);\n\n          // Override the orientation with its default value\n          dataView.setUint16(_offset, 1, littleEndian);\n          break;\n        }\n    }\n  }\n\n  return orientation;\n}\n\n/**\n * Parse Exif Orientation value.\n * @param {number} orientation - The orientation to parse.\n * @returns {Object} The parsed result.\n */\nfunction parseOrientation(orientation) {\n  var rotate = 0;\n  var scaleX = 1;\n  var scaleY = 1;\n\n  switch (orientation) {\n    // Flip horizontal\n    case 2:\n      scaleX = -1;\n      break;\n\n    // Rotate left 180°\n    case 3:\n      rotate = -180;\n      break;\n\n    // Flip vertical\n    case 4:\n      scaleY = -1;\n      break;\n\n    // Flip vertical and rotate right 90°\n    case 5:\n      rotate = 90;\n      scaleY = -1;\n      break;\n\n    // Rotate right 90°\n    case 6:\n      rotate = 90;\n      break;\n\n    // Flip horizontal and rotate right 90°\n    case 7:\n      rotate = 90;\n      scaleX = -1;\n      break;\n\n    // Rotate left 90°\n    case 8:\n      rotate = -90;\n      break;\n\n    default:\n  }\n\n  return {\n    rotate: rotate,\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\n\nvar render = {\n  render: function render() {\n    this.initContainer();\n    this.initCanvas();\n    this.initCropBox();\n    this.renderCanvas();\n\n    if (this.cropped) {\n      this.renderCropBox();\n    }\n  },\n  initContainer: function initContainer() {\n    var element = this.element,\n        options = this.options,\n        container = this.container,\n        cropper = this.cropper;\n\n\n    addClass(cropper, CLASS_HIDDEN);\n    removeClass(element, CLASS_HIDDEN);\n\n    var containerData = {\n      width: Math.max(container.offsetWidth, Number(options.minContainerWidth) || 200),\n      height: Math.max(container.offsetHeight, Number(options.minContainerHeight) || 100)\n    };\n\n    this.containerData = containerData;\n\n    setStyle(cropper, {\n      width: containerData.width,\n      height: containerData.height\n    });\n\n    addClass(element, CLASS_HIDDEN);\n    removeClass(cropper, CLASS_HIDDEN);\n  },\n\n\n  // Canvas (image wrapper)\n  initCanvas: function initCanvas() {\n    var containerData = this.containerData,\n        imageData = this.imageData;\n    var viewMode = this.options.viewMode;\n\n    var rotated = Math.abs(imageData.rotate) % 180 === 90;\n    var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;\n    var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;\n    var aspectRatio = naturalWidth / naturalHeight;\n    var canvasWidth = containerData.width;\n    var canvasHeight = containerData.height;\n\n    if (containerData.height * aspectRatio > containerData.width) {\n      if (viewMode === 3) {\n        canvasWidth = containerData.height * aspectRatio;\n      } else {\n        canvasHeight = containerData.width / aspectRatio;\n      }\n    } else if (viewMode === 3) {\n      canvasHeight = containerData.width / aspectRatio;\n    } else {\n      canvasWidth = containerData.height * aspectRatio;\n    }\n\n    var canvasData = {\n      aspectRatio: aspectRatio,\n      naturalWidth: naturalWidth,\n      naturalHeight: naturalHeight,\n      width: canvasWidth,\n      height: canvasHeight\n    };\n\n    canvasData.left = (containerData.width - canvasWidth) / 2;\n    canvasData.top = (containerData.height - canvasHeight) / 2;\n    canvasData.oldLeft = canvasData.left;\n    canvasData.oldTop = canvasData.top;\n\n    this.canvasData = canvasData;\n    this.limited = viewMode === 1 || viewMode === 2;\n    this.limitCanvas(true, true);\n    this.initialImageData = assign({}, imageData);\n    this.initialCanvasData = assign({}, canvasData);\n  },\n  limitCanvas: function limitCanvas(sizeLimited, positionLimited) {\n    var options = this.options,\n        containerData = this.containerData,\n        canvasData = this.canvasData,\n        cropBoxData = this.cropBoxData;\n    var viewMode = options.viewMode;\n    var aspectRatio = canvasData.aspectRatio;\n\n    var cropped = this.cropped && cropBoxData;\n\n    if (sizeLimited) {\n      var minCanvasWidth = Number(options.minCanvasWidth) || 0;\n      var minCanvasHeight = Number(options.minCanvasHeight) || 0;\n\n      if (viewMode > 1) {\n        minCanvasWidth = Math.max(minCanvasWidth, containerData.width);\n        minCanvasHeight = Math.max(minCanvasHeight, containerData.height);\n\n        if (viewMode === 3) {\n          if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n            minCanvasWidth = minCanvasHeight * aspectRatio;\n          } else {\n            minCanvasHeight = minCanvasWidth / aspectRatio;\n          }\n        }\n      } else if (viewMode > 0) {\n        if (minCanvasWidth) {\n          minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);\n        } else if (minCanvasHeight) {\n          minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);\n        } else if (cropped) {\n          minCanvasWidth = cropBoxData.width;\n          minCanvasHeight = cropBoxData.height;\n\n          if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n            minCanvasWidth = minCanvasHeight * aspectRatio;\n          } else {\n            minCanvasHeight = minCanvasWidth / aspectRatio;\n          }\n        }\n      }\n\n      var _getAdjustedSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: minCanvasWidth,\n        height: minCanvasHeight\n      });\n\n      minCanvasWidth = _getAdjustedSizes.width;\n      minCanvasHeight = _getAdjustedSizes.height;\n\n\n      canvasData.minWidth = minCanvasWidth;\n      canvasData.minHeight = minCanvasHeight;\n      canvasData.maxWidth = Infinity;\n      canvasData.maxHeight = Infinity;\n    }\n\n    if (positionLimited) {\n      if (viewMode > (cropped ? 0 : 1)) {\n        var newCanvasLeft = containerData.width - canvasData.width;\n        var newCanvasTop = containerData.height - canvasData.height;\n\n        canvasData.minLeft = Math.min(0, newCanvasLeft);\n        canvasData.minTop = Math.min(0, newCanvasTop);\n        canvasData.maxLeft = Math.max(0, newCanvasLeft);\n        canvasData.maxTop = Math.max(0, newCanvasTop);\n\n        if (cropped && this.limited) {\n          canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));\n          canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));\n          canvasData.maxLeft = cropBoxData.left;\n          canvasData.maxTop = cropBoxData.top;\n\n          if (viewMode === 2) {\n            if (canvasData.width >= containerData.width) {\n              canvasData.minLeft = Math.min(0, newCanvasLeft);\n              canvasData.maxLeft = Math.max(0, newCanvasLeft);\n            }\n\n            if (canvasData.height >= containerData.height) {\n              canvasData.minTop = Math.min(0, newCanvasTop);\n              canvasData.maxTop = Math.max(0, newCanvasTop);\n            }\n          }\n        }\n      } else {\n        canvasData.minLeft = -canvasData.width;\n        canvasData.minTop = -canvasData.height;\n        canvasData.maxLeft = containerData.width;\n        canvasData.maxTop = containerData.height;\n      }\n    }\n  },\n  renderCanvas: function renderCanvas(changed, transformed) {\n    var canvasData = this.canvasData,\n        imageData = this.imageData;\n\n\n    if (transformed) {\n      var _getRotatedSizes = getRotatedSizes({\n        width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),\n        height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),\n        degree: imageData.rotate || 0\n      }),\n          naturalWidth = _getRotatedSizes.width,\n          naturalHeight = _getRotatedSizes.height;\n\n      var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);\n      var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);\n\n      canvasData.left -= (width - canvasData.width) / 2;\n      canvasData.top -= (height - canvasData.height) / 2;\n      canvasData.width = width;\n      canvasData.height = height;\n      canvasData.aspectRatio = naturalWidth / naturalHeight;\n      canvasData.naturalWidth = naturalWidth;\n      canvasData.naturalHeight = naturalHeight;\n      this.limitCanvas(true, false);\n    }\n\n    if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {\n      canvasData.left = canvasData.oldLeft;\n    }\n\n    if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {\n      canvasData.top = canvasData.oldTop;\n    }\n\n    canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);\n    canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);\n\n    this.limitCanvas(false, true);\n\n    canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);\n    canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);\n    canvasData.oldLeft = canvasData.left;\n    canvasData.oldTop = canvasData.top;\n\n    setStyle(this.canvas, assign({\n      width: canvasData.width,\n      height: canvasData.height\n    }, getTransforms({\n      translateX: canvasData.left,\n      translateY: canvasData.top\n    })));\n\n    this.renderImage(changed);\n\n    if (this.cropped && this.limited) {\n      this.limitCropBox(true, true);\n    }\n  },\n  renderImage: function renderImage(changed) {\n    var canvasData = this.canvasData,\n        imageData = this.imageData;\n\n    var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);\n    var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);\n\n    assign(imageData, {\n      width: width,\n      height: height,\n      left: (canvasData.width - width) / 2,\n      top: (canvasData.height - height) / 2\n    });\n    setStyle(this.image, assign({\n      width: imageData.width,\n      height: imageData.height\n    }, getTransforms(assign({\n      translateX: imageData.left,\n      translateY: imageData.top\n    }, imageData))));\n\n    if (changed) {\n      this.output();\n    }\n  },\n  initCropBox: function initCropBox() {\n    var options = this.options,\n        canvasData = this.canvasData;\n\n    var aspectRatio = options.aspectRatio || options.initialAspectRatio;\n    var autoCropArea = Number(options.autoCropArea) || 0.8;\n    var cropBoxData = {\n      width: canvasData.width,\n      height: canvasData.height\n    };\n\n    if (aspectRatio) {\n      if (canvasData.height * aspectRatio > canvasData.width) {\n        cropBoxData.height = cropBoxData.width / aspectRatio;\n      } else {\n        cropBoxData.width = cropBoxData.height * aspectRatio;\n      }\n    }\n\n    this.cropBoxData = cropBoxData;\n    this.limitCropBox(true, true);\n\n    // Initialize auto crop area\n    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);\n\n    // The width/height of auto crop area must large than \"minWidth/Height\"\n    cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);\n    cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);\n    cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;\n    cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;\n    cropBoxData.oldLeft = cropBoxData.left;\n    cropBoxData.oldTop = cropBoxData.top;\n\n    this.initialCropBoxData = assign({}, cropBoxData);\n  },\n  limitCropBox: function limitCropBox(sizeLimited, positionLimited) {\n    var options = this.options,\n        containerData = this.containerData,\n        canvasData = this.canvasData,\n        cropBoxData = this.cropBoxData,\n        limited = this.limited;\n    var aspectRatio = options.aspectRatio;\n\n\n    if (sizeLimited) {\n      var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;\n      var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;\n      var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;\n      var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height;\n\n      // The min/maxCropBoxWidth/Height must be less than container's width/height\n      minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);\n      minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);\n\n      if (aspectRatio) {\n        if (minCropBoxWidth && minCropBoxHeight) {\n          if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n        } else if (minCropBoxWidth) {\n          minCropBoxHeight = minCropBoxWidth / aspectRatio;\n        } else if (minCropBoxHeight) {\n          minCropBoxWidth = minCropBoxHeight * aspectRatio;\n        }\n\n        if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n          maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n        } else {\n          maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n        }\n      }\n\n      // The minWidth/Height must be less than maxWidth/Height\n      cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);\n      cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);\n      cropBoxData.maxWidth = maxCropBoxWidth;\n      cropBoxData.maxHeight = maxCropBoxHeight;\n    }\n\n    if (positionLimited) {\n      if (limited) {\n        cropBoxData.minLeft = Math.max(0, canvasData.left);\n        cropBoxData.minTop = Math.max(0, canvasData.top);\n        cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;\n        cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;\n      } else {\n        cropBoxData.minLeft = 0;\n        cropBoxData.minTop = 0;\n        cropBoxData.maxLeft = containerData.width - cropBoxData.width;\n        cropBoxData.maxTop = containerData.height - cropBoxData.height;\n      }\n    }\n  },\n  renderCropBox: function renderCropBox() {\n    var options = this.options,\n        containerData = this.containerData,\n        cropBoxData = this.cropBoxData;\n\n\n    if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {\n      cropBoxData.left = cropBoxData.oldLeft;\n    }\n\n    if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {\n      cropBoxData.top = cropBoxData.oldTop;\n    }\n\n    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);\n\n    this.limitCropBox(false, true);\n\n    cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);\n    cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);\n    cropBoxData.oldLeft = cropBoxData.left;\n    cropBoxData.oldTop = cropBoxData.top;\n\n    if (options.movable && options.cropBoxMovable) {\n      // Turn to move the canvas when the crop box is equal to the container\n      setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);\n    }\n\n    setStyle(this.cropBox, assign({\n      width: cropBoxData.width,\n      height: cropBoxData.height\n    }, getTransforms({\n      translateX: cropBoxData.left,\n      translateY: cropBoxData.top\n    })));\n\n    if (this.cropped && this.limited) {\n      this.limitCanvas(true, true);\n    }\n\n    if (!this.disabled) {\n      this.output();\n    }\n  },\n  output: function output() {\n    this.preview();\n    dispatchEvent(this.element, EVENT_CROP, this.getData());\n  }\n};\n\nvar preview = {\n  initPreview: function initPreview() {\n    var crossOrigin = this.crossOrigin;\n    var preview = this.options.preview;\n\n    var url = crossOrigin ? this.crossOriginUrl : this.url;\n    var image = document.createElement('img');\n\n    if (crossOrigin) {\n      image.crossOrigin = crossOrigin;\n    }\n\n    image.src = url;\n    this.viewBox.appendChild(image);\n    this.viewBoxImage = image;\n\n    if (!preview) {\n      return;\n    }\n\n    var previews = preview;\n\n    if (typeof preview === 'string') {\n      previews = this.element.ownerDocument.querySelectorAll(preview);\n    } else if (preview.querySelector) {\n      previews = [preview];\n    }\n\n    this.previews = previews;\n\n    forEach(previews, function (el) {\n      var img = document.createElement('img');\n\n      // Save the original size for recover\n      setData(el, DATA_PREVIEW, {\n        width: el.offsetWidth,\n        height: el.offsetHeight,\n        html: el.innerHTML\n      });\n\n      if (crossOrigin) {\n        img.crossOrigin = crossOrigin;\n      }\n\n      img.src = url;\n\n      /**\n       * Override img element styles\n       * Add `display:block` to avoid margin top issue\n       * Add `height:auto` to override `height` attribute on IE8\n       * (Occur only when margin-top <= -height)\n       */\n      img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;\"';\n\n      el.innerHTML = '';\n      el.appendChild(img);\n    });\n  },\n  resetPreview: function resetPreview() {\n    forEach(this.previews, function (element) {\n      var data = getData(element, DATA_PREVIEW);\n\n      setStyle(element, {\n        width: data.width,\n        height: data.height\n      });\n\n      element.innerHTML = data.html;\n      removeData(element, DATA_PREVIEW);\n    });\n  },\n  preview: function preview() {\n    var imageData = this.imageData,\n        canvasData = this.canvasData,\n        cropBoxData = this.cropBoxData;\n    var cropBoxWidth = cropBoxData.width,\n        cropBoxHeight = cropBoxData.height;\n    var width = imageData.width,\n        height = imageData.height;\n\n    var left = cropBoxData.left - canvasData.left - imageData.left;\n    var top = cropBoxData.top - canvasData.top - imageData.top;\n\n    if (!this.cropped || this.disabled) {\n      return;\n    }\n\n    setStyle(this.viewBoxImage, assign({\n      width: width,\n      height: height\n    }, getTransforms(assign({\n      translateX: -left,\n      translateY: -top\n    }, imageData))));\n\n    forEach(this.previews, function (element) {\n      var data = getData(element, DATA_PREVIEW);\n      var originalWidth = data.width;\n      var originalHeight = data.height;\n      var newWidth = originalWidth;\n      var newHeight = originalHeight;\n      var ratio = 1;\n\n      if (cropBoxWidth) {\n        ratio = originalWidth / cropBoxWidth;\n        newHeight = cropBoxHeight * ratio;\n      }\n\n      if (cropBoxHeight && newHeight > originalHeight) {\n        ratio = originalHeight / cropBoxHeight;\n        newWidth = cropBoxWidth * ratio;\n        newHeight = originalHeight;\n      }\n\n      setStyle(element, {\n        width: newWidth,\n        height: newHeight\n      });\n\n      setStyle(element.getElementsByTagName('img')[0], assign({\n        width: width * ratio,\n        height: height * ratio\n      }, getTransforms(assign({\n        translateX: -left * ratio,\n        translateY: -top * ratio\n      }, imageData))));\n    });\n  }\n};\n\nvar events = {\n  bind: function bind() {\n    var element = this.element,\n        options = this.options,\n        cropper = this.cropper;\n\n\n    if (isFunction(options.cropstart)) {\n      addListener(element, EVENT_CROP_START, options.cropstart);\n    }\n\n    if (isFunction(options.cropmove)) {\n      addListener(element, EVENT_CROP_MOVE, options.cropmove);\n    }\n\n    if (isFunction(options.cropend)) {\n      addListener(element, EVENT_CROP_END, options.cropend);\n    }\n\n    if (isFunction(options.crop)) {\n      addListener(element, EVENT_CROP, options.crop);\n    }\n\n    if (isFunction(options.zoom)) {\n      addListener(element, EVENT_ZOOM, options.zoom);\n    }\n\n    addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));\n\n    if (options.zoomable && options.zoomOnWheel) {\n      addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this));\n    }\n\n    if (options.toggleDragModeOnDblclick) {\n      addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));\n    }\n\n    addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));\n    addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));\n\n    if (options.responsive) {\n      addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));\n    }\n  },\n  unbind: function unbind() {\n    var element = this.element,\n        options = this.options,\n        cropper = this.cropper;\n\n\n    if (isFunction(options.cropstart)) {\n      removeListener(element, EVENT_CROP_START, options.cropstart);\n    }\n\n    if (isFunction(options.cropmove)) {\n      removeListener(element, EVENT_CROP_MOVE, options.cropmove);\n    }\n\n    if (isFunction(options.cropend)) {\n      removeListener(element, EVENT_CROP_END, options.cropend);\n    }\n\n    if (isFunction(options.crop)) {\n      removeListener(element, EVENT_CROP, options.crop);\n    }\n\n    if (isFunction(options.zoom)) {\n      removeListener(element, EVENT_ZOOM, options.zoom);\n    }\n\n    removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);\n\n    if (options.zoomable && options.zoomOnWheel) {\n      removeListener(cropper, EVENT_WHEEL, this.onWheel);\n    }\n\n    if (options.toggleDragModeOnDblclick) {\n      removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);\n    }\n\n    removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);\n    removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);\n\n    if (options.responsive) {\n      removeListener(window, EVENT_RESIZE, this.onResize);\n    }\n  }\n};\n\nvar handlers = {\n  resize: function resize() {\n    var options = this.options,\n        container = this.container,\n        containerData = this.containerData;\n\n    var minContainerWidth = Number(options.minContainerWidth) || 200;\n    var minContainerHeight = Number(options.minContainerHeight) || 100;\n\n    if (this.disabled || containerData.width <= minContainerWidth || containerData.height <= minContainerHeight) {\n      return;\n    }\n\n    var ratio = container.offsetWidth / containerData.width;\n\n    // Resize when width changed or height changed\n    if (ratio !== 1 || container.offsetHeight !== containerData.height) {\n      var canvasData = void 0;\n      var cropBoxData = void 0;\n\n      if (options.restore) {\n        canvasData = this.getCanvasData();\n        cropBoxData = this.getCropBoxData();\n      }\n\n      this.render();\n\n      if (options.restore) {\n        this.setCanvasData(forEach(canvasData, function (n, i) {\n          canvasData[i] = n * ratio;\n        }));\n        this.setCropBoxData(forEach(cropBoxData, function (n, i) {\n          cropBoxData[i] = n * ratio;\n        }));\n      }\n    }\n  },\n  dblclick: function dblclick() {\n    if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {\n      return;\n    }\n\n    this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);\n  },\n  wheel: function wheel(e) {\n    var _this = this;\n\n    var ratio = Number(this.options.wheelZoomRatio) || 0.1;\n    var delta = 1;\n\n    if (this.disabled) {\n      return;\n    }\n\n    e.preventDefault();\n\n    // Limit wheel speed to prevent zoom too fast (#21)\n    if (this.wheeling) {\n      return;\n    }\n\n    this.wheeling = true;\n\n    setTimeout(function () {\n      _this.wheeling = false;\n    }, 50);\n\n    if (e.deltaY) {\n      delta = e.deltaY > 0 ? 1 : -1;\n    } else if (e.wheelDelta) {\n      delta = -e.wheelDelta / 120;\n    } else if (e.detail) {\n      delta = e.detail > 0 ? 1 : -1;\n    }\n\n    this.zoom(-delta * ratio, e);\n  },\n  cropStart: function cropStart(e) {\n    if (this.disabled) {\n      return;\n    }\n\n    var options = this.options,\n        pointers = this.pointers;\n\n    var action = void 0;\n\n    if (e.changedTouches) {\n      // Handle touch event\n      forEach(e.changedTouches, function (touch) {\n        pointers[touch.identifier] = getPointer(touch);\n      });\n    } else {\n      // Handle mouse event and pointer event\n      pointers[e.pointerId || 0] = getPointer(e);\n    }\n\n    if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {\n      action = ACTION_ZOOM;\n    } else {\n      action = getData(e.target, DATA_ACTION);\n    }\n\n    if (!REGEXP_ACTIONS.test(action)) {\n      return;\n    }\n\n    if (dispatchEvent(this.element, EVENT_CROP_START, {\n      originalEvent: e,\n      action: action\n    }) === false) {\n      return;\n    }\n\n    // This line is required for preventing page zooming in iOS browsers\n    e.preventDefault();\n\n    this.action = action;\n    this.cropping = false;\n\n    if (action === ACTION_CROP) {\n      this.cropping = true;\n      addClass(this.dragBox, CLASS_MODAL);\n    }\n  },\n  cropMove: function cropMove(e) {\n    var action = this.action;\n\n\n    if (this.disabled || !action) {\n      return;\n    }\n\n    var pointers = this.pointers;\n\n\n    e.preventDefault();\n\n    if (dispatchEvent(this.element, EVENT_CROP_MOVE, {\n      originalEvent: e,\n      action: action\n    }) === false) {\n      return;\n    }\n\n    if (e.changedTouches) {\n      forEach(e.changedTouches, function (touch) {\n        assign(pointers[touch.identifier], getPointer(touch, true));\n      });\n    } else {\n      assign(pointers[e.pointerId || 0], getPointer(e, true));\n    }\n\n    this.change(e);\n  },\n  cropEnd: function cropEnd(e) {\n    if (this.disabled) {\n      return;\n    }\n\n    var action = this.action,\n        pointers = this.pointers;\n\n\n    if (e.changedTouches) {\n      forEach(e.changedTouches, function (touch) {\n        delete pointers[touch.identifier];\n      });\n    } else {\n      delete pointers[e.pointerId || 0];\n    }\n\n    if (!action) {\n      return;\n    }\n\n    e.preventDefault();\n\n    if (!Object.keys(pointers).length) {\n      this.action = '';\n    }\n\n    if (this.cropping) {\n      this.cropping = false;\n      toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);\n    }\n\n    dispatchEvent(this.element, EVENT_CROP_END, {\n      originalEvent: e,\n      action: action\n    });\n  }\n};\n\nvar change = {\n  change: function change(e) {\n    var options = this.options,\n        canvasData = this.canvasData,\n        containerData = this.containerData,\n        cropBoxData = this.cropBoxData,\n        pointers = this.pointers;\n    var action = this.action;\n    var aspectRatio = options.aspectRatio;\n    var left = cropBoxData.left,\n        top = cropBoxData.top,\n        width = cropBoxData.width,\n        height = cropBoxData.height;\n\n    var right = left + width;\n    var bottom = top + height;\n    var minLeft = 0;\n    var minTop = 0;\n    var maxWidth = containerData.width;\n    var maxHeight = containerData.height;\n    var renderable = true;\n    var offset = void 0;\n\n    // Locking aspect ratio in \"free mode\" by holding shift key\n    if (!aspectRatio && e.shiftKey) {\n      aspectRatio = width && height ? width / height : 1;\n    }\n\n    if (this.limited) {\n      minLeft = cropBoxData.minLeft;\n      minTop = cropBoxData.minTop;\n\n      maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);\n      maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);\n    }\n\n    var pointer = pointers[Object.keys(pointers)[0]];\n    var range = {\n      x: pointer.endX - pointer.startX,\n      y: pointer.endY - pointer.startY\n    };\n    var check = function check(side) {\n      switch (side) {\n        case ACTION_EAST:\n          if (right + range.x > maxWidth) {\n            range.x = maxWidth - right;\n          }\n\n          break;\n\n        case ACTION_WEST:\n          if (left + range.x < minLeft) {\n            range.x = minLeft - left;\n          }\n\n          break;\n\n        case ACTION_NORTH:\n          if (top + range.y < minTop) {\n            range.y = minTop - top;\n          }\n\n          break;\n\n        case ACTION_SOUTH:\n          if (bottom + range.y > maxHeight) {\n            range.y = maxHeight - bottom;\n          }\n\n          break;\n\n        default:\n      }\n    };\n\n    switch (action) {\n      // Move crop box\n      case ACTION_ALL:\n        left += range.x;\n        top += range.y;\n        break;\n\n      // Resize crop box\n      case ACTION_EAST:\n        if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n          renderable = false;\n          break;\n        }\n\n        check(ACTION_EAST);\n        width += range.x;\n\n        if (width < 0) {\n          action = ACTION_WEST;\n          width = -width;\n          left -= width;\n        }\n\n        if (aspectRatio) {\n          height = width / aspectRatio;\n          top += (cropBoxData.height - height) / 2;\n        }\n\n        break;\n\n      case ACTION_NORTH:\n        if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n          renderable = false;\n          break;\n        }\n\n        check(ACTION_NORTH);\n        height -= range.y;\n        top += range.y;\n\n        if (height < 0) {\n          action = ACTION_SOUTH;\n          height = -height;\n          top -= height;\n        }\n\n        if (aspectRatio) {\n          width = height * aspectRatio;\n          left += (cropBoxData.width - width) / 2;\n        }\n\n        break;\n\n      case ACTION_WEST:\n        if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n          renderable = false;\n          break;\n        }\n\n        check(ACTION_WEST);\n        width -= range.x;\n        left += range.x;\n\n        if (width < 0) {\n          action = ACTION_EAST;\n          width = -width;\n          left -= width;\n        }\n\n        if (aspectRatio) {\n          height = width / aspectRatio;\n          top += (cropBoxData.height - height) / 2;\n        }\n\n        break;\n\n      case ACTION_SOUTH:\n        if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n          renderable = false;\n          break;\n        }\n\n        check(ACTION_SOUTH);\n        height += range.y;\n\n        if (height < 0) {\n          action = ACTION_NORTH;\n          height = -height;\n          top -= height;\n        }\n\n        if (aspectRatio) {\n          width = height * aspectRatio;\n          left += (cropBoxData.width - width) / 2;\n        }\n\n        break;\n\n      case ACTION_NORTH_EAST:\n        if (aspectRatio) {\n          if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_NORTH);\n          height -= range.y;\n          top += range.y;\n          width = height * aspectRatio;\n        } else {\n          check(ACTION_NORTH);\n          check(ACTION_EAST);\n\n          if (range.x >= 0) {\n            if (right < maxWidth) {\n              width += range.x;\n            } else if (range.y <= 0 && top <= minTop) {\n              renderable = false;\n            }\n          } else {\n            width += range.x;\n          }\n\n          if (range.y <= 0) {\n            if (top > minTop) {\n              height -= range.y;\n              top += range.y;\n            }\n          } else {\n            height -= range.y;\n            top += range.y;\n          }\n        }\n\n        if (width < 0 && height < 0) {\n          action = ACTION_SOUTH_WEST;\n          height = -height;\n          width = -width;\n          top -= height;\n          left -= width;\n        } else if (width < 0) {\n          action = ACTION_NORTH_WEST;\n          width = -width;\n          left -= width;\n        } else if (height < 0) {\n          action = ACTION_SOUTH_EAST;\n          height = -height;\n          top -= height;\n        }\n\n        break;\n\n      case ACTION_NORTH_WEST:\n        if (aspectRatio) {\n          if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_NORTH);\n          height -= range.y;\n          top += range.y;\n          width = height * aspectRatio;\n          left += cropBoxData.width - width;\n        } else {\n          check(ACTION_NORTH);\n          check(ACTION_WEST);\n\n          if (range.x <= 0) {\n            if (left > minLeft) {\n              width -= range.x;\n              left += range.x;\n            } else if (range.y <= 0 && top <= minTop) {\n              renderable = false;\n            }\n          } else {\n            width -= range.x;\n            left += range.x;\n          }\n\n          if (range.y <= 0) {\n            if (top > minTop) {\n              height -= range.y;\n              top += range.y;\n            }\n          } else {\n            height -= range.y;\n            top += range.y;\n          }\n        }\n\n        if (width < 0 && height < 0) {\n          action = ACTION_SOUTH_EAST;\n          height = -height;\n          width = -width;\n          top -= height;\n          left -= width;\n        } else if (width < 0) {\n          action = ACTION_NORTH_EAST;\n          width = -width;\n          left -= width;\n        } else if (height < 0) {\n          action = ACTION_SOUTH_WEST;\n          height = -height;\n          top -= height;\n        }\n\n        break;\n\n      case ACTION_SOUTH_WEST:\n        if (aspectRatio) {\n          if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_WEST);\n          width -= range.x;\n          left += range.x;\n          height = width / aspectRatio;\n        } else {\n          check(ACTION_SOUTH);\n          check(ACTION_WEST);\n\n          if (range.x <= 0) {\n            if (left > minLeft) {\n              width -= range.x;\n              left += range.x;\n            } else if (range.y >= 0 && bottom >= maxHeight) {\n              renderable = false;\n            }\n          } else {\n            width -= range.x;\n            left += range.x;\n          }\n\n          if (range.y >= 0) {\n            if (bottom < maxHeight) {\n              height += range.y;\n            }\n          } else {\n            height += range.y;\n          }\n        }\n\n        if (width < 0 && height < 0) {\n          action = ACTION_NORTH_EAST;\n          height = -height;\n          width = -width;\n          top -= height;\n          left -= width;\n        } else if (width < 0) {\n          action = ACTION_SOUTH_EAST;\n          width = -width;\n          left -= width;\n        } else if (height < 0) {\n          action = ACTION_NORTH_WEST;\n          height = -height;\n          top -= height;\n        }\n\n        break;\n\n      case ACTION_SOUTH_EAST:\n        if (aspectRatio) {\n          if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n            renderable = false;\n            break;\n          }\n\n          check(ACTION_EAST);\n          width += range.x;\n          height = width / aspectRatio;\n        } else {\n          check(ACTION_SOUTH);\n          check(ACTION_EAST);\n\n          if (range.x >= 0) {\n            if (right < maxWidth) {\n              width += range.x;\n            } else if (range.y >= 0 && bottom >= maxHeight) {\n              renderable = false;\n            }\n          } else {\n            width += range.x;\n          }\n\n          if (range.y >= 0) {\n            if (bottom < maxHeight) {\n              height += range.y;\n            }\n          } else {\n            height += range.y;\n          }\n        }\n\n        if (width < 0 && height < 0) {\n          action = ACTION_NORTH_WEST;\n          height = -height;\n          width = -width;\n          top -= height;\n          left -= width;\n        } else if (width < 0) {\n          action = ACTION_SOUTH_WEST;\n          width = -width;\n          left -= width;\n        } else if (height < 0) {\n          action = ACTION_NORTH_EAST;\n          height = -height;\n          top -= height;\n        }\n\n        break;\n\n      // Move canvas\n      case ACTION_MOVE:\n        this.move(range.x, range.y);\n        renderable = false;\n        break;\n\n      // Zoom canvas\n      case ACTION_ZOOM:\n        this.zoom(getMaxZoomRatio(pointers), e);\n        renderable = false;\n        break;\n\n      // Create crop box\n      case ACTION_CROP:\n        if (!range.x || !range.y) {\n          renderable = false;\n          break;\n        }\n\n        offset = getOffset(this.cropper);\n        left = pointer.startX - offset.left;\n        top = pointer.startY - offset.top;\n        width = cropBoxData.minWidth;\n        height = cropBoxData.minHeight;\n\n        if (range.x > 0) {\n          action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n        } else if (range.x < 0) {\n          left -= width;\n          action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n        }\n\n        if (range.y < 0) {\n          top -= height;\n        }\n\n        // Show the crop box if is hidden\n        if (!this.cropped) {\n          removeClass(this.cropBox, CLASS_HIDDEN);\n          this.cropped = true;\n\n          if (this.limited) {\n            this.limitCropBox(true, true);\n          }\n        }\n\n        break;\n\n      default:\n    }\n\n    if (renderable) {\n      cropBoxData.width = width;\n      cropBoxData.height = height;\n      cropBoxData.left = left;\n      cropBoxData.top = top;\n      this.action = action;\n      this.renderCropBox();\n    }\n\n    // Override\n    forEach(pointers, function (p) {\n      p.startX = p.endX;\n      p.startY = p.endY;\n    });\n  }\n};\n\nvar methods = {\n  // Show the crop box manually\n  crop: function crop() {\n    if (this.ready && !this.cropped && !this.disabled) {\n      this.cropped = true;\n      this.limitCropBox(true, true);\n\n      if (this.options.modal) {\n        addClass(this.dragBox, CLASS_MODAL);\n      }\n\n      removeClass(this.cropBox, CLASS_HIDDEN);\n      this.setCropBoxData(this.initialCropBoxData);\n    }\n\n    return this;\n  },\n\n\n  // Reset the image and crop box to their initial states\n  reset: function reset() {\n    if (this.ready && !this.disabled) {\n      this.imageData = assign({}, this.initialImageData);\n      this.canvasData = assign({}, this.initialCanvasData);\n      this.cropBoxData = assign({}, this.initialCropBoxData);\n      this.renderCanvas();\n\n      if (this.cropped) {\n        this.renderCropBox();\n      }\n    }\n\n    return this;\n  },\n\n\n  // Clear the crop box\n  clear: function clear() {\n    if (this.cropped && !this.disabled) {\n      assign(this.cropBoxData, {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      });\n\n      this.cropped = false;\n      this.renderCropBox();\n      this.limitCanvas(true, true);\n\n      // Render canvas after crop box rendered\n      this.renderCanvas();\n      removeClass(this.dragBox, CLASS_MODAL);\n      addClass(this.cropBox, CLASS_HIDDEN);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Replace the image's src and rebuild the cropper\n   * @param {string} url - The new URL.\n   * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.\n   * @returns {Cropper} this\n   */\n  replace: function replace(url) {\n    var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!this.disabled && url) {\n      if (this.isImg) {\n        this.element.src = url;\n      }\n\n      if (hasSameSize) {\n        this.url = url;\n        this.image.src = url;\n\n        if (this.ready) {\n          this.viewBoxImage.src = url;\n\n          forEach(this.previews, function (element) {\n            element.getElementsByTagName('img')[0].src = url;\n          });\n        }\n      } else {\n        if (this.isImg) {\n          this.replaced = true;\n        }\n\n        this.options.data = null;\n        this.uncreate();\n        this.load(url);\n      }\n    }\n\n    return this;\n  },\n\n\n  // Enable (unfreeze) the cropper\n  enable: function enable() {\n    if (this.ready && this.disabled) {\n      this.disabled = false;\n      removeClass(this.cropper, CLASS_DISABLED);\n    }\n\n    return this;\n  },\n\n\n  // Disable (freeze) the cropper\n  disable: function disable() {\n    if (this.ready && !this.disabled) {\n      this.disabled = true;\n      addClass(this.cropper, CLASS_DISABLED);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Destroy the cropper and remove the instance from the image\n   * @returns {Cropper} this\n   */\n  destroy: function destroy() {\n    var element = this.element;\n\n\n    if (!getData(element, NAMESPACE)) {\n      return this;\n    }\n\n    if (this.isImg && this.replaced) {\n      element.src = this.originalUrl;\n    }\n\n    this.uncreate();\n    removeData(element, NAMESPACE);\n\n    return this;\n  },\n\n\n  /**\n   * Move the canvas with relative offsets\n   * @param {number} offsetX - The relative offset distance on the x-axis.\n   * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.\n   * @returns {Cropper} this\n   */\n  move: function move(offsetX) {\n    var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;\n    var _canvasData = this.canvasData,\n        left = _canvasData.left,\n        top = _canvasData.top;\n\n\n    return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));\n  },\n\n\n  /**\n   * Move the canvas to an absolute point\n   * @param {number} x - The x-axis coordinate.\n   * @param {number} [y=x] - The y-axis coordinate.\n   * @returns {Cropper} this\n   */\n  moveTo: function moveTo(x) {\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n    var canvasData = this.canvasData;\n\n    var changed = false;\n\n    x = Number(x);\n    y = Number(y);\n\n    if (this.ready && !this.disabled && this.options.movable) {\n      if (isNumber(x)) {\n        canvasData.left = x;\n        changed = true;\n      }\n\n      if (isNumber(y)) {\n        canvasData.top = y;\n        changed = true;\n      }\n\n      if (changed) {\n        this.renderCanvas(true);\n      }\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Zoom the canvas with a relative ratio\n   * @param {number} ratio - The target ratio.\n   * @param {Event} _originalEvent - The original event if any.\n   * @returns {Cropper} this\n   */\n  zoom: function zoom(ratio, _originalEvent) {\n    var canvasData = this.canvasData;\n\n\n    ratio = Number(ratio);\n\n    if (ratio < 0) {\n      ratio = 1 / (1 - ratio);\n    } else {\n      ratio = 1 + ratio;\n    }\n\n    return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);\n  },\n\n\n  /**\n   * Zoom the canvas to an absolute ratio\n   * @param {number} ratio - The target ratio.\n   * @param {Object} pivot - The zoom pivot point coordinate.\n   * @param {Event} _originalEvent - The original event if any.\n   * @returns {Cropper} this\n   */\n  zoomTo: function zoomTo(ratio, pivot, _originalEvent) {\n    var options = this.options,\n        canvasData = this.canvasData;\n    var width = canvasData.width,\n        height = canvasData.height,\n        naturalWidth = canvasData.naturalWidth,\n        naturalHeight = canvasData.naturalHeight;\n\n\n    ratio = Number(ratio);\n\n    if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {\n      var newWidth = naturalWidth * ratio;\n      var newHeight = naturalHeight * ratio;\n\n      if (dispatchEvent(this.element, EVENT_ZOOM, {\n        ratio: ratio,\n        oldRatio: width / naturalWidth,\n        originalEvent: _originalEvent\n      }) === false) {\n        return this;\n      }\n\n      if (_originalEvent) {\n        var pointers = this.pointers;\n\n        var offset = getOffset(this.cropper);\n        var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {\n          pageX: _originalEvent.pageX,\n          pageY: _originalEvent.pageY\n        };\n\n        // Zoom from the triggering point of the event\n        canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);\n        canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);\n      } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {\n        canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);\n        canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);\n      } else {\n        // Zoom from the center of the canvas\n        canvasData.left -= (newWidth - width) / 2;\n        canvasData.top -= (newHeight - height) / 2;\n      }\n\n      canvasData.width = newWidth;\n      canvasData.height = newHeight;\n      this.renderCanvas(true);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Rotate the canvas with a relative degree\n   * @param {number} degree - The rotate degree.\n   * @returns {Cropper} this\n   */\n  rotate: function rotate(degree) {\n    return this.rotateTo((this.imageData.rotate || 0) + Number(degree));\n  },\n\n\n  /**\n   * Rotate the canvas to an absolute degree\n   * @param {number} degree - The rotate degree.\n   * @returns {Cropper} this\n   */\n  rotateTo: function rotateTo(degree) {\n    degree = Number(degree);\n\n    if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {\n      this.imageData.rotate = degree % 360;\n      this.renderCanvas(true, true);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Scale the image on the x-axis.\n   * @param {number} scaleX - The scale ratio on the x-axis.\n   * @returns {Cropper} this\n   */\n  scaleX: function scaleX(_scaleX) {\n    var scaleY = this.imageData.scaleY;\n\n\n    return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);\n  },\n\n\n  /**\n   * Scale the image on the y-axis.\n   * @param {number} scaleY - The scale ratio on the y-axis.\n   * @returns {Cropper} this\n   */\n  scaleY: function scaleY(_scaleY) {\n    var scaleX = this.imageData.scaleX;\n\n\n    return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);\n  },\n\n\n  /**\n   * Scale the image\n   * @param {number} scaleX - The scale ratio on the x-axis.\n   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.\n   * @returns {Cropper} this\n   */\n  scale: function scale(scaleX) {\n    var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n    var imageData = this.imageData;\n\n    var transformed = false;\n\n    scaleX = Number(scaleX);\n    scaleY = Number(scaleY);\n\n    if (this.ready && !this.disabled && this.options.scalable) {\n      if (isNumber(scaleX)) {\n        imageData.scaleX = scaleX;\n        transformed = true;\n      }\n\n      if (isNumber(scaleY)) {\n        imageData.scaleY = scaleY;\n        transformed = true;\n      }\n\n      if (transformed) {\n        this.renderCanvas(true, true);\n      }\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Get the cropped area position and size data (base on the original image)\n   * @param {boolean} [rounded=false] - Indicate if round the data values or not.\n   * @returns {Object} The result cropped data.\n   */\n  getData: function getData$$1() {\n    var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var options = this.options,\n        imageData = this.imageData,\n        canvasData = this.canvasData,\n        cropBoxData = this.cropBoxData;\n\n    var data = void 0;\n\n    if (this.ready && this.cropped) {\n      data = {\n        x: cropBoxData.left - canvasData.left,\n        y: cropBoxData.top - canvasData.top,\n        width: cropBoxData.width,\n        height: cropBoxData.height\n      };\n\n      var ratio = imageData.width / imageData.naturalWidth;\n\n      forEach(data, function (n, i) {\n        data[i] = n / ratio;\n      });\n\n      if (rounded) {\n        // In case rounding off leads to extra 1px in right or bottom border\n        // we should round the top-left corner and the dimension (#343).\n        var bottom = Math.round(data.y + data.height);\n        var right = Math.round(data.x + data.width);\n\n        data.x = Math.round(data.x);\n        data.y = Math.round(data.y);\n        data.width = right - data.x;\n        data.height = bottom - data.y;\n      }\n    } else {\n      data = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    if (options.rotatable) {\n      data.rotate = imageData.rotate || 0;\n    }\n\n    if (options.scalable) {\n      data.scaleX = imageData.scaleX || 1;\n      data.scaleY = imageData.scaleY || 1;\n    }\n\n    return data;\n  },\n\n\n  /**\n   * Set the cropped area position and size with new data\n   * @param {Object} data - The new data.\n   * @returns {Cropper} this\n   */\n  setData: function setData$$1(data) {\n    var options = this.options,\n        imageData = this.imageData,\n        canvasData = this.canvasData;\n\n    var cropBoxData = {};\n\n    if (this.ready && !this.disabled && isPlainObject(data)) {\n      var transformed = false;\n\n      if (options.rotatable) {\n        if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {\n          imageData.rotate = data.rotate;\n          transformed = true;\n        }\n      }\n\n      if (options.scalable) {\n        if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {\n          imageData.scaleX = data.scaleX;\n          transformed = true;\n        }\n\n        if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {\n          imageData.scaleY = data.scaleY;\n          transformed = true;\n        }\n      }\n\n      if (transformed) {\n        this.renderCanvas(true, true);\n      }\n\n      var ratio = imageData.width / imageData.naturalWidth;\n\n      if (isNumber(data.x)) {\n        cropBoxData.left = data.x * ratio + canvasData.left;\n      }\n\n      if (isNumber(data.y)) {\n        cropBoxData.top = data.y * ratio + canvasData.top;\n      }\n\n      if (isNumber(data.width)) {\n        cropBoxData.width = data.width * ratio;\n      }\n\n      if (isNumber(data.height)) {\n        cropBoxData.height = data.height * ratio;\n      }\n\n      this.setCropBoxData(cropBoxData);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Get the container size data.\n   * @returns {Object} The result container data.\n   */\n  getContainerData: function getContainerData() {\n    return this.ready ? assign({}, this.containerData) : {};\n  },\n\n\n  /**\n   * Get the image position and size data.\n   * @returns {Object} The result image data.\n   */\n  getImageData: function getImageData() {\n    return this.sized ? assign({}, this.imageData) : {};\n  },\n\n\n  /**\n   * Get the canvas position and size data.\n   * @returns {Object} The result canvas data.\n   */\n  getCanvasData: function getCanvasData() {\n    var canvasData = this.canvasData;\n\n    var data = {};\n\n    if (this.ready) {\n      forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {\n        data[n] = canvasData[n];\n      });\n    }\n\n    return data;\n  },\n\n\n  /**\n   * Set the canvas position and size with new data.\n   * @param {Object} data - The new canvas data.\n   * @returns {Cropper} this\n   */\n  setCanvasData: function setCanvasData(data) {\n    var canvasData = this.canvasData;\n    var aspectRatio = canvasData.aspectRatio;\n\n\n    if (this.ready && !this.disabled && isPlainObject(data)) {\n      if (isNumber(data.left)) {\n        canvasData.left = data.left;\n      }\n\n      if (isNumber(data.top)) {\n        canvasData.top = data.top;\n      }\n\n      if (isNumber(data.width)) {\n        canvasData.width = data.width;\n        canvasData.height = data.width / aspectRatio;\n      } else if (isNumber(data.height)) {\n        canvasData.height = data.height;\n        canvasData.width = data.height * aspectRatio;\n      }\n\n      this.renderCanvas(true);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Get the crop box position and size data.\n   * @returns {Object} The result crop box data.\n   */\n  getCropBoxData: function getCropBoxData() {\n    var cropBoxData = this.cropBoxData;\n\n    var data = void 0;\n\n    if (this.ready && this.cropped) {\n      data = {\n        left: cropBoxData.left,\n        top: cropBoxData.top,\n        width: cropBoxData.width,\n        height: cropBoxData.height\n      };\n    }\n\n    return data || {};\n  },\n\n\n  /**\n   * Set the crop box position and size with new data.\n   * @param {Object} data - The new crop box data.\n   * @returns {Cropper} this\n   */\n  setCropBoxData: function setCropBoxData(data) {\n    var cropBoxData = this.cropBoxData;\n    var aspectRatio = this.options.aspectRatio;\n\n    var widthChanged = void 0;\n    var heightChanged = void 0;\n\n    if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {\n      if (isNumber(data.left)) {\n        cropBoxData.left = data.left;\n      }\n\n      if (isNumber(data.top)) {\n        cropBoxData.top = data.top;\n      }\n\n      if (isNumber(data.width) && data.width !== cropBoxData.width) {\n        widthChanged = true;\n        cropBoxData.width = data.width;\n      }\n\n      if (isNumber(data.height) && data.height !== cropBoxData.height) {\n        heightChanged = true;\n        cropBoxData.height = data.height;\n      }\n\n      if (aspectRatio) {\n        if (widthChanged) {\n          cropBoxData.height = cropBoxData.width / aspectRatio;\n        } else if (heightChanged) {\n          cropBoxData.width = cropBoxData.height * aspectRatio;\n        }\n      }\n\n      this.renderCropBox();\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Get a canvas drawn the cropped image.\n   * @param {Object} [options={}] - The config options.\n   * @returns {HTMLCanvasElement} - The result canvas.\n   */\n  getCroppedCanvas: function getCroppedCanvas() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.ready || !window.HTMLCanvasElement) {\n      return null;\n    }\n\n    var canvasData = this.canvasData;\n\n    var source = getSourceCanvas(this.image, this.imageData, canvasData, options);\n\n    // Returns the source canvas if it is not cropped.\n    if (!this.cropped) {\n      return source;\n    }\n\n    var _getData = this.getData(),\n        initialX = _getData.x,\n        initialY = _getData.y,\n        initialWidth = _getData.width,\n        initialHeight = _getData.height;\n\n    var ratio = source.width / Math.floor(canvasData.naturalWidth);\n\n    if (ratio !== 1) {\n      initialX *= ratio;\n      initialY *= ratio;\n      initialWidth *= ratio;\n      initialHeight *= ratio;\n    }\n\n    var aspectRatio = initialWidth / initialHeight;\n    var maxSizes = getAdjustedSizes({\n      aspectRatio: aspectRatio,\n      width: options.maxWidth || Infinity,\n      height: options.maxHeight || Infinity\n    });\n    var minSizes = getAdjustedSizes({\n      aspectRatio: aspectRatio,\n      width: options.minWidth || 0,\n      height: options.minHeight || 0\n    }, 'cover');\n\n    var _getAdjustedSizes = getAdjustedSizes({\n      aspectRatio: aspectRatio,\n      width: options.width || (ratio !== 1 ? source.width : initialWidth),\n      height: options.height || (ratio !== 1 ? source.height : initialHeight)\n    }),\n        width = _getAdjustedSizes.width,\n        height = _getAdjustedSizes.height;\n\n    width = Math.min(maxSizes.width, Math.max(minSizes.width, width));\n    height = Math.min(maxSizes.height, Math.max(minSizes.height, height));\n\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    canvas.width = normalizeDecimalNumber(width);\n    canvas.height = normalizeDecimalNumber(height);\n\n    context.fillStyle = options.fillColor || 'transparent';\n    context.fillRect(0, 0, width, height);\n\n    var _options$imageSmoothi = options.imageSmoothingEnabled,\n        imageSmoothingEnabled = _options$imageSmoothi === undefined ? true : _options$imageSmoothi,\n        imageSmoothingQuality = options.imageSmoothingQuality;\n\n\n    context.imageSmoothingEnabled = imageSmoothingEnabled;\n\n    if (imageSmoothingQuality) {\n      context.imageSmoothingQuality = imageSmoothingQuality;\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n    var sourceWidth = source.width;\n    var sourceHeight = source.height;\n\n    // Source canvas parameters\n    var srcX = initialX;\n    var srcY = initialY;\n    var srcWidth = void 0;\n    var srcHeight = void 0;\n\n    // Destination canvas parameters\n    var dstX = void 0;\n    var dstY = void 0;\n    var dstWidth = void 0;\n    var dstHeight = void 0;\n\n    if (srcX <= -initialWidth || srcX > sourceWidth) {\n      srcX = 0;\n      srcWidth = 0;\n      dstX = 0;\n      dstWidth = 0;\n    } else if (srcX <= 0) {\n      dstX = -srcX;\n      srcX = 0;\n      srcWidth = Math.min(sourceWidth, initialWidth + srcX);\n      dstWidth = srcWidth;\n    } else if (srcX <= sourceWidth) {\n      dstX = 0;\n      srcWidth = Math.min(initialWidth, sourceWidth - srcX);\n      dstWidth = srcWidth;\n    }\n\n    if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {\n      srcY = 0;\n      srcHeight = 0;\n      dstY = 0;\n      dstHeight = 0;\n    } else if (srcY <= 0) {\n      dstY = -srcY;\n      srcY = 0;\n      srcHeight = Math.min(sourceHeight, initialHeight + srcY);\n      dstHeight = srcHeight;\n    } else if (srcY <= sourceHeight) {\n      dstY = 0;\n      srcHeight = Math.min(initialHeight, sourceHeight - srcY);\n      dstHeight = srcHeight;\n    }\n\n    var params = [srcX, srcY, srcWidth, srcHeight];\n\n    // Avoid \"IndexSizeError\"\n    if (dstWidth > 0 && dstHeight > 0) {\n      var scale = width / initialWidth;\n\n      params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);\n    }\n\n    // All the numerical parameters should be integer for `drawImage`\n    // https://github.com/fengyuanchen/cropper/issues/476\n    context.drawImage.apply(context, [source].concat(toConsumableArray(params.map(function (param) {\n      return Math.floor(normalizeDecimalNumber(param));\n    }))));\n\n    return canvas;\n  },\n\n\n  /**\n   * Change the aspect ratio of the crop box.\n   * @param {number} aspectRatio - The new aspect ratio.\n   * @returns {Cropper} this\n   */\n  setAspectRatio: function setAspectRatio(aspectRatio) {\n    var options = this.options;\n\n\n    if (!this.disabled && !isUndefined(aspectRatio)) {\n      // 0 -> NaN\n      options.aspectRatio = Math.max(0, aspectRatio) || NaN;\n\n      if (this.ready) {\n        this.initCropBox();\n\n        if (this.cropped) {\n          this.renderCropBox();\n        }\n      }\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Change the drag mode.\n   * @param {string} mode - The new drag mode.\n   * @returns {Cropper} this\n   */\n  setDragMode: function setDragMode(mode) {\n    var options = this.options,\n        dragBox = this.dragBox,\n        face = this.face;\n\n\n    if (this.ready && !this.disabled) {\n      var croppable = mode === DRAG_MODE_CROP;\n      var movable = options.movable && mode === DRAG_MODE_MOVE;\n\n      mode = croppable || movable ? mode : DRAG_MODE_NONE;\n\n      options.dragMode = mode;\n      setData(dragBox, DATA_ACTION, mode);\n      toggleClass(dragBox, CLASS_CROP, croppable);\n      toggleClass(dragBox, CLASS_MOVE, movable);\n\n      if (!options.cropBoxMovable) {\n        // Sync drag mode to crop box when it is not movable\n        setData(face, DATA_ACTION, mode);\n        toggleClass(face, CLASS_CROP, croppable);\n        toggleClass(face, CLASS_MOVE, movable);\n      }\n    }\n\n    return this;\n  }\n};\n\nvar AnotherCropper = WINDOW.Cropper;\n\nvar Cropper = function () {\n  /**\n   * Create a new Cropper.\n   * @param {Element} element - The target element for cropping.\n   * @param {Object} [options={}] - The configuration options.\n   */\n  function Cropper(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Cropper);\n\n    if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {\n      throw new Error('The first argument is required and must be an <img> or <canvas> element.');\n    }\n\n    this.element = element;\n    this.options = assign({}, DEFAULTS, isPlainObject(options) && options);\n    this.cropped = false;\n    this.disabled = false;\n    this.pointers = {};\n    this.ready = false;\n    this.reloading = false;\n    this.replaced = false;\n    this.sized = false;\n    this.sizing = false;\n    this.init();\n  }\n\n  createClass(Cropper, [{\n    key: 'init',\n    value: function init() {\n      var element = this.element;\n\n      var tagName = element.tagName.toLowerCase();\n      var url = void 0;\n\n      if (getData(element, NAMESPACE)) {\n        return;\n      }\n\n      setData(element, NAMESPACE, this);\n\n      if (tagName === 'img') {\n        this.isImg = true;\n\n        // e.g.: \"img/picture.jpg\"\n        url = element.getAttribute('src') || '';\n        this.originalUrl = url;\n\n        // Stop when it's a blank image\n        if (!url) {\n          return;\n        }\n\n        // e.g.: \"http://example.com/img/picture.jpg\"\n        url = element.src;\n      } else if (tagName === 'canvas' && window.HTMLCanvasElement) {\n        url = element.toDataURL();\n      }\n\n      this.load(url);\n    }\n  }, {\n    key: 'load',\n    value: function load(url) {\n      var _this = this;\n\n      if (!url) {\n        return;\n      }\n\n      this.url = url;\n      this.imageData = {};\n\n      var element = this.element,\n          options = this.options;\n\n\n      if (!options.rotatable && !options.scalable) {\n        options.checkOrientation = false;\n      }\n\n      if (!options.checkOrientation || !window.ArrayBuffer) {\n        this.clone();\n        return;\n      }\n\n      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari\n      if (REGEXP_DATA_URL.test(url)) {\n        if (REGEXP_DATA_URL_JPEG.test(url)) {\n          this.read(dataURLToArrayBuffer(url));\n        } else {\n          this.clone();\n        }\n\n        return;\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      this.reloading = true;\n      this.xhr = xhr;\n\n      var done = function done() {\n        _this.reloading = false;\n        _this.xhr = null;\n      };\n\n      xhr.ontimeout = done;\n      xhr.onabort = done;\n      xhr.onerror = function () {\n        done();\n        _this.clone();\n      };\n\n      xhr.onload = function () {\n        done();\n        _this.read(xhr.response);\n      };\n\n      // Bust cache when there is a \"crossOrigin\" property\n      if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {\n        url = addTimestamp(url);\n      }\n\n      xhr.open('get', url);\n      xhr.responseType = 'arraybuffer';\n      xhr.withCredentials = element.crossOrigin === 'use-credentials';\n      xhr.send();\n    }\n  }, {\n    key: 'read',\n    value: function read(arrayBuffer) {\n      var options = this.options,\n          imageData = this.imageData;\n\n      var orientation = getOrientation(arrayBuffer);\n      var rotate = 0;\n      var scaleX = 1;\n      var scaleY = 1;\n\n      if (orientation > 1) {\n        this.url = arrayBufferToDataURL(arrayBuffer, 'image/jpeg');\n\n        var _parseOrientation = parseOrientation(orientation);\n\n        rotate = _parseOrientation.rotate;\n        scaleX = _parseOrientation.scaleX;\n        scaleY = _parseOrientation.scaleY;\n      }\n\n      if (options.rotatable) {\n        imageData.rotate = rotate;\n      }\n\n      if (options.scalable) {\n        imageData.scaleX = scaleX;\n        imageData.scaleY = scaleY;\n      }\n\n      this.clone();\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var element = this.element,\n          url = this.url;\n\n      var crossOrigin = void 0;\n      var crossOriginUrl = void 0;\n\n      if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {\n        crossOrigin = element.crossOrigin;\n\n\n        if (crossOrigin) {\n          crossOriginUrl = url;\n        } else {\n          crossOrigin = 'anonymous';\n\n          // Bust cache when there is not a \"crossOrigin\" property\n          crossOriginUrl = addTimestamp(url);\n        }\n      }\n\n      this.crossOrigin = crossOrigin;\n      this.crossOriginUrl = crossOriginUrl;\n\n      var image = document.createElement('img');\n\n      if (crossOrigin) {\n        image.crossOrigin = crossOrigin;\n      }\n\n      image.src = crossOriginUrl || url;\n      this.image = image;\n      image.onload = this.start.bind(this);\n      image.onerror = this.stop.bind(this);\n      addClass(image, CLASS_HIDE);\n      element.parentNode.insertBefore(image, element.nextSibling);\n    }\n  }, {\n    key: 'start',\n    value: function start() {\n      var _this2 = this;\n\n      var image = this.isImg ? this.element : this.image;\n\n      image.onload = null;\n      image.onerror = null;\n      this.sizing = true;\n\n      var IS_SAFARI = WINDOW.navigator && /(Macintosh|iPhone|iPod|iPad).*AppleWebKit/i.test(WINDOW.navigator.userAgent);\n      var done = function done(naturalWidth, naturalHeight) {\n        assign(_this2.imageData, {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight,\n          aspectRatio: naturalWidth / naturalHeight\n        });\n        _this2.sizing = false;\n        _this2.sized = true;\n        _this2.build();\n      };\n\n      // Modern browsers (except Safari)\n      if (image.naturalWidth && !IS_SAFARI) {\n        done(image.naturalWidth, image.naturalHeight);\n        return;\n      }\n\n      var sizingImage = document.createElement('img');\n      var body = document.body || document.documentElement;\n\n      this.sizingImage = sizingImage;\n\n      sizingImage.onload = function () {\n        done(sizingImage.width, sizingImage.height);\n\n        if (!IS_SAFARI) {\n          body.removeChild(sizingImage);\n        }\n      };\n\n      sizingImage.src = image.src;\n\n      // iOS Safari will convert the image automatically\n      // with its orientation once append it into DOM (#279)\n      if (!IS_SAFARI) {\n        sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';\n        body.appendChild(sizingImage);\n      }\n    }\n  }, {\n    key: 'stop',\n    value: function stop() {\n      var image = this.image;\n\n\n      image.onload = null;\n      image.onerror = null;\n      image.parentNode.removeChild(image);\n      this.image = null;\n    }\n  }, {\n    key: 'build',\n    value: function build() {\n      if (!this.sized || this.ready) {\n        return;\n      }\n\n      var element = this.element,\n          options = this.options,\n          image = this.image;\n\n      // Create cropper elements\n\n      var container = element.parentNode;\n      var template = document.createElement('div');\n\n      template.innerHTML = TEMPLATE;\n\n      var cropper = template.querySelector('.' + NAMESPACE + '-container');\n      var canvas = cropper.querySelector('.' + NAMESPACE + '-canvas');\n      var dragBox = cropper.querySelector('.' + NAMESPACE + '-drag-box');\n      var cropBox = cropper.querySelector('.' + NAMESPACE + '-crop-box');\n      var face = cropBox.querySelector('.' + NAMESPACE + '-face');\n\n      this.container = container;\n      this.cropper = cropper;\n      this.canvas = canvas;\n      this.dragBox = dragBox;\n      this.cropBox = cropBox;\n      this.viewBox = cropper.querySelector('.' + NAMESPACE + '-view-box');\n      this.face = face;\n\n      canvas.appendChild(image);\n\n      // Hide the original image\n      addClass(element, CLASS_HIDDEN);\n\n      // Inserts the cropper after to the current image\n      container.insertBefore(cropper, element.nextSibling);\n\n      // Show the image if is hidden\n      if (!this.isImg) {\n        removeClass(image, CLASS_HIDE);\n      }\n\n      this.initPreview();\n      this.bind();\n\n      options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;\n      options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;\n      options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;\n\n      addClass(cropBox, CLASS_HIDDEN);\n\n      if (!options.guides) {\n        addClass(cropBox.getElementsByClassName(NAMESPACE + '-dashed'), CLASS_HIDDEN);\n      }\n\n      if (!options.center) {\n        addClass(cropBox.getElementsByClassName(NAMESPACE + '-center'), CLASS_HIDDEN);\n      }\n\n      if (options.background) {\n        addClass(cropper, NAMESPACE + '-bg');\n      }\n\n      if (!options.highlight) {\n        addClass(face, CLASS_INVISIBLE);\n      }\n\n      if (options.cropBoxMovable) {\n        addClass(face, CLASS_MOVE);\n        setData(face, DATA_ACTION, ACTION_ALL);\n      }\n\n      if (!options.cropBoxResizable) {\n        addClass(cropBox.getElementsByClassName(NAMESPACE + '-line'), CLASS_HIDDEN);\n        addClass(cropBox.getElementsByClassName(NAMESPACE + '-point'), CLASS_HIDDEN);\n      }\n\n      this.render();\n      this.ready = true;\n      this.setDragMode(options.dragMode);\n\n      if (options.autoCrop) {\n        this.crop();\n      }\n\n      this.setData(options.data);\n\n      if (isFunction(options.ready)) {\n        addListener(element, EVENT_READY, options.ready, {\n          once: true\n        });\n      }\n\n      dispatchEvent(element, EVENT_READY);\n    }\n  }, {\n    key: 'unbuild',\n    value: function unbuild() {\n      if (!this.ready) {\n        return;\n      }\n\n      this.ready = false;\n      this.unbind();\n      this.resetPreview();\n      this.cropper.parentNode.removeChild(this.cropper);\n      removeClass(this.element, CLASS_HIDDEN);\n    }\n  }, {\n    key: 'uncreate',\n    value: function uncreate() {\n      if (this.ready) {\n        this.unbuild();\n        this.ready = false;\n        this.cropped = false;\n      } else if (this.sizing) {\n        this.sizingImage.onload = null;\n        this.sizing = false;\n        this.sized = false;\n      } else if (this.reloading) {\n        this.xhr.abort();\n      } else if (this.image) {\n        this.stop();\n      }\n    }\n\n    /**\n     * Get the no conflict cropper class.\n     * @returns {Cropper} The cropper class.\n     */\n\n  }], [{\n    key: 'noConflict',\n    value: function noConflict() {\n      window.Cropper = AnotherCropper;\n      return Cropper;\n    }\n\n    /**\n     * Change the default options.\n     * @param {Object} options - The new default options.\n     */\n\n  }, {\n    key: 'setDefaults',\n    value: function setDefaults(options) {\n      assign(DEFAULTS, isPlainObject(options) && options);\n    }\n  }]);\n  return Cropper;\n}();\n\nassign(Cropper.prototype, render, preview, events, handlers, change, methods);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cropper);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5lc20uanM/YjVmYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHNDQUFzQztBQUN0QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCLGlCQUFpQiwyQkFBMkIsNEJBQTRCLDhCQUE4QiwrQkFBK0Isc0NBQXNDOztBQUVwTztBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU8sWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsK0JBQStCLDhCQUE4Qiw0QkFBNEIsMkJBQTJCLGVBQWUsdUJBQXVCLFdBQVcsZ0JBQWdCO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVlLHNFQUFPLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5lc20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENyb3BwZXIuanMgdjEuNC4xXG4gKiBodHRwczovL2Zlbmd5dWFuY2hlbi5naXRodWIuaW8vY3JvcHBlcmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCBDaGVuIEZlbmd5dWFuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE4LTA3LTE1VDA5OjU1OjMxLjE3MFpcbiAqL1xuXG52YXIgSU5fQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIFdJTkRPVyA9IElOX0JST1dTRVIgPyB3aW5kb3cgOiB7fTtcbnZhciBOQU1FU1BBQ0UgPSAnY3JvcHBlcic7XG5cbi8vIEFjdGlvbnNcbnZhciBBQ1RJT05fQUxMID0gJ2FsbCc7XG52YXIgQUNUSU9OX0NST1AgPSAnY3JvcCc7XG52YXIgQUNUSU9OX01PVkUgPSAnbW92ZSc7XG52YXIgQUNUSU9OX1pPT00gPSAnem9vbSc7XG52YXIgQUNUSU9OX0VBU1QgPSAnZSc7XG52YXIgQUNUSU9OX1dFU1QgPSAndyc7XG52YXIgQUNUSU9OX1NPVVRIID0gJ3MnO1xudmFyIEFDVElPTl9OT1JUSCA9ICduJztcbnZhciBBQ1RJT05fTk9SVEhfRUFTVCA9ICduZSc7XG52YXIgQUNUSU9OX05PUlRIX1dFU1QgPSAnbncnO1xudmFyIEFDVElPTl9TT1VUSF9FQVNUID0gJ3NlJztcbnZhciBBQ1RJT05fU09VVEhfV0VTVCA9ICdzdyc7XG5cbi8vIENsYXNzZXNcbnZhciBDTEFTU19DUk9QID0gTkFNRVNQQUNFICsgJy1jcm9wJztcbnZhciBDTEFTU19ESVNBQkxFRCA9IE5BTUVTUEFDRSArICctZGlzYWJsZWQnO1xudmFyIENMQVNTX0hJRERFTiA9IE5BTUVTUEFDRSArICctaGlkZGVuJztcbnZhciBDTEFTU19ISURFID0gTkFNRVNQQUNFICsgJy1oaWRlJztcbnZhciBDTEFTU19JTlZJU0lCTEUgPSBOQU1FU1BBQ0UgKyAnLWludmlzaWJsZSc7XG52YXIgQ0xBU1NfTU9EQUwgPSBOQU1FU1BBQ0UgKyAnLW1vZGFsJztcbnZhciBDTEFTU19NT1ZFID0gTkFNRVNQQUNFICsgJy1tb3ZlJztcblxuLy8gRGF0YSBrZXlzXG52YXIgREFUQV9BQ1RJT04gPSBOQU1FU1BBQ0UgKyAnQWN0aW9uJztcbnZhciBEQVRBX1BSRVZJRVcgPSBOQU1FU1BBQ0UgKyAnUHJldmlldyc7XG5cbi8vIERyYWcgbW9kZXNcbnZhciBEUkFHX01PREVfQ1JPUCA9ICdjcm9wJztcbnZhciBEUkFHX01PREVfTU9WRSA9ICdtb3ZlJztcbnZhciBEUkFHX01PREVfTk9ORSA9ICdub25lJztcblxuLy8gRXZlbnRzXG52YXIgRVZFTlRfQ1JPUCA9ICdjcm9wJztcbnZhciBFVkVOVF9DUk9QX0VORCA9ICdjcm9wZW5kJztcbnZhciBFVkVOVF9DUk9QX01PVkUgPSAnY3JvcG1vdmUnO1xudmFyIEVWRU5UX0NST1BfU1RBUlQgPSAnY3JvcHN0YXJ0JztcbnZhciBFVkVOVF9EQkxDTElDSyA9ICdkYmxjbGljayc7XG52YXIgRVZFTlRfUE9JTlRFUl9ET1dOID0gV0lORE9XLlBvaW50ZXJFdmVudCA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCBtb3VzZWRvd24nO1xudmFyIEVWRU5UX1BPSU5URVJfTU9WRSA9IFdJTkRPVy5Qb2ludGVyRXZlbnQgPyAncG9pbnRlcm1vdmUnIDogJ3RvdWNobW92ZSBtb3VzZW1vdmUnO1xudmFyIEVWRU5UX1BPSU5URVJfVVAgPSBXSU5ET1cuUG9pbnRlckV2ZW50ID8gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJyA6ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBtb3VzZXVwJztcbnZhciBFVkVOVF9SRUFEWSA9ICdyZWFkeSc7XG52YXIgRVZFTlRfUkVTSVpFID0gJ3Jlc2l6ZSc7XG52YXIgRVZFTlRfV0hFRUwgPSAnd2hlZWwgbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCc7XG52YXIgRVZFTlRfWk9PTSA9ICd6b29tJztcblxuLy8gUmVnRXhwc1xudmFyIFJFR0VYUF9BQ1RJT05TID0gL14oPzplfHd8c3xufHNlfHN3fG5lfG53fGFsbHxjcm9wfG1vdmV8em9vbSkkLztcbnZhciBSRUdFWFBfREFUQV9VUkwgPSAvXmRhdGE6LztcbnZhciBSRUdFWFBfREFUQV9VUkxfSlBFRyA9IC9eZGF0YTppbWFnZVxcL2pwZWc7YmFzZTY0LC87XG52YXIgUkVHRVhQX1RBR19OQU1FID0gL14oPzppbWd8Y2FudmFzKSQvaTtcblxudmFyIERFRkFVTFRTID0ge1xuICAvLyBEZWZpbmUgdGhlIHZpZXcgbW9kZSBvZiB0aGUgY3JvcHBlclxuICB2aWV3TW9kZTogMCwgLy8gMCwgMSwgMiwgM1xuXG4gIC8vIERlZmluZSB0aGUgZHJhZ2dpbmcgbW9kZSBvZiB0aGUgY3JvcHBlclxuICBkcmFnTW9kZTogRFJBR19NT0RFX0NST1AsIC8vICdjcm9wJywgJ21vdmUnIG9yICdub25lJ1xuXG4gIC8vIERlZmluZSB0aGUgaW5pdGlhbCBhc3BlY3QgcmF0aW8gb2YgdGhlIGNyb3AgYm94XG4gIGluaXRpYWxBc3BlY3RSYXRpbzogTmFOLFxuXG4gIC8vIERlZmluZSB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjcm9wIGJveFxuICBhc3BlY3RSYXRpbzogTmFOLFxuXG4gIC8vIEFuIG9iamVjdCB3aXRoIHRoZSBwcmV2aW91cyBjcm9wcGluZyByZXN1bHQgZGF0YVxuICBkYXRhOiBudWxsLFxuXG4gIC8vIEEgc2VsZWN0b3IgZm9yIGFkZGluZyBleHRyYSBjb250YWluZXJzIHRvIHByZXZpZXdcbiAgcHJldmlldzogJycsXG5cbiAgLy8gUmUtcmVuZGVyIHRoZSBjcm9wcGVyIHdoZW4gcmVzaXplIHRoZSB3aW5kb3dcbiAgcmVzcG9uc2l2ZTogdHJ1ZSxcblxuICAvLyBSZXN0b3JlIHRoZSBjcm9wcGVkIGFyZWEgYWZ0ZXIgcmVzaXplIHRoZSB3aW5kb3dcbiAgcmVzdG9yZTogdHJ1ZSxcblxuICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBpbWFnZSBpcyBhIGNyb3NzLW9yaWdpbiBpbWFnZVxuICBjaGVja0Nyb3NzT3JpZ2luOiB0cnVlLFxuXG4gIC8vIENoZWNrIHRoZSBjdXJyZW50IGltYWdlJ3MgRXhpZiBPcmllbnRhdGlvbiBpbmZvcm1hdGlvblxuICBjaGVja09yaWVudGF0aW9uOiB0cnVlLFxuXG4gIC8vIFNob3cgdGhlIGJsYWNrIG1vZGFsXG4gIG1vZGFsOiB0cnVlLFxuXG4gIC8vIFNob3cgdGhlIGRhc2hlZCBsaW5lcyBmb3IgZ3VpZGluZ1xuICBndWlkZXM6IHRydWUsXG5cbiAgLy8gU2hvdyB0aGUgY2VudGVyIGluZGljYXRvciBmb3IgZ3VpZGluZ1xuICBjZW50ZXI6IHRydWUsXG5cbiAgLy8gU2hvdyB0aGUgd2hpdGUgbW9kYWwgdG8gaGlnaGxpZ2h0IHRoZSBjcm9wIGJveFxuICBoaWdobGlnaHQ6IHRydWUsXG5cbiAgLy8gU2hvdyB0aGUgZ3JpZCBiYWNrZ3JvdW5kXG4gIGJhY2tncm91bmQ6IHRydWUsXG5cbiAgLy8gRW5hYmxlIHRvIGNyb3AgdGhlIGltYWdlIGF1dG9tYXRpY2FsbHkgd2hlbiBpbml0aWFsaXplXG4gIGF1dG9Dcm9wOiB0cnVlLFxuXG4gIC8vIERlZmluZSB0aGUgcGVyY2VudGFnZSBvZiBhdXRvbWF0aWMgY3JvcHBpbmcgYXJlYSB3aGVuIGluaXRpYWxpemVzXG4gIGF1dG9Dcm9wQXJlYTogMC44LFxuXG4gIC8vIEVuYWJsZSB0byBtb3ZlIHRoZSBpbWFnZVxuICBtb3ZhYmxlOiB0cnVlLFxuXG4gIC8vIEVuYWJsZSB0byByb3RhdGUgdGhlIGltYWdlXG4gIHJvdGF0YWJsZTogdHJ1ZSxcblxuICAvLyBFbmFibGUgdG8gc2NhbGUgdGhlIGltYWdlXG4gIHNjYWxhYmxlOiB0cnVlLFxuXG4gIC8vIEVuYWJsZSB0byB6b29tIHRoZSBpbWFnZVxuICB6b29tYWJsZTogdHJ1ZSxcblxuICAvLyBFbmFibGUgdG8gem9vbSB0aGUgaW1hZ2UgYnkgZHJhZ2dpbmcgdG91Y2hcbiAgem9vbU9uVG91Y2g6IHRydWUsXG5cbiAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlIGJ5IHdoZWVsaW5nIG1vdXNlXG4gIHpvb21PbldoZWVsOiB0cnVlLFxuXG4gIC8vIERlZmluZSB6b29tIHJhdGlvIHdoZW4gem9vbSB0aGUgaW1hZ2UgYnkgd2hlZWxpbmcgbW91c2VcbiAgd2hlZWxab29tUmF0aW86IDAuMSxcblxuICAvLyBFbmFibGUgdG8gbW92ZSB0aGUgY3JvcCBib3hcbiAgY3JvcEJveE1vdmFibGU6IHRydWUsXG5cbiAgLy8gRW5hYmxlIHRvIHJlc2l6ZSB0aGUgY3JvcCBib3hcbiAgY3JvcEJveFJlc2l6YWJsZTogdHJ1ZSxcblxuICAvLyBUb2dnbGUgZHJhZyBtb2RlIGJldHdlZW4gXCJjcm9wXCIgYW5kIFwibW92ZVwiIHdoZW4gY2xpY2sgdHdpY2Ugb24gdGhlIGNyb3BwZXJcbiAgdG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrOiB0cnVlLFxuXG4gIC8vIFNpemUgbGltaXRhdGlvblxuICBtaW5DYW52YXNXaWR0aDogMCxcbiAgbWluQ2FudmFzSGVpZ2h0OiAwLFxuICBtaW5Dcm9wQm94V2lkdGg6IDAsXG4gIG1pbkNyb3BCb3hIZWlnaHQ6IDAsXG4gIG1pbkNvbnRhaW5lcldpZHRoOiAyMDAsXG4gIG1pbkNvbnRhaW5lckhlaWdodDogMTAwLFxuXG4gIC8vIFNob3J0Y3V0cyBvZiBldmVudHNcbiAgcmVhZHk6IG51bGwsXG4gIGNyb3BzdGFydDogbnVsbCxcbiAgY3JvcG1vdmU6IG51bGwsXG4gIGNyb3BlbmQ6IG51bGwsXG4gIGNyb3A6IG51bGwsXG4gIHpvb206IG51bGxcbn07XG5cbnZhciBURU1QTEFURSA9ICc8ZGl2IGNsYXNzPVwiY3JvcHBlci1jb250YWluZXJcIiB0b3VjaC1hY3Rpb249XCJub25lXCI+JyArICc8ZGl2IGNsYXNzPVwiY3JvcHBlci13cmFwLWJveFwiPicgKyAnPGRpdiBjbGFzcz1cImNyb3BwZXItY2FudmFzXCI+PC9kaXY+JyArICc8L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWRyYWctYm94XCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwiY3JvcHBlci1jcm9wLWJveFwiPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXZpZXctYm94XCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWRhc2hlZCBkYXNoZWQtaFwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1kYXNoZWQgZGFzaGVkLXZcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItY2VudGVyXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWZhY2VcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItbGluZSBsaW5lLWVcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwiZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtblwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJuXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS13XCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIndcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItbGluZSBsaW5lLXNcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwic1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1lXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cImVcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtblwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJuXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LXdcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwid1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1zXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cInNcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtbmVcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwibmVcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtbndcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwibndcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtc3dcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwic3dcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtc2VcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwic2VcIj48L3NwYW4+JyArICc8L2Rpdj4nICsgJzwvZGl2Pic7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLlxuICovXG52YXIgaXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgV0lORE9XLmlzTmFOO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHVuZGVmaW5lZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG90eXBlID0gX2NvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuXG4gICAgcmV0dXJuIF9jb25zdHJ1Y3RvciAmJiBwcm90b3R5cGUgJiYgaGFzT3duUHJvcGVydHkuY2FsbChwcm90b3R5cGUsICdpc1Byb3RvdHlwZU9mJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhlIGdpdmVuIGRhdGEuXG4gKiBAcGFyYW0geyp9IGRhdGEgLSBUaGUgZGF0YSB0byBpdGVyYXRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcHJvY2VzcyBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50LlxuICogQHJldHVybnMgeyp9IFRoZSBvcmlnaW5hbCBkYXRhLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGlmIChkYXRhICYmIGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNOdW1iZXIoZGF0YS5sZW5ndGgpIC8qIGFycmF5LWxpa2UgKi8pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgIHZhciBpID0gdm9pZCAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGRhdGEsIGRhdGFbaV0sIGksIGRhdGEpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChkYXRhLCBkYXRhW2tleV0sIGtleSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBFeHRlbmQgdGhlIGdpdmVuIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZC5cbiAqIEBwYXJhbSB7Kn0gYXJncyAtIFRoZSByZXN0IG9iamVjdHMgd2hpY2ggd2lsbCBiZSBtZXJnZWQgdG8gdGhlIGZpcnN0IG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBleHRlbmRlZCBvYmplY3QuXG4gKi9cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIGFzc2lnbihvYmopIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoaXNPYmplY3Qob2JqKSAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgaWYgKGlzT2JqZWN0KGFyZykpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IGFyZ1trZXldO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgUkVHRVhQX0RFQ0lNQUxTID0gL1xcLlxcZCooPzowfDkpezEyfVxcZCokL2k7XG5cbi8qKlxuICogTm9ybWFsaXplIGRlY2ltYWwgbnVtYmVyLlxuICogQ2hlY2sgb3V0IHtAbGluayBodHRwOi8vMC4zMDAwMDAwMDAwMDAwMDAwNC5jb20vfVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZXM9MTAwMDAwMDAwMDAwXSAtIFRoZSB0aW1lcyBmb3Igbm9ybWFsaXppbmcuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBub3JtYWxpemVkIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGVjaW1hbE51bWJlcih2YWx1ZSkge1xuICB2YXIgdGltZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDAwMDAwMDAwMDtcblxuICByZXR1cm4gUkVHRVhQX0RFQ0lNQUxTLnRlc3QodmFsdWUpID8gTWF0aC5yb3VuZCh2YWx1ZSAqIHRpbWVzKSAvIHRpbWVzIDogdmFsdWU7XG59XG5cbnZhciBSRUdFWFBfU1VGRklYID0gL14oPzp3aWR0aHxoZWlnaHR8bGVmdHx0b3B8bWFyZ2luTGVmdHxtYXJnaW5Ub3ApJC87XG5cbi8qKlxuICogQXBwbHkgc3R5bGVzIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyAtIFRoZSBzdHlsZXMgZm9yIGFwcGx5aW5nLlxuICovXG5mdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblxuXG4gIGZvckVhY2goc3R5bGVzLCBmdW5jdGlvbiAodmFsdWUsIHByb3BlcnR5KSB7XG4gICAgaWYgKFJFR0VYUF9TVUZGSVgudGVzdChwcm9wZXJ0eSkgJiYgaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICB2YWx1ZSArPSAncHgnO1xuICAgIH1cblxuICAgIHN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgYSBzcGVjaWFsIGNsYXNzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3MgdG8gc2VhcmNoLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWFsIGNsYXNzIHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgdmFsdWUpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0ID8gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModmFsdWUpIDogZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbn1cblxuLyoqXG4gKiBBZGQgY2xhc3NlcyB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIGFkZGVkLlxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCB2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKGVsZW1lbnQubGVuZ3RoKSkge1xuICAgIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIGFkZENsYXNzKGVsZW0sIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQodmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS50cmltKCk7XG5cbiAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGNsYXNzTmFtZS5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICcgJyArIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzZXMgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNOdW1iZXIoZWxlbWVudC5sZW5ndGgpKSB7XG4gICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmVtb3ZlQ2xhc3MoZWxlbSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpID49IDApIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UodmFsdWUsICcnKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBvciByZW1vdmUgY2xhc3NlcyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIGNsYXNzZXMgdG8gYmUgdG9nZ2xlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWRkZWQgLSBBZGQgb25seS5cbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgdmFsdWUsIGFkZGVkKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNOdW1iZXIoZWxlbWVudC5sZW5ndGgpKSB7XG4gICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgdG9nZ2xlQ2xhc3MoZWxlbSwgdmFsdWUsIGFkZGVkKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJRTEwLTExIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiBgY2xhc3NMaXN0LnRvZ2dsZWBcbiAgaWYgKGFkZGVkKSB7XG4gICAgYWRkQ2xhc3MoZWxlbWVudCwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgUkVHRVhQX0hZUEhFTkFURSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZ2l2ZW4gc3RyaW5nIGZyb20gY2FtZWxDYXNlIHRvIGtlYmFiLWNhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShSRUdFWFBfSFlQSEVOQVRFLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIEdldCBkYXRhIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBkYXRhIGtleSB0byBnZXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGF0YSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YShlbGVtZW50LCBuYW1lKSB7XG4gIGlmIChpc09iamVjdChlbGVtZW50W25hbWVdKSkge1xuICAgIHJldHVybiBlbGVtZW50W25hbWVdO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQuZGF0YXNldCkge1xuICAgIHJldHVybiBlbGVtZW50LmRhdGFzZXRbbmFtZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGh5cGhlbmF0ZShuYW1lKSk7XG59XG5cbi8qKlxuICogU2V0IGRhdGEgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBkYXRhIGtleSB0byBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBkYXRhIHZhbHVlLlxuICovXG5mdW5jdGlvbiBzZXREYXRhKGVsZW1lbnQsIG5hbWUsIGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgZWxlbWVudFtuYW1lXSA9IGRhdGE7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgZWxlbWVudC5kYXRhc2V0W25hbWVdID0gZGF0YTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS0nICsgaHlwaGVuYXRlKG5hbWUpLCBkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBkYXRhIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBkYXRhIGtleSB0byByZW1vdmUuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURhdGEoZWxlbWVudCwgbmFtZSkge1xuICBpZiAoaXNPYmplY3QoZWxlbWVudFtuYW1lXSkpIHtcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIGVsZW1lbnRbbmFtZV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZWxlbWVudFtuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgLy8gIzEyOCBTYWZhcmkgbm90IGFsbG93cyB0byBkZWxldGUgZGF0YXNldCBwcm9wZXJ0eVxuICAgIHRyeSB7XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0W25hbWVdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtJyArIGh5cGhlbmF0ZShuYW1lKSk7XG4gIH1cbn1cblxudmFyIFJFR0VYUF9TUEFDRVMgPSAvXFxzXFxzKi87XG52YXIgb25jZVN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xuXG4gIGlmIChJTl9CUk9XU0VSKSB7XG4gICAgdmFyIG9uY2UgPSBmYWxzZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHt9O1xuICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnb25jZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb25jZTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIHNldHRlciBjYW4gZml4IGEgYFR5cGVFcnJvcmAgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvR2V0dGVyX29ubHl9XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldFxuICAgICAgICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2YWx1ZSkge1xuICAgICAgICBvbmNlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBXSU5ET1cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICBXSU5ET1cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0ZWQ7XG59KCk7XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUocykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBldmVudCBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGV2ZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICB2YXIgaGFuZGxlciA9IGxpc3RlbmVyO1xuXG4gIHR5cGUudHJpbSgpLnNwbGl0KFJFR0VYUF9TUEFDRVMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCFvbmNlU3VwcG9ydGVkKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gZWxlbWVudC5saXN0ZW5lcnM7XG5cblxuICAgICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbZXZlbnRdICYmIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XG4gICAgICAgIGhhbmRsZXIgPSBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdO1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsaXN0ZW5lcnNbZXZlbnRdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBlbGVtZW50Lmxpc3RlbmVycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lciB0byB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZShzKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGxpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgZXZlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gIHZhciBfaGFuZGxlciA9IGxpc3RlbmVyO1xuXG4gIHR5cGUudHJpbSgpLnNwbGl0KFJFR0VYUF9TUEFDRVMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKG9wdGlvbnMub25jZSAmJiAhb25jZVN1cHBvcnRlZCkge1xuICAgICAgdmFyIF9lbGVtZW50JGxpc3RlbmVycyA9IGVsZW1lbnQubGlzdGVuZXJzLFxuICAgICAgICAgIGxpc3RlbmVycyA9IF9lbGVtZW50JGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkID8ge30gOiBfZWxlbWVudCRsaXN0ZW5lcnM7XG5cblxuICAgICAgX2hhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KGVsZW1lbnQsIGFyZ3MpO1xuICAgICAgfTtcblxuICAgICAgaWYgKCFsaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl0sIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXSA9IF9oYW5kbGVyO1xuICAgICAgZWxlbWVudC5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGV2ZW50IG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlKHMpLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgYWRkaXRpb25hbCBldmVudCBkYXRhLlxuICogQHJldHVybnMge2Jvb2xlYW59IEluZGljYXRlIGlmIHRoZSBldmVudCBpcyBkZWZhdWx0IHByZXZlbnRlZCBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgdHlwZSwgZGF0YSkge1xuICB2YXIgZXZlbnQgPSB2b2lkIDA7XG5cbiAgLy8gRXZlbnQgYW5kIEN1c3RvbUV2ZW50IG9uIElFOS0xMSBhcmUgZ2xvYmFsIG9iamVjdHMsIG5vdCBjb25zdHJ1Y3RvcnNcbiAgaWYgKGlzRnVuY3Rpb24oRXZlbnQpICYmIGlzRnVuY3Rpb24oQ3VzdG9tRXZlbnQpKSB7XG4gICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgICAgZGV0YWlsOiBkYXRhLFxuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGV2ZW50LmluaXRDdXN0b21FdmVudCh0eXBlLCB0cnVlLCB0cnVlLCBkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb2Zmc2V0IGJhc2Ugb24gdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIG9mZnNldCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXQoZWxlbWVudCkge1xuICB2YXIgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGJveC5sZWZ0ICsgKHdpbmRvdy5wYWdlWE9mZnNldCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRMZWZ0KSxcbiAgICB0b3A6IGJveC50b3AgKyAod2luZG93LnBhZ2VZT2Zmc2V0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFRvcClcbiAgfTtcbn1cblxudmFyIGxvY2F0aW9uID0gV0lORE9XLmxvY2F0aW9uO1xuXG52YXIgUkVHRVhQX09SSUdJTlMgPSAvXihodHRwcz86KVxcL1xcLyhbXjovPyNdKyk6PyhcXGQqKS9pO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBVUkwgaXMgYSBjcm9zcyBvcmlnaW4gVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSB0YXJnZXQgVVJMLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBVUkwgaXMgYSBjcm9zcyBvcmlnaW4gVVJMLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzQ3Jvc3NPcmlnaW5VUkwodXJsKSB7XG4gIHZhciBwYXJ0cyA9IHVybC5tYXRjaChSRUdFWFBfT1JJR0lOUyk7XG5cbiAgcmV0dXJuIHBhcnRzICYmIChwYXJ0c1sxXSAhPT0gbG9jYXRpb24ucHJvdG9jb2wgfHwgcGFydHNbMl0gIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBhcnRzWzNdICE9PSBsb2NhdGlvbi5wb3J0KTtcbn1cblxuLyoqXG4gKiBBZGQgdGltZXN0YW1wIHRvIHRoZSBnaXZlbiBVUkwuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHRhcmdldCBVUkwuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcmVzdWx0IFVSTC5cbiAqL1xuZnVuY3Rpb24gYWRkVGltZXN0YW1wKHVybCkge1xuICB2YXIgdGltZXN0YW1wID0gJ3RpbWVzdGFtcD0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgcmV0dXJuIHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyB0aW1lc3RhbXA7XG59XG5cbi8qKlxuICogR2V0IHRyYW5zZm9ybXMgYmFzZSBvbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSB0YXJnZXQgb2JqZWN0LlxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgY29udGFpbnMgdHJhbnNmb3JtIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtcyhfcmVmKSB7XG4gIHZhciByb3RhdGUgPSBfcmVmLnJvdGF0ZSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB0cmFuc2xhdGVYID0gX3JlZi50cmFuc2xhdGVYLFxuICAgICAgdHJhbnNsYXRlWSA9IF9yZWYudHJhbnNsYXRlWTtcblxuICB2YXIgdmFsdWVzID0gW107XG5cbiAgaWYgKGlzTnVtYmVyKHRyYW5zbGF0ZVgpICYmIHRyYW5zbGF0ZVggIT09IDApIHtcbiAgICB2YWx1ZXMucHVzaCgndHJhbnNsYXRlWCgnICsgdHJhbnNsYXRlWCArICdweCknKTtcbiAgfVxuXG4gIGlmIChpc051bWJlcih0cmFuc2xhdGVZKSAmJiB0cmFuc2xhdGVZICE9PSAwKSB7XG4gICAgdmFsdWVzLnB1c2goJ3RyYW5zbGF0ZVkoJyArIHRyYW5zbGF0ZVkgKyAncHgpJyk7XG4gIH1cblxuICAvLyBSb3RhdGUgc2hvdWxkIGNvbWUgZmlyc3QgYmVmb3JlIHNjYWxlIHRvIG1hdGNoIG9yaWVudGF0aW9uIHRyYW5zZm9ybVxuICBpZiAoaXNOdW1iZXIocm90YXRlKSAmJiByb3RhdGUgIT09IDApIHtcbiAgICB2YWx1ZXMucHVzaCgncm90YXRlKCcgKyByb3RhdGUgKyAnZGVnKScpO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKHNjYWxlWCkgJiYgc2NhbGVYICE9PSAxKSB7XG4gICAgdmFsdWVzLnB1c2goJ3NjYWxlWCgnICsgc2NhbGVYICsgJyknKTtcbiAgfVxuXG4gIGlmIChpc051bWJlcihzY2FsZVkpICYmIHNjYWxlWSAhPT0gMSkge1xuICAgIHZhbHVlcy5wdXNoKCdzY2FsZVkoJyArIHNjYWxlWSArICcpJyk7XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtID0gdmFsdWVzLmxlbmd0aCA/IHZhbHVlcy5qb2luKCcgJykgOiAnbm9uZSc7XG5cbiAgcmV0dXJuIHtcbiAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBtc1RyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBtYXggcmF0aW8gb2YgYSBncm91cCBvZiBwb2ludGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2ludGVycyAtIFRoZSB0YXJnZXQgcG9pbnRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVzdWx0IHJhdGlvLlxuICovXG5mdW5jdGlvbiBnZXRNYXhab29tUmF0aW8ocG9pbnRlcnMpIHtcbiAgdmFyIHBvaW50ZXJzMiA9IGFzc2lnbih7fSwgcG9pbnRlcnMpO1xuICB2YXIgcmF0aW9zID0gW107XG5cbiAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKHBvaW50ZXIsIHBvaW50ZXJJZCkge1xuICAgIGRlbGV0ZSBwb2ludGVyczJbcG9pbnRlcklkXTtcblxuICAgIGZvckVhY2gocG9pbnRlcnMyLCBmdW5jdGlvbiAocG9pbnRlcjIpIHtcbiAgICAgIHZhciB4MSA9IE1hdGguYWJzKHBvaW50ZXIuc3RhcnRYIC0gcG9pbnRlcjIuc3RhcnRYKTtcbiAgICAgIHZhciB5MSA9IE1hdGguYWJzKHBvaW50ZXIuc3RhcnRZIC0gcG9pbnRlcjIuc3RhcnRZKTtcbiAgICAgIHZhciB4MiA9IE1hdGguYWJzKHBvaW50ZXIuZW5kWCAtIHBvaW50ZXIyLmVuZFgpO1xuICAgICAgdmFyIHkyID0gTWF0aC5hYnMocG9pbnRlci5lbmRZIC0gcG9pbnRlcjIuZW5kWSk7XG4gICAgICB2YXIgejEgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpO1xuICAgICAgdmFyIHoyID0gTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcbiAgICAgIHZhciByYXRpbyA9ICh6MiAtIHoxKSAvIHoxO1xuXG4gICAgICByYXRpb3MucHVzaChyYXRpbyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJhdGlvcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEpIDwgTWF0aC5hYnMoYik7XG4gIH0pO1xuXG4gIHJldHVybiByYXRpb3NbMF07XG59XG5cbi8qKlxuICogR2V0IGEgcG9pbnRlciBmcm9tIGFuIGV2ZW50IG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSB0YXJnZXQgZXZlbnQgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBlbmRPbmx5IC0gSW5kaWNhdGVzIGlmIG9ubHkgcmV0dXJucyB0aGUgZW5kIHBvaW50IGNvb3JkaW5hdGUgb3Igbm90LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBwb2ludGVyIGNvbnRhaW5zIHN0YXJ0IGFuZC9vciBlbmQgcG9pbnQgY29vcmRpbmF0ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50ZXIoX3JlZjIsIGVuZE9ubHkpIHtcbiAgdmFyIHBhZ2VYID0gX3JlZjIucGFnZVgsXG4gICAgICBwYWdlWSA9IF9yZWYyLnBhZ2VZO1xuXG4gIHZhciBlbmQgPSB7XG4gICAgZW5kWDogcGFnZVgsXG4gICAgZW5kWTogcGFnZVlcbiAgfTtcblxuICByZXR1cm4gZW5kT25seSA/IGVuZCA6IGFzc2lnbih7XG4gICAgc3RhcnRYOiBwYWdlWCxcbiAgICBzdGFydFk6IHBhZ2VZXG4gIH0sIGVuZCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjZW50ZXIgcG9pbnQgY29vcmRpbmF0ZSBvZiBhIGdyb3VwIG9mIHBvaW50ZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJzIC0gVGhlIHRhcmdldCBwb2ludGVycy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjZW50ZXIgcG9pbnQgY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRlcnNDZW50ZXIocG9pbnRlcnMpIHtcbiAgdmFyIHBhZ2VYID0gMDtcbiAgdmFyIHBhZ2VZID0gMDtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmb3JFYWNoKHBvaW50ZXJzLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgc3RhcnRYID0gX3JlZjMuc3RhcnRYLFxuICAgICAgICBzdGFydFkgPSBfcmVmMy5zdGFydFk7XG5cbiAgICBwYWdlWCArPSBzdGFydFg7XG4gICAgcGFnZVkgKz0gc3RhcnRZO1xuICAgIGNvdW50ICs9IDE7XG4gIH0pO1xuXG4gIHBhZ2VYIC89IGNvdW50O1xuICBwYWdlWSAvPSBjb3VudDtcblxuICByZXR1cm4ge1xuICAgIHBhZ2VYOiBwYWdlWCxcbiAgICBwYWdlWTogcGFnZVlcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmaW5pdGUgbnVtYmVyLlxuICovXG52YXIgaXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgV0lORE9XLmlzRmluaXRlO1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IHNpemVzIGluIGEgcmVjdGFuZ2xlIHVuZGVyIHRoZSBnaXZlbiBhc3BlY3QgcmF0aW8uXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBvcmlnaW5hbCBzaXplcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT0nY29udGFpbiddIC0gVGhlIGFkanVzdCB0eXBlLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBzaXplcy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWRqdXN0ZWRTaXplcyhfcmVmNCkgLy8gb3IgJ2NvdmVyJ1xue1xuICB2YXIgYXNwZWN0UmF0aW8gPSBfcmVmNC5hc3BlY3RSYXRpbyxcbiAgICAgIGhlaWdodCA9IF9yZWY0LmhlaWdodCxcbiAgICAgIHdpZHRoID0gX3JlZjQud2lkdGg7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnY29udGFpbic7XG5cbiAgdmFyIGlzVmFsaWROdW1iZXIgPSBmdW5jdGlvbiBpc1ZhbGlkTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDA7XG4gIH07XG5cbiAgaWYgKGlzVmFsaWROdW1iZXIod2lkdGgpICYmIGlzVmFsaWROdW1iZXIoaGVpZ2h0KSkge1xuICAgIHZhciBhZGp1c3RlZFdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NvbnRhaW4nICYmIGFkanVzdGVkV2lkdGggPiB3aWR0aCB8fCB0eXBlID09PSAnY292ZXInICYmIGFkanVzdGVkV2lkdGggPCB3aWR0aCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZE51bWJlcih3aWR0aCkpIHtcbiAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICB9IGVsc2UgaWYgKGlzVmFsaWROdW1iZXIoaGVpZ2h0KSkge1xuICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV3IHNpemVzIG9mIGEgcmVjdGFuZ2xlIGFmdGVyIHJvdGF0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBvcmlnaW5hbCBzaXplcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgc2l6ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0ZWRTaXplcyhfcmVmNSkge1xuICB2YXIgd2lkdGggPSBfcmVmNS53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWY1LmhlaWdodCxcbiAgICAgIGRlZ3JlZSA9IF9yZWY1LmRlZ3JlZTtcblxuICBkZWdyZWUgPSBNYXRoLmFicyhkZWdyZWUpICUgMTgwO1xuXG4gIGlmIChkZWdyZWUgPT09IDkwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBoZWlnaHQsXG4gICAgICBoZWlnaHQ6IHdpZHRoXG4gICAgfTtcbiAgfVxuXG4gIHZhciBhcmMgPSBkZWdyZWUgJSA5MCAqIE1hdGguUEkgLyAxODA7XG4gIHZhciBzaW5BcmMgPSBNYXRoLnNpbihhcmMpO1xuICB2YXIgY29zQXJjID0gTWF0aC5jb3MoYXJjKTtcbiAgdmFyIG5ld1dpZHRoID0gd2lkdGggKiBjb3NBcmMgKyBoZWlnaHQgKiBzaW5BcmM7XG4gIHZhciBuZXdIZWlnaHQgPSB3aWR0aCAqIHNpbkFyYyArIGhlaWdodCAqIGNvc0FyYztcblxuICByZXR1cm4gZGVncmVlID4gOTAgPyB7XG4gICAgd2lkdGg6IG5ld0hlaWdodCxcbiAgICBoZWlnaHQ6IG5ld1dpZHRoXG4gIH0gOiB7XG4gICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgIGhlaWdodDogbmV3SGVpZ2h0XG4gIH07XG59XG5cbi8qKlxuICogR2V0IGEgY2FudmFzIHdoaWNoIGRyZXcgdGhlIGdpdmVuIGltYWdlLlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZSAtIFRoZSBpbWFnZSBmb3IgZHJhd2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGEgLSBUaGUgaW1hZ2UgZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNEYXRhIC0gVGhlIGNhbnZhcyBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIHJlc3VsdCBjYW52YXMuXG4gKi9cbmZ1bmN0aW9uIGdldFNvdXJjZUNhbnZhcyhpbWFnZSwgX3JlZjYsIF9yZWY3LCBfcmVmOCkge1xuICB2YXIgaW1hZ2VBc3BlY3RSYXRpbyA9IF9yZWY2LmFzcGVjdFJhdGlvLFxuICAgICAgaW1hZ2VOYXR1cmFsV2lkdGggPSBfcmVmNi5uYXR1cmFsV2lkdGgsXG4gICAgICBpbWFnZU5hdHVyYWxIZWlnaHQgPSBfcmVmNi5uYXR1cmFsSGVpZ2h0LFxuICAgICAgX3JlZjYkcm90YXRlID0gX3JlZjYucm90YXRlLFxuICAgICAgcm90YXRlID0gX3JlZjYkcm90YXRlID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjYkcm90YXRlLFxuICAgICAgX3JlZjYkc2NhbGVYID0gX3JlZjYuc2NhbGVYLFxuICAgICAgc2NhbGVYID0gX3JlZjYkc2NhbGVYID09PSB1bmRlZmluZWQgPyAxIDogX3JlZjYkc2NhbGVYLFxuICAgICAgX3JlZjYkc2NhbGVZID0gX3JlZjYuc2NhbGVZLFxuICAgICAgc2NhbGVZID0gX3JlZjYkc2NhbGVZID09PSB1bmRlZmluZWQgPyAxIDogX3JlZjYkc2NhbGVZO1xuICB2YXIgYXNwZWN0UmF0aW8gPSBfcmVmNy5hc3BlY3RSYXRpbyxcbiAgICAgIG5hdHVyYWxXaWR0aCA9IF9yZWY3Lm5hdHVyYWxXaWR0aCxcbiAgICAgIG5hdHVyYWxIZWlnaHQgPSBfcmVmNy5uYXR1cmFsSGVpZ2h0O1xuICB2YXIgX3JlZjgkZmlsbENvbG9yID0gX3JlZjguZmlsbENvbG9yLFxuICAgICAgZmlsbENvbG9yID0gX3JlZjgkZmlsbENvbG9yID09PSB1bmRlZmluZWQgPyAndHJhbnNwYXJlbnQnIDogX3JlZjgkZmlsbENvbG9yLFxuICAgICAgX3JlZjgkaW1hZ2VTbW9vdGhpbmdFID0gX3JlZjguaW1hZ2VTbW9vdGhpbmdFbmFibGVkLFxuICAgICAgaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gX3JlZjgkaW1hZ2VTbW9vdGhpbmdFID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjgkaW1hZ2VTbW9vdGhpbmdFLFxuICAgICAgX3JlZjgkaW1hZ2VTbW9vdGhpbmdRID0gX3JlZjguaW1hZ2VTbW9vdGhpbmdRdWFsaXR5LFxuICAgICAgaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gX3JlZjgkaW1hZ2VTbW9vdGhpbmdRID09PSB1bmRlZmluZWQgPyAnbG93JyA6IF9yZWY4JGltYWdlU21vb3RoaW5nUSxcbiAgICAgIF9yZWY4JG1heFdpZHRoID0gX3JlZjgubWF4V2lkdGgsXG4gICAgICBtYXhXaWR0aCA9IF9yZWY4JG1heFdpZHRoID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IF9yZWY4JG1heFdpZHRoLFxuICAgICAgX3JlZjgkbWF4SGVpZ2h0ID0gX3JlZjgubWF4SGVpZ2h0LFxuICAgICAgbWF4SGVpZ2h0ID0gX3JlZjgkbWF4SGVpZ2h0ID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IF9yZWY4JG1heEhlaWdodCxcbiAgICAgIF9yZWY4JG1pbldpZHRoID0gX3JlZjgubWluV2lkdGgsXG4gICAgICBtaW5XaWR0aCA9IF9yZWY4JG1pbldpZHRoID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjgkbWluV2lkdGgsXG4gICAgICBfcmVmOCRtaW5IZWlnaHQgPSBfcmVmOC5taW5IZWlnaHQsXG4gICAgICBtaW5IZWlnaHQgPSBfcmVmOCRtaW5IZWlnaHQgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmOCRtaW5IZWlnaHQ7XG5cbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB2YXIgbWF4U2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgd2lkdGg6IG1heFdpZHRoLFxuICAgIGhlaWdodDogbWF4SGVpZ2h0XG4gIH0pO1xuICB2YXIgbWluU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgd2lkdGg6IG1pbldpZHRoLFxuICAgIGhlaWdodDogbWluSGVpZ2h0XG4gIH0sICdjb3ZlcicpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1pbihtYXhTaXplcy53aWR0aCwgTWF0aC5tYXgobWluU2l6ZXMud2lkdGgsIG5hdHVyYWxXaWR0aCkpO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5taW4obWF4U2l6ZXMuaGVpZ2h0LCBNYXRoLm1heChtaW5TaXplcy5oZWlnaHQsIG5hdHVyYWxIZWlnaHQpKTtcblxuICAvLyBOb3RlOiBzaG91bGQgYWx3YXlzIHVzZSBpbWFnZSdzIG5hdHVyYWwgc2l6ZXMgZm9yIGRyYXdpbmcgYXNcbiAgLy8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCA9PT0gY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0IHdoZW4gcm90YXRlICUgMTgwID09PSA5MFxuICB2YXIgZGVzdE1heFNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgYXNwZWN0UmF0aW86IGltYWdlQXNwZWN0UmF0aW8sXG4gICAgd2lkdGg6IG1heFdpZHRoLFxuICAgIGhlaWdodDogbWF4SGVpZ2h0XG4gIH0pO1xuICB2YXIgZGVzdE1pblNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgYXNwZWN0UmF0aW86IGltYWdlQXNwZWN0UmF0aW8sXG4gICAgd2lkdGg6IG1pbldpZHRoLFxuICAgIGhlaWdodDogbWluSGVpZ2h0XG4gIH0sICdjb3ZlcicpO1xuICB2YXIgZGVzdFdpZHRoID0gTWF0aC5taW4oZGVzdE1heFNpemVzLndpZHRoLCBNYXRoLm1heChkZXN0TWluU2l6ZXMud2lkdGgsIGltYWdlTmF0dXJhbFdpZHRoKSk7XG4gIHZhciBkZXN0SGVpZ2h0ID0gTWF0aC5taW4oZGVzdE1heFNpemVzLmhlaWdodCwgTWF0aC5tYXgoZGVzdE1pblNpemVzLmhlaWdodCwgaW1hZ2VOYXR1cmFsSGVpZ2h0KSk7XG4gIHZhciBwYXJhbXMgPSBbLWRlc3RXaWR0aCAvIDIsIC1kZXN0SGVpZ2h0IC8gMiwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0XTtcblxuICBjYW52YXMud2lkdGggPSBub3JtYWxpemVEZWNpbWFsTnVtYmVyKHdpZHRoKTtcbiAgY2FudmFzLmhlaWdodCA9IG5vcm1hbGl6ZURlY2ltYWxOdW1iZXIoaGVpZ2h0KTtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBmaWxsQ29sb3I7XG4gIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGNvbnRleHQuc2F2ZSgpO1xuICBjb250ZXh0LnRyYW5zbGF0ZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb250ZXh0LnJvdGF0ZShyb3RhdGUgKiBNYXRoLlBJIC8gMTgwKTtcbiAgY29udGV4dC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICBjb250ZXh0LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9IGltYWdlU21vb3RoaW5nUXVhbGl0eTtcbiAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgW2ltYWdlXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkocGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihub3JtYWxpemVEZWNpbWFsTnVtYmVyKHBhcmFtKSk7XG4gIH0pKSkpO1xuICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgcmV0dXJuIGNhbnZhcztcbn1cblxudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qKlxuICogR2V0IHN0cmluZyBmcm9tIGNoYXIgY29kZSBpbiBkYXRhIHZpZXcuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyAtIFRoZSBkYXRhIHZpZXcgZm9yIHJlYWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBUaGUgc3RhcnQgaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gVGhlIHJlYWQgbGVuZ3RoLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlYWQgcmVzdWx0LlxuICovXG5cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21DaGFyQ29kZShkYXRhVmlldywgc3RhcnQsIGxlbmd0aCkge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBpID0gdm9pZCAwO1xuXG4gIGxlbmd0aCArPSBzdGFydDtcblxuICBmb3IgKGkgPSBzdGFydDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgc3RyICs9IGZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG52YXIgUkVHRVhQX0RBVEFfVVJMX0hFQUQgPSAvXmRhdGE6LiosLztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gRGF0YSBVUkwgdG8gYXJyYXkgYnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFVUkwgLSBUaGUgRGF0YSBVUkwgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBUaGUgcmVzdWx0IGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gZGF0YVVSTFRvQXJyYXlCdWZmZXIoZGF0YVVSTCkge1xuICB2YXIgYmFzZTY0ID0gZGF0YVVSTC5yZXBsYWNlKFJFR0VYUF9EQVRBX1VSTF9IRUFELCAnJyk7XG4gIHZhciBiaW5hcnkgPSBhdG9iKGJhc2U2NCk7XG4gIHZhciBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihiaW5hcnkubGVuZ3RoKTtcbiAgdmFyIHVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuXG4gIGZvckVhY2godWludDgsIGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgIHVpbnQ4W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gIH0pO1xuXG4gIHJldHVybiBhcnJheUJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYXJyYXkgYnVmZmVyIHRvIERhdGEgVVJMLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgLSBUaGUgYXJyYXkgYnVmZmVyIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSAtIFRoZSBtaW1lIHR5cGUgb2YgdGhlIERhdGEgVVJMLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdCBEYXRhIFVSTC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0RhdGFVUkwoYXJyYXlCdWZmZXIsIG1pbWVUeXBlKSB7XG4gIHZhciB1aW50OCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgdmFyIGRhdGEgPSAnJztcblxuICAvLyBUeXBlZEFycmF5LnByb3RvdHlwZS5mb3JFYWNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gc29tZSBicm93c2VycyBhcyBJRS5cbiAgaWYgKGlzRnVuY3Rpb24odWludDguZm9yRWFjaCkpIHtcbiAgICAvLyBVc2UgbmF0aXZlIGBmb3JFYWNoYCBtZXRob2QgZmlyc3QgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgIHVpbnQ4LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBkYXRhICs9IGZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaCh1aW50OCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBkYXRhICs9IGZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gJ2RhdGE6JyArIG1pbWVUeXBlICsgJztiYXNlNjQsJyArIGJ0b2EoZGF0YSk7XG59XG5cbi8qKlxuICogR2V0IG9yaWVudGF0aW9uIHZhbHVlIGZyb20gZ2l2ZW4gYXJyYXkgYnVmZmVyLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgLSBUaGUgYXJyYXkgYnVmZmVyIHRvIHJlYWQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVhZCBvcmllbnRhdGlvbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0T3JpZW50YXRpb24oYXJyYXlCdWZmZXIpIHtcbiAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgdmFyIG9yaWVudGF0aW9uID0gdm9pZCAwO1xuICB2YXIgbGl0dGxlRW5kaWFuID0gdm9pZCAwO1xuICB2YXIgYXBwMVN0YXJ0ID0gdm9pZCAwO1xuICB2YXIgaWZkU3RhcnQgPSB2b2lkIDA7XG5cbiAgLy8gT25seSBoYW5kbGUgSlBFRyBpbWFnZSAoc3RhcnQgYnkgMHhGRkQ4KVxuICBpZiAoZGF0YVZpZXcuZ2V0VWludDgoMCkgPT09IDB4RkYgJiYgZGF0YVZpZXcuZ2V0VWludDgoMSkgPT09IDB4RDgpIHtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcbiAgICB2YXIgb2Zmc2V0ID0gMjtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpID09PSAweEZGICYmIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpID09PSAweEUxKSB7XG4gICAgICAgIGFwcDFTdGFydCA9IG9mZnNldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhcHAxU3RhcnQpIHtcbiAgICB2YXIgZXhpZklEQ29kZSA9IGFwcDFTdGFydCArIDQ7XG4gICAgdmFyIHRpZmZPZmZzZXQgPSBhcHAxU3RhcnQgKyAxMDtcblxuICAgIGlmIChnZXRTdHJpbmdGcm9tQ2hhckNvZGUoZGF0YVZpZXcsIGV4aWZJRENvZGUsIDQpID09PSAnRXhpZicpIHtcbiAgICAgIHZhciBlbmRpYW5uZXNzID0gZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpO1xuXG4gICAgICBsaXR0bGVFbmRpYW4gPSBlbmRpYW5uZXNzID09PSAweDQ5NDk7XG5cbiAgICAgIGlmIChsaXR0bGVFbmRpYW4gfHwgZW5kaWFubmVzcyA9PT0gMHg0RDREIC8qIGJpZ0VuZGlhbiAqLykge1xuICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsIGxpdHRsZUVuZGlhbikgPT09IDB4MDAyQSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0SUZET2Zmc2V0ID0gZGF0YVZpZXcuZ2V0VWludDMyKHRpZmZPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPj0gMHgwMDAwMDAwOCkge1xuICAgICAgICAgICAgICBpZmRTdGFydCA9IHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaWZkU3RhcnQpIHtcbiAgICB2YXIgX2xlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihpZmRTdGFydCwgbGl0dGxlRW5kaWFuKTtcbiAgICB2YXIgX29mZnNldCA9IHZvaWQgMDtcbiAgICB2YXIgaSA9IHZvaWQgMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBfbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIF9vZmZzZXQgPSBpZmRTdGFydCArIGkgKiAxMiArIDI7XG5cbiAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYoX29mZnNldCwgbGl0dGxlRW5kaWFuKSA9PT0gMHgwMTEyIC8qIE9yaWVudGF0aW9uICovKSB7XG4gICAgICAgICAgLy8gOCBpcyB0aGUgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IHRhZydzIHZhbHVlXG4gICAgICAgICAgX29mZnNldCArPSA4O1xuXG4gICAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBvcmllbnRhdGlvbiB2YWx1ZVxuICAgICAgICAgIG9yaWVudGF0aW9uID0gZGF0YVZpZXcuZ2V0VWludDE2KF9vZmZzZXQsIGxpdHRsZUVuZGlhbik7XG5cbiAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgb3JpZW50YXRpb24gd2l0aCBpdHMgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihfb2Zmc2V0LCAxLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9yaWVudGF0aW9uO1xufVxuXG4vKipcbiAqIFBhcnNlIEV4aWYgT3JpZW50YXRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZW50YXRpb24gLSBUaGUgb3JpZW50YXRpb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGFyc2VkIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICB2YXIgcm90YXRlID0gMDtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAvLyBGbGlwIGhvcml6b250YWxcbiAgICBjYXNlIDI6XG4gICAgICBzY2FsZVggPSAtMTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gUm90YXRlIGxlZnQgMTgwwrBcbiAgICBjYXNlIDM6XG4gICAgICByb3RhdGUgPSAtMTgwO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBGbGlwIHZlcnRpY2FsXG4gICAgY2FzZSA0OlxuICAgICAgc2NhbGVZID0gLTE7XG4gICAgICBicmVhaztcblxuICAgIC8vIEZsaXAgdmVydGljYWwgYW5kIHJvdGF0ZSByaWdodCA5MMKwXG4gICAgY2FzZSA1OlxuICAgICAgcm90YXRlID0gOTA7XG4gICAgICBzY2FsZVkgPSAtMTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gUm90YXRlIHJpZ2h0IDkwwrBcbiAgICBjYXNlIDY6XG4gICAgICByb3RhdGUgPSA5MDtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gRmxpcCBob3Jpem9udGFsIGFuZCByb3RhdGUgcmlnaHQgOTDCsFxuICAgIGNhc2UgNzpcbiAgICAgIHJvdGF0ZSA9IDkwO1xuICAgICAgc2NhbGVYID0gLTE7XG4gICAgICBicmVhaztcblxuICAgIC8vIFJvdGF0ZSBsZWZ0IDkwwrBcbiAgICBjYXNlIDg6XG4gICAgICByb3RhdGUgPSAtOTA7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdGF0ZTogcm90YXRlLFxuICAgIHNjYWxlWDogc2NhbGVYLFxuICAgIHNjYWxlWTogc2NhbGVZXG4gIH07XG59XG5cbnZhciByZW5kZXIgPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuICAgIHRoaXMuaW5pdENhbnZhcygpO1xuICAgIHRoaXMuaW5pdENyb3BCb3goKTtcbiAgICB0aGlzLnJlbmRlckNhbnZhcygpO1xuXG4gICAgaWYgKHRoaXMuY3JvcHBlZCkge1xuICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgfVxuICB9LFxuICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbiBpbml0Q29udGFpbmVyKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgY3JvcHBlciA9IHRoaXMuY3JvcHBlcjtcblxuXG4gICAgYWRkQ2xhc3MoY3JvcHBlciwgQ0xBU1NfSElEREVOKTtcbiAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pO1xuXG4gICAgdmFyIGNvbnRhaW5lckRhdGEgPSB7XG4gICAgICB3aWR0aDogTWF0aC5tYXgoY29udGFpbmVyLm9mZnNldFdpZHRoLCBOdW1iZXIob3B0aW9ucy5taW5Db250YWluZXJXaWR0aCkgfHwgMjAwKSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoY29udGFpbmVyLm9mZnNldEhlaWdodCwgTnVtYmVyKG9wdGlvbnMubWluQ29udGFpbmVySGVpZ2h0KSB8fCAxMDApXG4gICAgfTtcblxuICAgIHRoaXMuY29udGFpbmVyRGF0YSA9IGNvbnRhaW5lckRhdGE7XG5cbiAgICBzZXRTdHlsZShjcm9wcGVyLCB7XG4gICAgICB3aWR0aDogY29udGFpbmVyRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodDogY29udGFpbmVyRGF0YS5oZWlnaHRcbiAgICB9KTtcblxuICAgIGFkZENsYXNzKGVsZW1lbnQsIENMQVNTX0hJRERFTik7XG4gICAgcmVtb3ZlQ2xhc3MoY3JvcHBlciwgQ0xBU1NfSElEREVOKTtcbiAgfSxcblxuXG4gIC8vIENhbnZhcyAoaW1hZ2Ugd3JhcHBlcilcbiAgaW5pdENhbnZhczogZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICB2YXIgY29udGFpbmVyRGF0YSA9IHRoaXMuY29udGFpbmVyRGF0YSxcbiAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgdmFyIHZpZXdNb2RlID0gdGhpcy5vcHRpb25zLnZpZXdNb2RlO1xuXG4gICAgdmFyIHJvdGF0ZWQgPSBNYXRoLmFicyhpbWFnZURhdGEucm90YXRlKSAlIDE4MCA9PT0gOTA7XG4gICAgdmFyIG5hdHVyYWxXaWR0aCA9IHJvdGF0ZWQgPyBpbWFnZURhdGEubmF0dXJhbEhlaWdodCA6IGltYWdlRGF0YS5uYXR1cmFsV2lkdGg7XG4gICAgdmFyIG5hdHVyYWxIZWlnaHQgPSByb3RhdGVkID8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCA6IGltYWdlRGF0YS5uYXR1cmFsSGVpZ2h0O1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XG4gICAgdmFyIGNhbnZhc1dpZHRoID0gY29udGFpbmVyRGF0YS53aWR0aDtcbiAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG5cbiAgICBpZiAoY29udGFpbmVyRGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbyA+IGNvbnRhaW5lckRhdGEud2lkdGgpIHtcbiAgICAgIGlmICh2aWV3TW9kZSA9PT0gMykge1xuICAgICAgICBjYW52YXNXaWR0aCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXNIZWlnaHQgPSBjb250YWluZXJEYXRhLndpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2aWV3TW9kZSA9PT0gMykge1xuICAgICAgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW52YXNXaWR0aCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhc0RhdGEgPSB7XG4gICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICBuYXR1cmFsV2lkdGg6IG5hdHVyYWxXaWR0aCxcbiAgICAgIG5hdHVyYWxIZWlnaHQ6IG5hdHVyYWxIZWlnaHQsXG4gICAgICB3aWR0aDogY2FudmFzV2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgIH07XG5cbiAgICBjYW52YXNEYXRhLmxlZnQgPSAoY29udGFpbmVyRGF0YS53aWR0aCAtIGNhbnZhc1dpZHRoKSAvIDI7XG4gICAgY2FudmFzRGF0YS50b3AgPSAoY29udGFpbmVyRGF0YS5oZWlnaHQgLSBjYW52YXNIZWlnaHQpIC8gMjtcbiAgICBjYW52YXNEYXRhLm9sZExlZnQgPSBjYW52YXNEYXRhLmxlZnQ7XG4gICAgY2FudmFzRGF0YS5vbGRUb3AgPSBjYW52YXNEYXRhLnRvcDtcblxuICAgIHRoaXMuY2FudmFzRGF0YSA9IGNhbnZhc0RhdGE7XG4gICAgdGhpcy5saW1pdGVkID0gdmlld01vZGUgPT09IDEgfHwgdmlld01vZGUgPT09IDI7XG4gICAgdGhpcy5saW1pdENhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB0aGlzLmluaXRpYWxJbWFnZURhdGEgPSBhc3NpZ24oe30sIGltYWdlRGF0YSk7XG4gICAgdGhpcy5pbml0aWFsQ2FudmFzRGF0YSA9IGFzc2lnbih7fSwgY2FudmFzRGF0YSk7XG4gIH0sXG4gIGxpbWl0Q2FudmFzOiBmdW5jdGlvbiBsaW1pdENhbnZhcyhzaXplTGltaXRlZCwgcG9zaXRpb25MaW1pdGVkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGEsXG4gICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcbiAgICB2YXIgdmlld01vZGUgPSBvcHRpb25zLnZpZXdNb2RlO1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IGNhbnZhc0RhdGEuYXNwZWN0UmF0aW87XG5cbiAgICB2YXIgY3JvcHBlZCA9IHRoaXMuY3JvcHBlZCAmJiBjcm9wQm94RGF0YTtcblxuICAgIGlmIChzaXplTGltaXRlZCkge1xuICAgICAgdmFyIG1pbkNhbnZhc1dpZHRoID0gTnVtYmVyKG9wdGlvbnMubWluQ2FudmFzV2lkdGgpIHx8IDA7XG4gICAgICB2YXIgbWluQ2FudmFzSGVpZ2h0ID0gTnVtYmVyKG9wdGlvbnMubWluQ2FudmFzSGVpZ2h0KSB8fCAwO1xuXG4gICAgICBpZiAodmlld01vZGUgPiAxKSB7XG4gICAgICAgIG1pbkNhbnZhc1dpZHRoID0gTWF0aC5tYXgobWluQ2FudmFzV2lkdGgsIGNvbnRhaW5lckRhdGEud2lkdGgpO1xuICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBNYXRoLm1heChtaW5DYW52YXNIZWlnaHQsIGNvbnRhaW5lckRhdGEuaGVpZ2h0KTtcblxuICAgICAgICBpZiAodmlld01vZGUgPT09IDMpIHtcbiAgICAgICAgICBpZiAobWluQ2FudmFzSGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtaW5DYW52YXNXaWR0aCkge1xuICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluQ2FudmFzSGVpZ2h0ID0gbWluQ2FudmFzV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmlld01vZGUgPiAwKSB7XG4gICAgICAgIGlmIChtaW5DYW52YXNXaWR0aCkge1xuICAgICAgICAgIG1pbkNhbnZhc1dpZHRoID0gTWF0aC5tYXgobWluQ2FudmFzV2lkdGgsIGNyb3BwZWQgPyBjcm9wQm94RGF0YS53aWR0aCA6IDApO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbkNhbnZhc0hlaWdodCkge1xuICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IE1hdGgubWF4KG1pbkNhbnZhc0hlaWdodCwgY3JvcHBlZCA/IGNyb3BCb3hEYXRhLmhlaWdodCA6IDApO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3BwZWQpIHtcbiAgICAgICAgICBtaW5DYW52YXNXaWR0aCA9IGNyb3BCb3hEYXRhLndpZHRoO1xuICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcblxuICAgICAgICAgIGlmIChtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbyA+IG1pbkNhbnZhc1dpZHRoKSB7XG4gICAgICAgICAgICBtaW5DYW52YXNXaWR0aCA9IG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBtaW5DYW52YXNXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgICB3aWR0aDogbWluQ2FudmFzV2lkdGgsXG4gICAgICAgIGhlaWdodDogbWluQ2FudmFzSGVpZ2h0XG4gICAgICB9KTtcblxuICAgICAgbWluQ2FudmFzV2lkdGggPSBfZ2V0QWRqdXN0ZWRTaXplcy53aWR0aDtcbiAgICAgIG1pbkNhbnZhc0hlaWdodCA9IF9nZXRBZGp1c3RlZFNpemVzLmhlaWdodDtcblxuXG4gICAgICBjYW52YXNEYXRhLm1pbldpZHRoID0gbWluQ2FudmFzV2lkdGg7XG4gICAgICBjYW52YXNEYXRhLm1pbkhlaWdodCA9IG1pbkNhbnZhc0hlaWdodDtcbiAgICAgIGNhbnZhc0RhdGEubWF4V2lkdGggPSBJbmZpbml0eTtcbiAgICAgIGNhbnZhc0RhdGEubWF4SGVpZ2h0ID0gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uTGltaXRlZCkge1xuICAgICAgaWYgKHZpZXdNb2RlID4gKGNyb3BwZWQgPyAwIDogMSkpIHtcbiAgICAgICAgdmFyIG5ld0NhbnZhc0xlZnQgPSBjb250YWluZXJEYXRhLndpZHRoIC0gY2FudmFzRGF0YS53aWR0aDtcbiAgICAgICAgdmFyIG5ld0NhbnZhc1RvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gTWF0aC5taW4oMCwgbmV3Q2FudmFzTGVmdCk7XG4gICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gTWF0aC5taW4oMCwgbmV3Q2FudmFzVG9wKTtcbiAgICAgICAgY2FudmFzRGF0YS5tYXhMZWZ0ID0gTWF0aC5tYXgoMCwgbmV3Q2FudmFzTGVmdCk7XG4gICAgICAgIGNhbnZhc0RhdGEubWF4VG9wID0gTWF0aC5tYXgoMCwgbmV3Q2FudmFzVG9wKTtcblxuICAgICAgICBpZiAoY3JvcHBlZCAmJiB0aGlzLmxpbWl0ZWQpIHtcbiAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBNYXRoLm1pbihjcm9wQm94RGF0YS5sZWZ0LCBjcm9wQm94RGF0YS5sZWZ0ICsgKGNyb3BCb3hEYXRhLndpZHRoIC0gY2FudmFzRGF0YS53aWR0aCkpO1xuICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gTWF0aC5taW4oY3JvcEJveERhdGEudG9wLCBjcm9wQm94RGF0YS50b3AgKyAoY3JvcEJveERhdGEuaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQpKTtcbiAgICAgICAgICBjYW52YXNEYXRhLm1heExlZnQgPSBjcm9wQm94RGF0YS5sZWZ0O1xuICAgICAgICAgIGNhbnZhc0RhdGEubWF4VG9wID0gY3JvcEJveERhdGEudG9wO1xuXG4gICAgICAgICAgaWYgKHZpZXdNb2RlID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzRGF0YS53aWR0aCA+PSBjb250YWluZXJEYXRhLndpZHRoKSB7XG4gICAgICAgICAgICAgIGNhbnZhc0RhdGEubWluTGVmdCA9IE1hdGgubWluKDAsIG5ld0NhbnZhc0xlZnQpO1xuICAgICAgICAgICAgICBjYW52YXNEYXRhLm1heExlZnQgPSBNYXRoLm1heCgwLCBuZXdDYW52YXNMZWZ0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbnZhc0RhdGEuaGVpZ2h0ID49IGNvbnRhaW5lckRhdGEuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gTWF0aC5taW4oMCwgbmV3Q2FudmFzVG9wKTtcbiAgICAgICAgICAgICAgY2FudmFzRGF0YS5tYXhUb3AgPSBNYXRoLm1heCgwLCBuZXdDYW52YXNUb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gLWNhbnZhc0RhdGEud2lkdGg7XG4gICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gLWNhbnZhc0RhdGEuaGVpZ2h0O1xuICAgICAgICBjYW52YXNEYXRhLm1heExlZnQgPSBjb250YWluZXJEYXRhLndpZHRoO1xuICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbiByZW5kZXJDYW52YXMoY2hhbmdlZCwgdHJhbnNmb3JtZWQpIHtcbiAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG5cblxuICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgdmFyIF9nZXRSb3RhdGVkU2l6ZXMgPSBnZXRSb3RhdGVkU2l6ZXMoe1xuICAgICAgICB3aWR0aDogaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCAqIE1hdGguYWJzKGltYWdlRGF0YS5zY2FsZVggfHwgMSksXG4gICAgICAgIGhlaWdodDogaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgKiBNYXRoLmFicyhpbWFnZURhdGEuc2NhbGVZIHx8IDEpLFxuICAgICAgICBkZWdyZWU6IGltYWdlRGF0YS5yb3RhdGUgfHwgMFxuICAgICAgfSksXG4gICAgICAgICAgbmF0dXJhbFdpZHRoID0gX2dldFJvdGF0ZWRTaXplcy53aWR0aCxcbiAgICAgICAgICBuYXR1cmFsSGVpZ2h0ID0gX2dldFJvdGF0ZWRTaXplcy5oZWlnaHQ7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNhbnZhc0RhdGEud2lkdGggKiAobmF0dXJhbFdpZHRoIC8gY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgpO1xuICAgICAgdmFyIGhlaWdodCA9IGNhbnZhc0RhdGEuaGVpZ2h0ICogKG5hdHVyYWxIZWlnaHQgLyBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQpO1xuXG4gICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKHdpZHRoIC0gY2FudmFzRGF0YS53aWR0aCkgLyAyO1xuICAgICAgY2FudmFzRGF0YS50b3AgLT0gKGhlaWdodCAtIGNhbnZhc0RhdGEuaGVpZ2h0KSAvIDI7XG4gICAgICBjYW52YXNEYXRhLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXNEYXRhLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGNhbnZhc0RhdGEuYXNwZWN0UmF0aW8gPSBuYXR1cmFsV2lkdGggLyBuYXR1cmFsSGVpZ2h0O1xuICAgICAgY2FudmFzRGF0YS5uYXR1cmFsV2lkdGggPSBuYXR1cmFsV2lkdGg7XG4gICAgICBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQgPSBuYXR1cmFsSGVpZ2h0O1xuICAgICAgdGhpcy5saW1pdENhbnZhcyh0cnVlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGNhbnZhc0RhdGEud2lkdGggPiBjYW52YXNEYXRhLm1heFdpZHRoIHx8IGNhbnZhc0RhdGEud2lkdGggPCBjYW52YXNEYXRhLm1pbldpZHRoKSB7XG4gICAgICBjYW52YXNEYXRhLmxlZnQgPSBjYW52YXNEYXRhLm9sZExlZnQ7XG4gICAgfVxuXG4gICAgaWYgKGNhbnZhc0RhdGEuaGVpZ2h0ID4gY2FudmFzRGF0YS5tYXhIZWlnaHQgfHwgY2FudmFzRGF0YS5oZWlnaHQgPCBjYW52YXNEYXRhLm1pbkhlaWdodCkge1xuICAgICAgY2FudmFzRGF0YS50b3AgPSBjYW52YXNEYXRhLm9sZFRvcDtcbiAgICB9XG5cbiAgICBjYW52YXNEYXRhLndpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS5taW5XaWR0aCksIGNhbnZhc0RhdGEubWF4V2lkdGgpO1xuICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS5oZWlnaHQsIGNhbnZhc0RhdGEubWluSGVpZ2h0KSwgY2FudmFzRGF0YS5tYXhIZWlnaHQpO1xuXG4gICAgdGhpcy5saW1pdENhbnZhcyhmYWxzZSwgdHJ1ZSk7XG5cbiAgICBjYW52YXNEYXRhLmxlZnQgPSBNYXRoLm1pbihNYXRoLm1heChjYW52YXNEYXRhLmxlZnQsIGNhbnZhc0RhdGEubWluTGVmdCksIGNhbnZhc0RhdGEubWF4TGVmdCk7XG4gICAgY2FudmFzRGF0YS50b3AgPSBNYXRoLm1pbihNYXRoLm1heChjYW52YXNEYXRhLnRvcCwgY2FudmFzRGF0YS5taW5Ub3ApLCBjYW52YXNEYXRhLm1heFRvcCk7XG4gICAgY2FudmFzRGF0YS5vbGRMZWZ0ID0gY2FudmFzRGF0YS5sZWZ0O1xuICAgIGNhbnZhc0RhdGEub2xkVG9wID0gY2FudmFzRGF0YS50b3A7XG5cbiAgICBzZXRTdHlsZSh0aGlzLmNhbnZhcywgYXNzaWduKHtcbiAgICAgIHdpZHRoOiBjYW52YXNEYXRhLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXNEYXRhLmhlaWdodFxuICAgIH0sIGdldFRyYW5zZm9ybXMoe1xuICAgICAgdHJhbnNsYXRlWDogY2FudmFzRGF0YS5sZWZ0LFxuICAgICAgdHJhbnNsYXRlWTogY2FudmFzRGF0YS50b3BcbiAgICB9KSkpO1xuXG4gICAgdGhpcy5yZW5kZXJJbWFnZShjaGFuZ2VkKTtcblxuICAgIGlmICh0aGlzLmNyb3BwZWQgJiYgdGhpcy5saW1pdGVkKSB7XG4gICAgICB0aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlckltYWdlOiBmdW5jdGlvbiByZW5kZXJJbWFnZShjaGFuZ2VkKSB7XG4gICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhO1xuXG4gICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCAqIChjYW52YXNEYXRhLndpZHRoIC8gY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgpO1xuICAgIHZhciBoZWlnaHQgPSBpbWFnZURhdGEubmF0dXJhbEhlaWdodCAqIChjYW52YXNEYXRhLmhlaWdodCAvIGNhbnZhc0RhdGEubmF0dXJhbEhlaWdodCk7XG5cbiAgICBhc3NpZ24oaW1hZ2VEYXRhLCB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGxlZnQ6IChjYW52YXNEYXRhLndpZHRoIC0gd2lkdGgpIC8gMixcbiAgICAgIHRvcDogKGNhbnZhc0RhdGEuaGVpZ2h0IC0gaGVpZ2h0KSAvIDJcbiAgICB9KTtcbiAgICBzZXRTdHlsZSh0aGlzLmltYWdlLCBhc3NpZ24oe1xuICAgICAgd2lkdGg6IGltYWdlRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodDogaW1hZ2VEYXRhLmhlaWdodFxuICAgIH0sIGdldFRyYW5zZm9ybXMoYXNzaWduKHtcbiAgICAgIHRyYW5zbGF0ZVg6IGltYWdlRGF0YS5sZWZ0LFxuICAgICAgdHJhbnNsYXRlWTogaW1hZ2VEYXRhLnRvcFxuICAgIH0sIGltYWdlRGF0YSkpKSk7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5vdXRwdXQoKTtcbiAgICB9XG4gIH0sXG4gIGluaXRDcm9wQm94OiBmdW5jdGlvbiBpbml0Q3JvcEJveCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcblxuICAgIHZhciBhc3BlY3RSYXRpbyA9IG9wdGlvbnMuYXNwZWN0UmF0aW8gfHwgb3B0aW9ucy5pbml0aWFsQXNwZWN0UmF0aW87XG4gICAgdmFyIGF1dG9Dcm9wQXJlYSA9IE51bWJlcihvcHRpb25zLmF1dG9Dcm9wQXJlYSkgfHwgMC44O1xuICAgIHZhciBjcm9wQm94RGF0YSA9IHtcbiAgICAgIHdpZHRoOiBjYW52YXNEYXRhLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXNEYXRhLmhlaWdodFxuICAgIH07XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgIGlmIChjYW52YXNEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvID4gY2FudmFzRGF0YS53aWR0aCkge1xuICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBjcm9wQm94RGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBjcm9wQm94RGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNyb3BCb3hEYXRhID0gY3JvcEJveERhdGE7XG4gICAgdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7XG5cbiAgICAvLyBJbml0aWFsaXplIGF1dG8gY3JvcCBhcmVhXG4gICAgY3JvcEJveERhdGEud2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS53aWR0aCwgY3JvcEJveERhdGEubWluV2lkdGgpLCBjcm9wQm94RGF0YS5tYXhXaWR0aCk7XG4gICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5tYXgoY3JvcEJveERhdGEuaGVpZ2h0LCBjcm9wQm94RGF0YS5taW5IZWlnaHQpLCBjcm9wQm94RGF0YS5tYXhIZWlnaHQpO1xuXG4gICAgLy8gVGhlIHdpZHRoL2hlaWdodCBvZiBhdXRvIGNyb3AgYXJlYSBtdXN0IGxhcmdlIHRoYW4gXCJtaW5XaWR0aC9IZWlnaHRcIlxuICAgIGNyb3BCb3hEYXRhLndpZHRoID0gTWF0aC5tYXgoY3JvcEJveERhdGEubWluV2lkdGgsIGNyb3BCb3hEYXRhLndpZHRoICogYXV0b0Nyb3BBcmVhKTtcbiAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBNYXRoLm1heChjcm9wQm94RGF0YS5taW5IZWlnaHQsIGNyb3BCb3hEYXRhLmhlaWdodCAqIGF1dG9Dcm9wQXJlYSk7XG4gICAgY3JvcEJveERhdGEubGVmdCA9IGNhbnZhc0RhdGEubGVmdCArIChjYW52YXNEYXRhLndpZHRoIC0gY3JvcEJveERhdGEud2lkdGgpIC8gMjtcbiAgICBjcm9wQm94RGF0YS50b3AgPSBjYW52YXNEYXRhLnRvcCArIChjYW52YXNEYXRhLmhlaWdodCAtIGNyb3BCb3hEYXRhLmhlaWdodCkgLyAyO1xuICAgIGNyb3BCb3hEYXRhLm9sZExlZnQgPSBjcm9wQm94RGF0YS5sZWZ0O1xuICAgIGNyb3BCb3hEYXRhLm9sZFRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcblxuICAgIHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhID0gYXNzaWduKHt9LCBjcm9wQm94RGF0YSk7XG4gIH0sXG4gIGxpbWl0Q3JvcEJveDogZnVuY3Rpb24gbGltaXRDcm9wQm94KHNpemVMaW1pdGVkLCBwb3NpdGlvbkxpbWl0ZWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgY29udGFpbmVyRGF0YSA9IHRoaXMuY29udGFpbmVyRGF0YSxcbiAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhLFxuICAgICAgICBsaW1pdGVkID0gdGhpcy5saW1pdGVkO1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IG9wdGlvbnMuYXNwZWN0UmF0aW87XG5cblxuICAgIGlmIChzaXplTGltaXRlZCkge1xuICAgICAgdmFyIG1pbkNyb3BCb3hXaWR0aCA9IE51bWJlcihvcHRpb25zLm1pbkNyb3BCb3hXaWR0aCkgfHwgMDtcbiAgICAgIHZhciBtaW5Dcm9wQm94SGVpZ2h0ID0gTnVtYmVyKG9wdGlvbnMubWluQ3JvcEJveEhlaWdodCkgfHwgMDtcbiAgICAgIHZhciBtYXhDcm9wQm94V2lkdGggPSBsaW1pdGVkID8gTWF0aC5taW4oY29udGFpbmVyRGF0YS53aWR0aCwgY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS53aWR0aCArIGNhbnZhc0RhdGEubGVmdCwgY29udGFpbmVyRGF0YS53aWR0aCAtIGNhbnZhc0RhdGEubGVmdCkgOiBjb250YWluZXJEYXRhLndpZHRoO1xuICAgICAgdmFyIG1heENyb3BCb3hIZWlnaHQgPSBsaW1pdGVkID8gTWF0aC5taW4oY29udGFpbmVyRGF0YS5oZWlnaHQsIGNhbnZhc0RhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLmhlaWdodCArIGNhbnZhc0RhdGEudG9wLCBjb250YWluZXJEYXRhLmhlaWdodCAtIGNhbnZhc0RhdGEudG9wKSA6IGNvbnRhaW5lckRhdGEuaGVpZ2h0O1xuXG4gICAgICAvLyBUaGUgbWluL21heENyb3BCb3hXaWR0aC9IZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gY29udGFpbmVyJ3Mgd2lkdGgvaGVpZ2h0XG4gICAgICBtaW5Dcm9wQm94V2lkdGggPSBNYXRoLm1pbihtaW5Dcm9wQm94V2lkdGgsIGNvbnRhaW5lckRhdGEud2lkdGgpO1xuICAgICAgbWluQ3JvcEJveEhlaWdodCA9IE1hdGgubWluKG1pbkNyb3BCb3hIZWlnaHQsIGNvbnRhaW5lckRhdGEuaGVpZ2h0KTtcblxuICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChtaW5Dcm9wQm94V2lkdGggJiYgbWluQ3JvcEJveEhlaWdodCkge1xuICAgICAgICAgIGlmIChtaW5Dcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtaW5Dcm9wQm94V2lkdGgpIHtcbiAgICAgICAgICAgIG1pbkNyb3BCb3hIZWlnaHQgPSBtaW5Dcm9wQm94V2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gbWluQ3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtaW5Dcm9wQm94V2lkdGgpIHtcbiAgICAgICAgICBtaW5Dcm9wQm94SGVpZ2h0ID0gbWluQ3JvcEJveFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAobWluQ3JvcEJveEhlaWdodCkge1xuICAgICAgICAgIG1pbkNyb3BCb3hXaWR0aCA9IG1pbkNyb3BCb3hIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhDcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtYXhDcm9wQm94V2lkdGgpIHtcbiAgICAgICAgICBtYXhDcm9wQm94SGVpZ2h0ID0gbWF4Q3JvcEJveFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4Q3JvcEJveFdpZHRoID0gbWF4Q3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBtaW5XaWR0aC9IZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gbWF4V2lkdGgvSGVpZ2h0XG4gICAgICBjcm9wQm94RGF0YS5taW5XaWR0aCA9IE1hdGgubWluKG1pbkNyb3BCb3hXaWR0aCwgbWF4Q3JvcEJveFdpZHRoKTtcbiAgICAgIGNyb3BCb3hEYXRhLm1pbkhlaWdodCA9IE1hdGgubWluKG1pbkNyb3BCb3hIZWlnaHQsIG1heENyb3BCb3hIZWlnaHQpO1xuICAgICAgY3JvcEJveERhdGEubWF4V2lkdGggPSBtYXhDcm9wQm94V2lkdGg7XG4gICAgICBjcm9wQm94RGF0YS5tYXhIZWlnaHQgPSBtYXhDcm9wQm94SGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbkxpbWl0ZWQpIHtcbiAgICAgIGlmIChsaW1pdGVkKSB7XG4gICAgICAgIGNyb3BCb3hEYXRhLm1pbkxlZnQgPSBNYXRoLm1heCgwLCBjYW52YXNEYXRhLmxlZnQpO1xuICAgICAgICBjcm9wQm94RGF0YS5taW5Ub3AgPSBNYXRoLm1heCgwLCBjYW52YXNEYXRhLnRvcCk7XG4gICAgICAgIGNyb3BCb3hEYXRhLm1heExlZnQgPSBNYXRoLm1pbihjb250YWluZXJEYXRhLndpZHRoLCBjYW52YXNEYXRhLmxlZnQgKyBjYW52YXNEYXRhLndpZHRoKSAtIGNyb3BCb3hEYXRhLndpZHRoO1xuICAgICAgICBjcm9wQm94RGF0YS5tYXhUb3AgPSBNYXRoLm1pbihjb250YWluZXJEYXRhLmhlaWdodCwgY2FudmFzRGF0YS50b3AgKyBjYW52YXNEYXRhLmhlaWdodCkgLSBjcm9wQm94RGF0YS5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcm9wQm94RGF0YS5taW5MZWZ0ID0gMDtcbiAgICAgICAgY3JvcEJveERhdGEubWluVG9wID0gMDtcbiAgICAgICAgY3JvcEJveERhdGEubWF4TGVmdCA9IGNvbnRhaW5lckRhdGEud2lkdGggLSBjcm9wQm94RGF0YS53aWR0aDtcbiAgICAgICAgY3JvcEJveERhdGEubWF4VG9wID0gY29udGFpbmVyRGF0YS5oZWlnaHQgLSBjcm9wQm94RGF0YS5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZW5kZXJDcm9wQm94OiBmdW5jdGlvbiByZW5kZXJDcm9wQm94KCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICBjcm9wQm94RGF0YSA9IHRoaXMuY3JvcEJveERhdGE7XG5cblxuICAgIGlmIChjcm9wQm94RGF0YS53aWR0aCA+IGNyb3BCb3hEYXRhLm1heFdpZHRoIHx8IGNyb3BCb3hEYXRhLndpZHRoIDwgY3JvcEJveERhdGEubWluV2lkdGgpIHtcbiAgICAgIGNyb3BCb3hEYXRhLmxlZnQgPSBjcm9wQm94RGF0YS5vbGRMZWZ0O1xuICAgIH1cblxuICAgIGlmIChjcm9wQm94RGF0YS5oZWlnaHQgPiBjcm9wQm94RGF0YS5tYXhIZWlnaHQgfHwgY3JvcEJveERhdGEuaGVpZ2h0IDwgY3JvcEJveERhdGEubWluSGVpZ2h0KSB7XG4gICAgICBjcm9wQm94RGF0YS50b3AgPSBjcm9wQm94RGF0YS5vbGRUb3A7XG4gICAgfVxuXG4gICAgY3JvcEJveERhdGEud2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS53aWR0aCwgY3JvcEJveERhdGEubWluV2lkdGgpLCBjcm9wQm94RGF0YS5tYXhXaWR0aCk7XG4gICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5tYXgoY3JvcEJveERhdGEuaGVpZ2h0LCBjcm9wQm94RGF0YS5taW5IZWlnaHQpLCBjcm9wQm94RGF0YS5tYXhIZWlnaHQpO1xuXG4gICAgdGhpcy5saW1pdENyb3BCb3goZmFsc2UsIHRydWUpO1xuXG4gICAgY3JvcEJveERhdGEubGVmdCA9IE1hdGgubWluKE1hdGgubWF4KGNyb3BCb3hEYXRhLmxlZnQsIGNyb3BCb3hEYXRhLm1pbkxlZnQpLCBjcm9wQm94RGF0YS5tYXhMZWZ0KTtcbiAgICBjcm9wQm94RGF0YS50b3AgPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS50b3AsIGNyb3BCb3hEYXRhLm1pblRvcCksIGNyb3BCb3hEYXRhLm1heFRvcCk7XG4gICAgY3JvcEJveERhdGEub2xkTGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQ7XG4gICAgY3JvcEJveERhdGEub2xkVG9wID0gY3JvcEJveERhdGEudG9wO1xuXG4gICAgaWYgKG9wdGlvbnMubW92YWJsZSAmJiBvcHRpb25zLmNyb3BCb3hNb3ZhYmxlKSB7XG4gICAgICAvLyBUdXJuIHRvIG1vdmUgdGhlIGNhbnZhcyB3aGVuIHRoZSBjcm9wIGJveCBpcyBlcXVhbCB0byB0aGUgY29udGFpbmVyXG4gICAgICBzZXREYXRhKHRoaXMuZmFjZSwgREFUQV9BQ1RJT04sIGNyb3BCb3hEYXRhLndpZHRoID49IGNvbnRhaW5lckRhdGEud2lkdGggJiYgY3JvcEJveERhdGEuaGVpZ2h0ID49IGNvbnRhaW5lckRhdGEuaGVpZ2h0ID8gQUNUSU9OX01PVkUgOiBBQ1RJT05fQUxMKTtcbiAgICB9XG5cbiAgICBzZXRTdHlsZSh0aGlzLmNyb3BCb3gsIGFzc2lnbih7XG4gICAgICB3aWR0aDogY3JvcEJveERhdGEud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNyb3BCb3hEYXRhLmhlaWdodFxuICAgIH0sIGdldFRyYW5zZm9ybXMoe1xuICAgICAgdHJhbnNsYXRlWDogY3JvcEJveERhdGEubGVmdCxcbiAgICAgIHRyYW5zbGF0ZVk6IGNyb3BCb3hEYXRhLnRvcFxuICAgIH0pKSk7XG5cbiAgICBpZiAodGhpcy5jcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xuICAgICAgdGhpcy5saW1pdENhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMub3V0cHV0KCk7XG4gICAgfVxuICB9LFxuICBvdXRwdXQ6IGZ1bmN0aW9uIG91dHB1dCgpIHtcbiAgICB0aGlzLnByZXZpZXcoKTtcbiAgICBkaXNwYXRjaEV2ZW50KHRoaXMuZWxlbWVudCwgRVZFTlRfQ1JPUCwgdGhpcy5nZXREYXRhKCkpO1xuICB9XG59O1xuXG52YXIgcHJldmlldyA9IHtcbiAgaW5pdFByZXZpZXc6IGZ1bmN0aW9uIGluaXRQcmV2aWV3KCkge1xuICAgIHZhciBjcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG4gICAgdmFyIHByZXZpZXcgPSB0aGlzLm9wdGlvbnMucHJldmlldztcblxuICAgIHZhciB1cmwgPSBjcm9zc09yaWdpbiA/IHRoaXMuY3Jvc3NPcmlnaW5VcmwgOiB0aGlzLnVybDtcbiAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICB9XG5cbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgdGhpcy52aWV3Qm94LmFwcGVuZENoaWxkKGltYWdlKTtcbiAgICB0aGlzLnZpZXdCb3hJbWFnZSA9IGltYWdlO1xuXG4gICAgaWYgKCFwcmV2aWV3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByZXZpZXdzID0gcHJldmlldztcblxuICAgIGlmICh0eXBlb2YgcHJldmlldyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByZXZpZXdzID0gdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwcmV2aWV3KTtcbiAgICB9IGVsc2UgaWYgKHByZXZpZXcucXVlcnlTZWxlY3Rvcikge1xuICAgICAgcHJldmlld3MgPSBbcHJldmlld107XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2aWV3cyA9IHByZXZpZXdzO1xuXG4gICAgZm9yRWFjaChwcmV2aWV3cywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgIC8vIFNhdmUgdGhlIG9yaWdpbmFsIHNpemUgZm9yIHJlY292ZXJcbiAgICAgIHNldERhdGEoZWwsIERBVEFfUFJFVklFVywge1xuICAgICAgICB3aWR0aDogZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0LFxuICAgICAgICBodG1sOiBlbC5pbm5lckhUTUxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICB9XG5cbiAgICAgIGltZy5zcmMgPSB1cmw7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGUgaW1nIGVsZW1lbnQgc3R5bGVzXG4gICAgICAgKiBBZGQgYGRpc3BsYXk6YmxvY2tgIHRvIGF2b2lkIG1hcmdpbiB0b3AgaXNzdWVcbiAgICAgICAqIEFkZCBgaGVpZ2h0OmF1dG9gIHRvIG92ZXJyaWRlIGBoZWlnaHRgIGF0dHJpYnV0ZSBvbiBJRThcbiAgICAgICAqIChPY2N1ciBvbmx5IHdoZW4gbWFyZ2luLXRvcCA8PSAtaGVpZ2h0KVxuICAgICAgICovXG4gICAgICBpbWcuc3R5bGUuY3NzVGV4dCA9ICdkaXNwbGF5OmJsb2NrOycgKyAnd2lkdGg6MTAwJTsnICsgJ2hlaWdodDphdXRvOycgKyAnbWluLXdpZHRoOjAhaW1wb3J0YW50OycgKyAnbWluLWhlaWdodDowIWltcG9ydGFudDsnICsgJ21heC13aWR0aDpub25lIWltcG9ydGFudDsnICsgJ21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnQ7JyArICdpbWFnZS1vcmllbnRhdGlvbjowZGVnIWltcG9ydGFudDtcIic7XG5cbiAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9KTtcbiAgfSxcbiAgcmVzZXRQcmV2aWV3OiBmdW5jdGlvbiByZXNldFByZXZpZXcoKSB7XG4gICAgZm9yRWFjaCh0aGlzLnByZXZpZXdzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKGVsZW1lbnQsIERBVEFfUFJFVklFVyk7XG5cbiAgICAgIHNldFN0eWxlKGVsZW1lbnQsIHtcbiAgICAgICAgd2lkdGg6IGRhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YS5oZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGRhdGEuaHRtbDtcbiAgICAgIHJlbW92ZURhdGEoZWxlbWVudCwgREFUQV9QUkVWSUVXKTtcbiAgICB9KTtcbiAgfSxcbiAgcHJldmlldzogZnVuY3Rpb24gcHJldmlldygpIHtcbiAgICB2YXIgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGEsXG4gICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcbiAgICB2YXIgY3JvcEJveFdpZHRoID0gY3JvcEJveERhdGEud2lkdGgsXG4gICAgICAgIGNyb3BCb3hIZWlnaHQgPSBjcm9wQm94RGF0YS5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgdmFyIGxlZnQgPSBjcm9wQm94RGF0YS5sZWZ0IC0gY2FudmFzRGF0YS5sZWZ0IC0gaW1hZ2VEYXRhLmxlZnQ7XG4gICAgdmFyIHRvcCA9IGNyb3BCb3hEYXRhLnRvcCAtIGNhbnZhc0RhdGEudG9wIC0gaW1hZ2VEYXRhLnRvcDtcblxuICAgIGlmICghdGhpcy5jcm9wcGVkIHx8IHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRTdHlsZSh0aGlzLnZpZXdCb3hJbWFnZSwgYXNzaWduKHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSwgZ2V0VHJhbnNmb3Jtcyhhc3NpZ24oe1xuICAgICAgdHJhbnNsYXRlWDogLWxlZnQsXG4gICAgICB0cmFuc2xhdGVZOiAtdG9wXG4gICAgfSwgaW1hZ2VEYXRhKSkpKTtcblxuICAgIGZvckVhY2godGhpcy5wcmV2aWV3cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtZW50LCBEQVRBX1BSRVZJRVcpO1xuICAgICAgdmFyIG9yaWdpbmFsV2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgdmFyIG9yaWdpbmFsSGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgbmV3V2lkdGggPSBvcmlnaW5hbFdpZHRoO1xuICAgICAgdmFyIG5ld0hlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgdmFyIHJhdGlvID0gMTtcblxuICAgICAgaWYgKGNyb3BCb3hXaWR0aCkge1xuICAgICAgICByYXRpbyA9IG9yaWdpbmFsV2lkdGggLyBjcm9wQm94V2lkdGg7XG4gICAgICAgIG5ld0hlaWdodCA9IGNyb3BCb3hIZWlnaHQgKiByYXRpbztcbiAgICAgIH1cblxuICAgICAgaWYgKGNyb3BCb3hIZWlnaHQgJiYgbmV3SGVpZ2h0ID4gb3JpZ2luYWxIZWlnaHQpIHtcbiAgICAgICAgcmF0aW8gPSBvcmlnaW5hbEhlaWdodCAvIGNyb3BCb3hIZWlnaHQ7XG4gICAgICAgIG5ld1dpZHRoID0gY3JvcEJveFdpZHRoICogcmF0aW87XG4gICAgICAgIG5ld0hlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBzZXRTdHlsZShlbGVtZW50LCB7XG4gICAgICAgIHdpZHRoOiBuZXdXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICBzZXRTdHlsZShlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKVswXSwgYXNzaWduKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoICogcmF0aW8sXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICogcmF0aW9cbiAgICAgIH0sIGdldFRyYW5zZm9ybXMoYXNzaWduKHtcbiAgICAgICAgdHJhbnNsYXRlWDogLWxlZnQgKiByYXRpbyxcbiAgICAgICAgdHJhbnNsYXRlWTogLXRvcCAqIHJhdGlvXG4gICAgICB9LCBpbWFnZURhdGEpKSkpO1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZXZlbnRzID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjcm9wcGVyID0gdGhpcy5jcm9wcGVyO1xuXG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BzdGFydCkpIHtcbiAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfU1RBUlQsIG9wdGlvbnMuY3JvcHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3Btb3ZlKSkge1xuICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9NT1ZFLCBvcHRpb25zLmNyb3Btb3ZlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BlbmQpKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX0VORCwgb3B0aW9ucy5jcm9wZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3ApKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QLCBvcHRpb25zLmNyb3ApO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuem9vbSkpIHtcbiAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1pPT00sIG9wdGlvbnMuem9vbSk7XG4gICAgfVxuXG4gICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfUE9JTlRFUl9ET1dOLCB0aGlzLm9uQ3JvcFN0YXJ0ID0gdGhpcy5jcm9wU3RhcnQuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAob3B0aW9ucy56b29tYWJsZSAmJiBvcHRpb25zLnpvb21PbldoZWVsKSB7XG4gICAgICBhZGRMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9XSEVFTCwgdGhpcy5vbldoZWVsID0gdGhpcy53aGVlbC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50b2dnbGVEcmFnTW9kZU9uRGJsY2xpY2spIHtcbiAgICAgIGFkZExpc3RlbmVyKGNyb3BwZXIsIEVWRU5UX0RCTENMSUNLLCB0aGlzLm9uRGJsY2xpY2sgPSB0aGlzLmRibGNsaWNrLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGFkZExpc3RlbmVyKGVsZW1lbnQub3duZXJEb2N1bWVudCwgRVZFTlRfUE9JTlRFUl9NT1ZFLCB0aGlzLm9uQ3JvcE1vdmUgPSB0aGlzLmNyb3BNb3ZlLmJpbmQodGhpcykpO1xuICAgIGFkZExpc3RlbmVyKGVsZW1lbnQub3duZXJEb2N1bWVudCwgRVZFTlRfUE9JTlRFUl9VUCwgdGhpcy5vbkNyb3BFbmQgPSB0aGlzLmNyb3BFbmQuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICBhZGRMaXN0ZW5lcih3aW5kb3csIEVWRU5UX1JFU0laRSwgdGhpcy5vblJlc2l6ZSA9IHRoaXMucmVzaXplLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSxcbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGNyb3BwZXIgPSB0aGlzLmNyb3BwZXI7XG5cblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcHN0YXJ0KSkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9TVEFSVCwgb3B0aW9ucy5jcm9wc3RhcnQpO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcG1vdmUpKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIG9wdGlvbnMuY3JvcG1vdmUpO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcGVuZCkpIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfRU5ELCBvcHRpb25zLmNyb3BlbmQpO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcCkpIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1AsIG9wdGlvbnMuY3JvcCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy56b29tKSkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfWk9PTSwgb3B0aW9ucy56b29tKTtcbiAgICB9XG5cbiAgICByZW1vdmVMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9QT0lOVEVSX0RPV04sIHRoaXMub25Dcm9wU3RhcnQpO1xuXG4gICAgaWYgKG9wdGlvbnMuem9vbWFibGUgJiYgb3B0aW9ucy56b29tT25XaGVlbCkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfV0hFRUwsIHRoaXMub25XaGVlbCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9EQkxDTElDSywgdGhpcy5vbkRibGNsaWNrKTtcbiAgICB9XG5cbiAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50Lm93bmVyRG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfTU9WRSwgdGhpcy5vbkNyb3BNb3ZlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50Lm93bmVyRG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfVVAsIHRoaXMub25Dcm9wRW5kKTtcblxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKHdpbmRvdywgRVZFTlRfUkVTSVpFLCB0aGlzLm9uUmVzaXplKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhO1xuXG4gICAgdmFyIG1pbkNvbnRhaW5lcldpZHRoID0gTnVtYmVyKG9wdGlvbnMubWluQ29udGFpbmVyV2lkdGgpIHx8IDIwMDtcbiAgICB2YXIgbWluQ29udGFpbmVySGVpZ2h0ID0gTnVtYmVyKG9wdGlvbnMubWluQ29udGFpbmVySGVpZ2h0KSB8fCAxMDA7XG5cbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBjb250YWluZXJEYXRhLndpZHRoIDw9IG1pbkNvbnRhaW5lcldpZHRoIHx8IGNvbnRhaW5lckRhdGEuaGVpZ2h0IDw9IG1pbkNvbnRhaW5lckhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByYXRpbyA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIGNvbnRhaW5lckRhdGEud2lkdGg7XG5cbiAgICAvLyBSZXNpemUgd2hlbiB3aWR0aCBjaGFuZ2VkIG9yIGhlaWdodCBjaGFuZ2VkXG4gICAgaWYgKHJhdGlvICE9PSAxIHx8IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgIT09IGNvbnRhaW5lckRhdGEuaGVpZ2h0KSB7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHZvaWQgMDtcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IHZvaWQgMDtcblxuICAgICAgaWYgKG9wdGlvbnMucmVzdG9yZSkge1xuICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5nZXRDYW52YXNEYXRhKCk7XG4gICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5nZXRDcm9wQm94RGF0YSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgICBpZiAob3B0aW9ucy5yZXN0b3JlKSB7XG4gICAgICAgIHRoaXMuc2V0Q2FudmFzRGF0YShmb3JFYWNoKGNhbnZhc0RhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgY2FudmFzRGF0YVtpXSA9IG4gKiByYXRpbztcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnNldENyb3BCb3hEYXRhKGZvckVhY2goY3JvcEJveERhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgY3JvcEJveERhdGFbaV0gPSBuICogcmF0aW87XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRibGNsaWNrOiBmdW5jdGlvbiBkYmxjbGljaygpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLm9wdGlvbnMuZHJhZ01vZGUgPT09IERSQUdfTU9ERV9OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXREcmFnTW9kZShoYXNDbGFzcyh0aGlzLmRyYWdCb3gsIENMQVNTX0NST1ApID8gRFJBR19NT0RFX01PVkUgOiBEUkFHX01PREVfQ1JPUCk7XG4gIH0sXG4gIHdoZWVsOiBmdW5jdGlvbiB3aGVlbChlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciByYXRpbyA9IE51bWJlcih0aGlzLm9wdGlvbnMud2hlZWxab29tUmF0aW8pIHx8IDAuMTtcbiAgICB2YXIgZGVsdGEgPSAxO1xuXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBMaW1pdCB3aGVlbCBzcGVlZCB0byBwcmV2ZW50IHpvb20gdG9vIGZhc3QgKCMyMSlcbiAgICBpZiAodGhpcy53aGVlbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2hlZWxpbmcgPSB0cnVlO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy53aGVlbGluZyA9IGZhbHNlO1xuICAgIH0sIDUwKTtcblxuICAgIGlmIChlLmRlbHRhWSkge1xuICAgICAgZGVsdGEgPSBlLmRlbHRhWSA+IDAgPyAxIDogLTE7XG4gICAgfSBlbHNlIGlmIChlLndoZWVsRGVsdGEpIHtcbiAgICAgIGRlbHRhID0gLWUud2hlZWxEZWx0YSAvIDEyMDtcbiAgICB9IGVsc2UgaWYgKGUuZGV0YWlsKSB7XG4gICAgICBkZWx0YSA9IGUuZGV0YWlsID4gMCA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICB0aGlzLnpvb20oLWRlbHRhICogcmF0aW8sIGUpO1xuICB9LFxuICBjcm9wU3RhcnQ6IGZ1bmN0aW9uIGNyb3BTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xuXG4gICAgdmFyIGFjdGlvbiA9IHZvaWQgMDtcblxuICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAvLyBIYW5kbGUgdG91Y2ggZXZlbnRcbiAgICAgIGZvckVhY2goZS5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgIHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdID0gZ2V0UG9pbnRlcih0b3VjaCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGFuZGxlIG1vdXNlIGV2ZW50IGFuZCBwb2ludGVyIGV2ZW50XG4gICAgICBwb2ludGVyc1tlLnBvaW50ZXJJZCB8fCAwXSA9IGdldFBvaW50ZXIoZSk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHBvaW50ZXJzKS5sZW5ndGggPiAxICYmIG9wdGlvbnMuem9vbWFibGUgJiYgb3B0aW9ucy56b29tT25Ub3VjaCkge1xuICAgICAgYWN0aW9uID0gQUNUSU9OX1pPT007XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGlvbiA9IGdldERhdGEoZS50YXJnZXQsIERBVEFfQUNUSU9OKTtcbiAgICB9XG5cbiAgICBpZiAoIVJFR0VYUF9BQ1RJT05TLnRlc3QoYWN0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkaXNwYXRjaEV2ZW50KHRoaXMuZWxlbWVudCwgRVZFTlRfQ1JPUF9TVEFSVCwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBsaW5lIGlzIHJlcXVpcmVkIGZvciBwcmV2ZW50aW5nIHBhZ2Ugem9vbWluZyBpbiBpT1MgYnJvd3NlcnNcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB0aGlzLmNyb3BwaW5nID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aW9uID09PSBBQ1RJT05fQ1JPUCkge1xuICAgICAgdGhpcy5jcm9wcGluZyA9IHRydWU7XG4gICAgICBhZGRDbGFzcyh0aGlzLmRyYWdCb3gsIENMQVNTX01PREFMKTtcbiAgICB9XG4gIH0sXG4gIGNyb3BNb3ZlOiBmdW5jdGlvbiBjcm9wTW92ZShlKSB7XG4gICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uO1xuXG5cbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcblxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKGRpc3BhdGNoRXZlbnQodGhpcy5lbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICBhY3Rpb246IGFjdGlvblxuICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICBmb3JFYWNoKGUuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICBhc3NpZ24ocG9pbnRlcnNbdG91Y2guaWRlbnRpZmllcl0sIGdldFBvaW50ZXIodG91Y2gsIHRydWUpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ24ocG9pbnRlcnNbZS5wb2ludGVySWQgfHwgMF0sIGdldFBvaW50ZXIoZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlKGUpO1xuICB9LFxuICBjcm9wRW5kOiBmdW5jdGlvbiBjcm9wRW5kKGUpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbixcbiAgICAgICAgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xuXG5cbiAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgZm9yRWFjaChlLmNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgZGVsZXRlIHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBwb2ludGVyc1tlLnBvaW50ZXJJZCB8fCAwXTtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICghT2JqZWN0LmtleXMocG9pbnRlcnMpLmxlbmd0aCkge1xuICAgICAgdGhpcy5hY3Rpb24gPSAnJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jcm9wcGluZykge1xuICAgICAgdGhpcy5jcm9wcGluZyA9IGZhbHNlO1xuICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5kcmFnQm94LCBDTEFTU19NT0RBTCwgdGhpcy5jcm9wcGVkICYmIHRoaXMub3B0aW9ucy5tb2RhbCk7XG4gICAgfVxuXG4gICAgZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX0NST1BfRU5ELCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGNoYW5nZSA9IHtcbiAgY2hhbmdlOiBmdW5jdGlvbiBjaGFuZ2UoZSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICBjcm9wQm94RGF0YSA9IHRoaXMuY3JvcEJveERhdGEsXG4gICAgICAgIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcbiAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpbztcbiAgICB2YXIgbGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQsXG4gICAgICAgIHRvcCA9IGNyb3BCb3hEYXRhLnRvcCxcbiAgICAgICAgd2lkdGggPSBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gY3JvcEJveERhdGEuaGVpZ2h0O1xuXG4gICAgdmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgIHZhciBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgdmFyIG1pbkxlZnQgPSAwO1xuICAgIHZhciBtaW5Ub3AgPSAwO1xuICAgIHZhciBtYXhXaWR0aCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XG4gICAgdmFyIG1heEhlaWdodCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0O1xuICAgIHZhciByZW5kZXJhYmxlID0gdHJ1ZTtcbiAgICB2YXIgb2Zmc2V0ID0gdm9pZCAwO1xuXG4gICAgLy8gTG9ja2luZyBhc3BlY3QgcmF0aW8gaW4gXCJmcmVlIG1vZGVcIiBieSBob2xkaW5nIHNoaWZ0IGtleVxuICAgIGlmICghYXNwZWN0UmF0aW8gJiYgZS5zaGlmdEtleSkge1xuICAgICAgYXNwZWN0UmF0aW8gPSB3aWR0aCAmJiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IDE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGltaXRlZCkge1xuICAgICAgbWluTGVmdCA9IGNyb3BCb3hEYXRhLm1pbkxlZnQ7XG4gICAgICBtaW5Ub3AgPSBjcm9wQm94RGF0YS5taW5Ub3A7XG5cbiAgICAgIG1heFdpZHRoID0gbWluTGVmdCArIE1hdGgubWluKGNvbnRhaW5lckRhdGEud2lkdGgsIGNhbnZhc0RhdGEud2lkdGgsIGNhbnZhc0RhdGEubGVmdCArIGNhbnZhc0RhdGEud2lkdGgpO1xuICAgICAgbWF4SGVpZ2h0ID0gbWluVG9wICsgTWF0aC5taW4oY29udGFpbmVyRGF0YS5oZWlnaHQsIGNhbnZhc0RhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLnRvcCArIGNhbnZhc0RhdGEuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRlciA9IHBvaW50ZXJzW09iamVjdC5rZXlzKHBvaW50ZXJzKVswXV07XG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgeDogcG9pbnRlci5lbmRYIC0gcG9pbnRlci5zdGFydFgsXG4gICAgICB5OiBwb2ludGVyLmVuZFkgLSBwb2ludGVyLnN0YXJ0WVxuICAgIH07XG4gICAgdmFyIGNoZWNrID0gZnVuY3Rpb24gY2hlY2soc2lkZSkge1xuICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgQUNUSU9OX0VBU1Q6XG4gICAgICAgICAgaWYgKHJpZ2h0ICsgcmFuZ2UueCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICByYW5nZS54ID0gbWF4V2lkdGggLSByaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9XRVNUOlxuICAgICAgICAgIGlmIChsZWZ0ICsgcmFuZ2UueCA8IG1pbkxlZnQpIHtcbiAgICAgICAgICAgIHJhbmdlLnggPSBtaW5MZWZ0IC0gbGVmdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9OT1JUSDpcbiAgICAgICAgICBpZiAodG9wICsgcmFuZ2UueSA8IG1pblRvcCkge1xuICAgICAgICAgICAgcmFuZ2UueSA9IG1pblRvcCAtIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSDpcbiAgICAgICAgICBpZiAoYm90dG9tICsgcmFuZ2UueSA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgcmFuZ2UueSA9IG1heEhlaWdodCAtIGJvdHRvbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH07XG5cbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgLy8gTW92ZSBjcm9wIGJveFxuICAgICAgY2FzZSBBQ1RJT05fQUxMOlxuICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gUmVzaXplIGNyb3AgYm94XG4gICAgICBjYXNlIEFDVElPTl9FQVNUOlxuICAgICAgICBpZiAocmFuZ2UueCA+PSAwICYmIChyaWdodCA+PSBtYXhXaWR0aCB8fCBhc3BlY3RSYXRpbyAmJiAodG9wIDw9IG1pblRvcCB8fCBib3R0b20gPj0gbWF4SGVpZ2h0KSkpIHtcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjaGVjayhBQ1RJT05fRUFTVCk7XG4gICAgICAgIHdpZHRoICs9IHJhbmdlLng7XG5cbiAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9XRVNUO1xuICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIHRvcCArPSAoY3JvcEJveERhdGEuaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBBQ1RJT05fTk9SVEg6XG4gICAgICAgIGlmIChyYW5nZS55IDw9IDAgJiYgKHRvcCA8PSBtaW5Ub3AgfHwgYXNwZWN0UmF0aW8gJiYgKGxlZnQgPD0gbWluTGVmdCB8fCByaWdodCA+PSBtYXhXaWR0aCkpKSB7XG4gICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2soQUNUSU9OX05PUlRIKTtcbiAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgIHRvcCArPSByYW5nZS55O1xuXG4gICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgbGVmdCArPSAoY3JvcEJveERhdGEud2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQUNUSU9OX1dFU1Q6XG4gICAgICAgIGlmIChyYW5nZS54IDw9IDAgJiYgKGxlZnQgPD0gbWluTGVmdCB8fCBhc3BlY3RSYXRpbyAmJiAodG9wIDw9IG1pblRvcCB8fCBib3R0b20gPj0gbWF4SGVpZ2h0KSkpIHtcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XG4gICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgIGxlZnQgKz0gcmFuZ2UueDtcblxuICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX0VBU1Q7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgdG9wICs9IChjcm9wQm94RGF0YS5oZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEFDVElPTl9TT1VUSDpcbiAgICAgICAgaWYgKHJhbmdlLnkgPj0gMCAmJiAoYm90dG9tID49IG1heEhlaWdodCB8fCBhc3BlY3RSYXRpbyAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IHJpZ2h0ID49IG1heFdpZHRoKSkpIHtcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjaGVjayhBQ1RJT05fU09VVEgpO1xuICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcblxuICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSDtcbiAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIGxlZnQgKz0gKGNyb3BCb3hEYXRhLndpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEFDVElPTl9OT1JUSF9FQVNUOlxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBpZiAocmFuZ2UueSA8PSAwICYmICh0b3AgPD0gbWluVG9wIHx8IHJpZ2h0ID49IG1heFdpZHRoKSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hlY2soQUNUSU9OX05PUlRIKTtcbiAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgY2hlY2soQUNUSU9OX0VBU1QpO1xuXG4gICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCkge1xuICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA8PSAwICYmIHRvcCA8PSBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZS55IDw9IDApIHtcbiAgICAgICAgICAgIGlmICh0b3AgPiBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aWR0aCA8IDAgJiYgaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9XRVNUO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9XRVNUO1xuICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEFDVElPTl9OT1JUSF9XRVNUOlxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBpZiAocmFuZ2UueSA8PSAwICYmICh0b3AgPD0gbWluVG9wIHx8IGxlZnQgPD0gbWluTGVmdCkpIHtcbiAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICBsZWZ0ICs9IGNyb3BCb3hEYXRhLndpZHRoIC0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2soQUNUSU9OX05PUlRIKTtcbiAgICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XG5cbiAgICAgICAgICBpZiAocmFuZ2UueCA8PSAwKSB7XG4gICAgICAgICAgICBpZiAobGVmdCA+IG1pbkxlZnQpIHtcbiAgICAgICAgICAgICAgd2lkdGggLT0gcmFuZ2UueDtcbiAgICAgICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS55IDw9IDAgJiYgdG9wIDw9IG1pblRvcCkge1xuICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCkge1xuICAgICAgICAgICAgaWYgKHRvcCA+IG1pblRvcCkge1xuICAgICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCAtPSByYW5nZS55O1xuICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX0VBU1Q7XG4gICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX0VBU1Q7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX1dFU1Q7XG4gICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQUNUSU9OX1NPVVRIX1dFU1Q6XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgIGlmIChyYW5nZS54IDw9IDAgJiYgKGxlZnQgPD0gbWluTGVmdCB8fCBib3R0b20gPj0gbWF4SGVpZ2h0KSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hlY2soQUNUSU9OX1dFU1QpO1xuICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2soQUNUSU9OX1NPVVRIKTtcbiAgICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XG5cbiAgICAgICAgICBpZiAocmFuZ2UueCA8PSAwKSB7XG4gICAgICAgICAgICBpZiAobGVmdCA+IG1pbkxlZnQpIHtcbiAgICAgICAgICAgICAgd2lkdGggLT0gcmFuZ2UueDtcbiAgICAgICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS55ID49IDAgJiYgYm90dG9tID49IG1heEhlaWdodCkge1xuICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJhbmdlLnkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGJvdHRvbSA8IG1heEhlaWdodCkge1xuICAgICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHJhbmdlLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX0VBU1Q7XG4gICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX0VBU1Q7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX1dFU1Q7XG4gICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQUNUSU9OX1NPVVRIX0VBU1Q6XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgIGlmIChyYW5nZS54ID49IDAgJiYgKHJpZ2h0ID49IG1heFdpZHRoIHx8IGJvdHRvbSA+PSBtYXhIZWlnaHQpKSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGVjayhBQ1RJT05fRUFTVCk7XG4gICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcbiAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrKEFDVElPTl9TT1VUSCk7XG4gICAgICAgICAgY2hlY2soQUNUSU9OX0VBU1QpO1xuXG4gICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCkge1xuICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA+PSAwICYmIGJvdHRvbSA+PSBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZS55ID49IDApIHtcbiAgICAgICAgICAgIGlmIChib3R0b20gPCBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgaGVpZ2h0ICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCArPSByYW5nZS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aWR0aCA8IDAgJiYgaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9XRVNUO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9XRVNUO1xuICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBNb3ZlIGNhbnZhc1xuICAgICAgY2FzZSBBQ1RJT05fTU9WRTpcbiAgICAgICAgdGhpcy5tb3ZlKHJhbmdlLngsIHJhbmdlLnkpO1xuICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBab29tIGNhbnZhc1xuICAgICAgY2FzZSBBQ1RJT05fWk9PTTpcbiAgICAgICAgdGhpcy56b29tKGdldE1heFpvb21SYXRpbyhwb2ludGVycyksIGUpO1xuICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBDcmVhdGUgY3JvcCBib3hcbiAgICAgIGNhc2UgQUNUSU9OX0NST1A6XG4gICAgICAgIGlmICghcmFuZ2UueCB8fCAhcmFuZ2UueSkge1xuICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCA9IGdldE9mZnNldCh0aGlzLmNyb3BwZXIpO1xuICAgICAgICBsZWZ0ID0gcG9pbnRlci5zdGFydFggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgdG9wID0gcG9pbnRlci5zdGFydFkgLSBvZmZzZXQudG9wO1xuICAgICAgICB3aWR0aCA9IGNyb3BCb3hEYXRhLm1pbldpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjcm9wQm94RGF0YS5taW5IZWlnaHQ7XG5cbiAgICAgICAgaWYgKHJhbmdlLnggPiAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gcmFuZ2UueSA+IDAgPyBBQ1RJT05fU09VVEhfRUFTVCA6IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnggPCAwKSB7XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBhY3Rpb24gPSByYW5nZS55ID4gMCA/IEFDVElPTl9TT1VUSF9XRVNUIDogQUNUSU9OX05PUlRIX1dFU1Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmFuZ2UueSA8IDApIHtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdyB0aGUgY3JvcCBib3ggaWYgaXMgaGlkZGVuXG4gICAgICAgIGlmICghdGhpcy5jcm9wcGVkKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xuICAgICAgICAgIHRoaXMuY3JvcHBlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5saW1pdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICBpZiAocmVuZGVyYWJsZSkge1xuICAgICAgY3JvcEJveERhdGEud2lkdGggPSB3aWR0aDtcbiAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGNyb3BCb3hEYXRhLmxlZnQgPSBsZWZ0O1xuICAgICAgY3JvcEJveERhdGEudG9wID0gdG9wO1xuICAgICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgICB0aGlzLnJlbmRlckNyb3BCb3goKTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZVxuICAgIGZvckVhY2gocG9pbnRlcnMsIGZ1bmN0aW9uIChwKSB7XG4gICAgICBwLnN0YXJ0WCA9IHAuZW5kWDtcbiAgICAgIHAuc3RhcnRZID0gcC5lbmRZO1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gU2hvdyB0aGUgY3JvcCBib3ggbWFudWFsbHlcbiAgY3JvcDogZnVuY3Rpb24gY3JvcCgpIHtcbiAgICBpZiAodGhpcy5yZWFkeSAmJiAhdGhpcy5jcm9wcGVkICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmNyb3BwZWQgPSB0cnVlO1xuICAgICAgdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubW9kYWwpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5kcmFnQm94LCBDTEFTU19NT0RBTCk7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuY3JvcEJveCwgQ0xBU1NfSElEREVOKTtcbiAgICAgIHRoaXMuc2V0Q3JvcEJveERhdGEodGhpcy5pbml0aWFsQ3JvcEJveERhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLy8gUmVzZXQgdGhlIGltYWdlIGFuZCBjcm9wIGJveCB0byB0aGVpciBpbml0aWFsIHN0YXRlc1xuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuaW1hZ2VEYXRhID0gYXNzaWduKHt9LCB0aGlzLmluaXRpYWxJbWFnZURhdGEpO1xuICAgICAgdGhpcy5jYW52YXNEYXRhID0gYXNzaWduKHt9LCB0aGlzLmluaXRpYWxDYW52YXNEYXRhKTtcbiAgICAgIHRoaXMuY3JvcEJveERhdGEgPSBhc3NpZ24oe30sIHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhKTtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKCk7XG5cbiAgICAgIGlmICh0aGlzLmNyb3BwZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvLyBDbGVhciB0aGUgY3JvcCBib3hcbiAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLmNyb3BwZWQgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIGFzc2lnbih0aGlzLmNyb3BCb3hEYXRhLCB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY3JvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICB0aGlzLmxpbWl0Q2FudmFzKHRydWUsIHRydWUpO1xuXG4gICAgICAvLyBSZW5kZXIgY2FudmFzIGFmdGVyIGNyb3AgYm94IHJlbmRlcmVkXG4gICAgICB0aGlzLnJlbmRlckNhbnZhcygpO1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5kcmFnQm94LCBDTEFTU19NT0RBTCk7XG4gICAgICBhZGRDbGFzcyh0aGlzLmNyb3BCb3gsIENMQVNTX0hJRERFTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgaW1hZ2UncyBzcmMgYW5kIHJlYnVpbGQgdGhlIGNyb3BwZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBuZXcgVVJMLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNTYW1lU2l6ZV0gLSBJbmRpY2F0ZSBpZiB0aGUgbmV3IGltYWdlIGhhcyB0aGUgc2FtZSBzaXplIGFzIHRoZSBvbGQgb25lLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZSh1cmwpIHtcbiAgICB2YXIgaGFzU2FtZVNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHVybCkge1xuICAgICAgaWYgKHRoaXMuaXNJbWcpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNyYyA9IHVybDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1NhbWVTaXplKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmltYWdlLnNyYyA9IHVybDtcblxuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICAgIHRoaXMudmlld0JveEltYWdlLnNyYyA9IHVybDtcblxuICAgICAgICAgIGZvckVhY2godGhpcy5wcmV2aWV3cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpWzBdLnNyYyA9IHVybDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbWcpIHtcbiAgICAgICAgICB0aGlzLnJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy5kYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLmxvYWQodXJsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8vIEVuYWJsZSAodW5mcmVlemUpIHRoZSBjcm9wcGVyXG4gIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuY3JvcHBlciwgQ0xBU1NfRElTQUJMRUQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLy8gRGlzYWJsZSAoZnJlZXplKSB0aGUgY3JvcHBlclxuICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIGFkZENsYXNzKHRoaXMuY3JvcHBlciwgQ0xBU1NfRElTQUJMRUQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGNyb3BwZXIgYW5kIHJlbW92ZSB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgaW1hZ2VcbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cblxuICAgIGlmICghZ2V0RGF0YShlbGVtZW50LCBOQU1FU1BBQ0UpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0ltZyAmJiB0aGlzLnJlcGxhY2VkKSB7XG4gICAgICBlbGVtZW50LnNyYyA9IHRoaXMub3JpZ2luYWxVcmw7XG4gICAgfVxuXG4gICAgdGhpcy51bmNyZWF0ZSgpO1xuICAgIHJlbW92ZURhdGEoZWxlbWVudCwgTkFNRVNQQUNFKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGNhbnZhcyB3aXRoIHJlbGF0aXZlIG9mZnNldHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBUaGUgcmVsYXRpdmUgb2Zmc2V0IGRpc3RhbmNlIG9uIHRoZSB4LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0WT1vZmZzZXRYXSAtIFRoZSByZWxhdGl2ZSBvZmZzZXQgZGlzdGFuY2Ugb24gdGhlIHktYXhpcy5cbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIG1vdmU6IGZ1bmN0aW9uIG1vdmUob2Zmc2V0WCkge1xuICAgIHZhciBvZmZzZXRZID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBvZmZzZXRYO1xuICAgIHZhciBfY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgICAgbGVmdCA9IF9jYW52YXNEYXRhLmxlZnQsXG4gICAgICAgIHRvcCA9IF9jYW52YXNEYXRhLnRvcDtcblxuXG4gICAgcmV0dXJuIHRoaXMubW92ZVRvKGlzVW5kZWZpbmVkKG9mZnNldFgpID8gb2Zmc2V0WCA6IGxlZnQgKyBOdW1iZXIob2Zmc2V0WCksIGlzVW5kZWZpbmVkKG9mZnNldFkpID8gb2Zmc2V0WSA6IHRvcCArIE51bWJlcihvZmZzZXRZKSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogTW92ZSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIHBvaW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHgtYXhpcyBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9eF0gLSBUaGUgeS1heGlzIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uIG1vdmVUbyh4KSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHg7XG4gICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG5cbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgeCA9IE51bWJlcih4KTtcbiAgICB5ID0gTnVtYmVyKHkpO1xuXG4gICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5vcHRpb25zLm1vdmFibGUpIHtcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICBjYW52YXNEYXRhLmxlZnQgPSB4O1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIGNhbnZhc0RhdGEudG9wID0geTtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFpvb20gdGhlIGNhbnZhcyB3aXRoIGEgcmVsYXRpdmUgcmF0aW9cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIC0gVGhlIHRhcmdldCByYXRpby5cbiAgICogQHBhcmFtIHtFdmVudH0gX29yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgZXZlbnQgaWYgYW55LlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgem9vbTogZnVuY3Rpb24gem9vbShyYXRpbywgX29yaWdpbmFsRXZlbnQpIHtcbiAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcblxuXG4gICAgcmF0aW8gPSBOdW1iZXIocmF0aW8pO1xuXG4gICAgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgcmF0aW8gPSAxIC8gKDEgLSByYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvID0gMSArIHJhdGlvO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnpvb21UbyhjYW52YXNEYXRhLndpZHRoICogcmF0aW8gLyBjYW52YXNEYXRhLm5hdHVyYWxXaWR0aCwgbnVsbCwgX29yaWdpbmFsRXZlbnQpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFpvb20gdGhlIGNhbnZhcyB0byBhbiBhYnNvbHV0ZSByYXRpb1xuICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gLSBUaGUgdGFyZ2V0IHJhdGlvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGl2b3QgLSBUaGUgem9vbSBwaXZvdCBwb2ludCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBfb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBldmVudCBpZiBhbnkuXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICB6b29tVG86IGZ1bmN0aW9uIHpvb21UbyhyYXRpbywgcGl2b3QsIF9vcmlnaW5hbEV2ZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgdmFyIHdpZHRoID0gY2FudmFzRGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gY2FudmFzRGF0YS5oZWlnaHQsXG4gICAgICAgIG5hdHVyYWxXaWR0aCA9IGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoLFxuICAgICAgICBuYXR1cmFsSGVpZ2h0ID0gY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0O1xuXG5cbiAgICByYXRpbyA9IE51bWJlcihyYXRpbyk7XG5cbiAgICBpZiAocmF0aW8gPj0gMCAmJiB0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIG9wdGlvbnMuem9vbWFibGUpIHtcbiAgICAgIHZhciBuZXdXaWR0aCA9IG5hdHVyYWxXaWR0aCAqIHJhdGlvO1xuICAgICAgdmFyIG5ld0hlaWdodCA9IG5hdHVyYWxIZWlnaHQgKiByYXRpbztcblxuICAgICAgaWYgKGRpc3BhdGNoRXZlbnQodGhpcy5lbGVtZW50LCBFVkVOVF9aT09NLCB7XG4gICAgICAgIHJhdGlvOiByYXRpbyxcbiAgICAgICAgb2xkUmF0aW86IHdpZHRoIC8gbmF0dXJhbFdpZHRoLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBfb3JpZ2luYWxFdmVudFxuICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoX29yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHRoaXMuY3JvcHBlcik7XG4gICAgICAgIHZhciBjZW50ZXIgPSBwb2ludGVycyAmJiBPYmplY3Qua2V5cyhwb2ludGVycykubGVuZ3RoID8gZ2V0UG9pbnRlcnNDZW50ZXIocG9pbnRlcnMpIDoge1xuICAgICAgICAgIHBhZ2VYOiBfb3JpZ2luYWxFdmVudC5wYWdlWCxcbiAgICAgICAgICBwYWdlWTogX29yaWdpbmFsRXZlbnQucGFnZVlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBab29tIGZyb20gdGhlIHRyaWdnZXJpbmcgcG9pbnQgb2YgdGhlIGV2ZW50XG4gICAgICAgIGNhbnZhc0RhdGEubGVmdCAtPSAobmV3V2lkdGggLSB3aWR0aCkgKiAoKGNlbnRlci5wYWdlWCAtIG9mZnNldC5sZWZ0IC0gY2FudmFzRGF0YS5sZWZ0KSAvIHdpZHRoKTtcbiAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgKiAoKGNlbnRlci5wYWdlWSAtIG9mZnNldC50b3AgLSBjYW52YXNEYXRhLnRvcCkgLyBoZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHBpdm90KSAmJiBpc051bWJlcihwaXZvdC54KSAmJiBpc051bWJlcihwaXZvdC55KSkge1xuICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpICogKChwaXZvdC54IC0gY2FudmFzRGF0YS5sZWZ0KSAvIHdpZHRoKTtcbiAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgKiAoKHBpdm90LnkgLSBjYW52YXNEYXRhLnRvcCkgLyBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gWm9vbSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhc1xuICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgfVxuXG4gICAgICBjYW52YXNEYXRhLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjYW52YXNEYXRhLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgY2FudmFzIHdpdGggYSByZWxhdGl2ZSBkZWdyZWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZSAtIFRoZSByb3RhdGUgZGVncmVlLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgcm90YXRlOiBmdW5jdGlvbiByb3RhdGUoZGVncmVlKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlVG8oKHRoaXMuaW1hZ2VEYXRhLnJvdGF0ZSB8fCAwKSArIE51bWJlcihkZWdyZWUpKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSb3RhdGUgdGhlIGNhbnZhcyB0byBhbiBhYnNvbHV0ZSBkZWdyZWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZSAtIFRoZSByb3RhdGUgZGVncmVlLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgcm90YXRlVG86IGZ1bmN0aW9uIHJvdGF0ZVRvKGRlZ3JlZSkge1xuICAgIGRlZ3JlZSA9IE51bWJlcihkZWdyZWUpO1xuXG4gICAgaWYgKGlzTnVtYmVyKGRlZ3JlZSkgJiYgdGhpcy5yZWFkeSAmJiAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLm9wdGlvbnMucm90YXRhYmxlKSB7XG4gICAgICB0aGlzLmltYWdlRGF0YS5yb3RhdGUgPSBkZWdyZWUgJSAzNjA7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGUgaW1hZ2Ugb24gdGhlIHgtYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWCAtIFRoZSBzY2FsZSByYXRpbyBvbiB0aGUgeC1heGlzLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgc2NhbGVYOiBmdW5jdGlvbiBzY2FsZVgoX3NjYWxlWCkge1xuICAgIHZhciBzY2FsZVkgPSB0aGlzLmltYWdlRGF0YS5zY2FsZVk7XG5cblxuICAgIHJldHVybiB0aGlzLnNjYWxlKF9zY2FsZVgsIGlzTnVtYmVyKHNjYWxlWSkgPyBzY2FsZVkgOiAxKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGUgaW1hZ2Ugb24gdGhlIHktYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWSAtIFRoZSBzY2FsZSByYXRpbyBvbiB0aGUgeS1heGlzLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgc2NhbGVZOiBmdW5jdGlvbiBzY2FsZVkoX3NjYWxlWSkge1xuICAgIHZhciBzY2FsZVggPSB0aGlzLmltYWdlRGF0YS5zY2FsZVg7XG5cblxuICAgIHJldHVybiB0aGlzLnNjYWxlKGlzTnVtYmVyKHNjYWxlWCkgPyBzY2FsZVggOiAxLCBfc2NhbGVZKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGUgaW1hZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWCAtIFRoZSBzY2FsZSByYXRpbyBvbiB0aGUgeC1heGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWT1zY2FsZVhdIC0gVGhlIHNjYWxlIHJhdGlvIG9uIHRoZSB5LWF4aXMuXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICBzY2FsZTogZnVuY3Rpb24gc2NhbGUoc2NhbGVYKSB7XG4gICAgdmFyIHNjYWxlWSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogc2NhbGVYO1xuICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcblxuICAgIHZhciB0cmFuc2Zvcm1lZCA9IGZhbHNlO1xuXG4gICAgc2NhbGVYID0gTnVtYmVyKHNjYWxlWCk7XG4gICAgc2NhbGVZID0gTnVtYmVyKHNjYWxlWSk7XG5cbiAgICBpZiAodGhpcy5yZWFkeSAmJiAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLm9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgIGlmIChpc051bWJlcihzY2FsZVgpKSB7XG4gICAgICAgIGltYWdlRGF0YS5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgIHRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtYmVyKHNjYWxlWSkpIHtcbiAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgdHJhbnNmb3JtZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogR2V0IHRoZSBjcm9wcGVkIGFyZWEgcG9zaXRpb24gYW5kIHNpemUgZGF0YSAoYmFzZSBvbiB0aGUgb3JpZ2luYWwgaW1hZ2UpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JvdW5kZWQ9ZmFsc2VdIC0gSW5kaWNhdGUgaWYgcm91bmQgdGhlIGRhdGEgdmFsdWVzIG9yIG5vdC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBjcm9wcGVkIGRhdGEuXG4gICAqL1xuICBnZXREYXRhOiBmdW5jdGlvbiBnZXREYXRhJCQxKCkge1xuICAgIHZhciByb3VuZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGEsXG4gICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcblxuICAgIHZhciBkYXRhID0gdm9pZCAwO1xuXG4gICAgaWYgKHRoaXMucmVhZHkgJiYgdGhpcy5jcm9wcGVkKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICB4OiBjcm9wQm94RGF0YS5sZWZ0IC0gY2FudmFzRGF0YS5sZWZ0LFxuICAgICAgICB5OiBjcm9wQm94RGF0YS50b3AgLSBjYW52YXNEYXRhLnRvcCxcbiAgICAgICAgd2lkdGg6IGNyb3BCb3hEYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNyb3BCb3hEYXRhLmhlaWdodFxuICAgICAgfTtcblxuICAgICAgdmFyIHJhdGlvID0gaW1hZ2VEYXRhLndpZHRoIC8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aDtcblxuICAgICAgZm9yRWFjaChkYXRhLCBmdW5jdGlvbiAobiwgaSkge1xuICAgICAgICBkYXRhW2ldID0gbiAvIHJhdGlvO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyb3VuZGVkKSB7XG4gICAgICAgIC8vIEluIGNhc2Ugcm91bmRpbmcgb2ZmIGxlYWRzIHRvIGV4dHJhIDFweCBpbiByaWdodCBvciBib3R0b20gYm9yZGVyXG4gICAgICAgIC8vIHdlIHNob3VsZCByb3VuZCB0aGUgdG9wLWxlZnQgY29ybmVyIGFuZCB0aGUgZGltZW5zaW9uICgjMzQzKS5cbiAgICAgICAgdmFyIGJvdHRvbSA9IE1hdGgucm91bmQoZGF0YS55ICsgZGF0YS5oZWlnaHQpO1xuICAgICAgICB2YXIgcmlnaHQgPSBNYXRoLnJvdW5kKGRhdGEueCArIGRhdGEud2lkdGgpO1xuXG4gICAgICAgIGRhdGEueCA9IE1hdGgucm91bmQoZGF0YS54KTtcbiAgICAgICAgZGF0YS55ID0gTWF0aC5yb3VuZChkYXRhLnkpO1xuICAgICAgICBkYXRhLndpZHRoID0gcmlnaHQgLSBkYXRhLng7XG4gICAgICAgIGRhdGEuaGVpZ2h0ID0gYm90dG9tIC0gZGF0YS55O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJvdGF0YWJsZSkge1xuICAgICAgZGF0YS5yb3RhdGUgPSBpbWFnZURhdGEucm90YXRlIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgIGRhdGEuc2NhbGVYID0gaW1hZ2VEYXRhLnNjYWxlWCB8fCAxO1xuICAgICAgZGF0YS5zY2FsZVkgPSBpbWFnZURhdGEuc2NhbGVZIHx8IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cblxuICAvKipcbiAgICogU2V0IHRoZSBjcm9wcGVkIGFyZWEgcG9zaXRpb24gYW5kIHNpemUgd2l0aCBuZXcgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBuZXcgZGF0YS5cbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEkJDEoZGF0YSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YSxcbiAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcblxuICAgIHZhciBjcm9wQm94RGF0YSA9IHt9O1xuXG4gICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgdmFyIHRyYW5zZm9ybWVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChvcHRpb25zLnJvdGF0YWJsZSkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5yb3RhdGUpICYmIGRhdGEucm90YXRlICE9PSBpbWFnZURhdGEucm90YXRlKSB7XG4gICAgICAgICAgaW1hZ2VEYXRhLnJvdGF0ZSA9IGRhdGEucm90YXRlO1xuICAgICAgICAgIHRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5zY2FsZVgpICYmIGRhdGEuc2NhbGVYICE9PSBpbWFnZURhdGEuc2NhbGVYKSB7XG4gICAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWCA9IGRhdGEuc2NhbGVYO1xuICAgICAgICAgIHRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLnNjYWxlWSkgJiYgZGF0YS5zY2FsZVkgIT09IGltYWdlRGF0YS5zY2FsZVkpIHtcbiAgICAgICAgICBpbWFnZURhdGEuc2NhbGVZID0gZGF0YS5zY2FsZVk7XG4gICAgICAgICAgdHJhbnNmb3JtZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhdGlvID0gaW1hZ2VEYXRhLndpZHRoIC8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aDtcblxuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEueCkpIHtcbiAgICAgICAgY3JvcEJveERhdGEubGVmdCA9IGRhdGEueCAqIHJhdGlvICsgY2FudmFzRGF0YS5sZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1iZXIoZGF0YS55KSkge1xuICAgICAgICBjcm9wQm94RGF0YS50b3AgPSBkYXRhLnkgKiByYXRpbyArIGNhbnZhc0RhdGEudG9wO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1iZXIoZGF0YS53aWR0aCkpIHtcbiAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBkYXRhLndpZHRoICogcmF0aW87XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bWJlcihkYXRhLmhlaWdodCkpIHtcbiAgICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgKiByYXRpbztcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRDcm9wQm94RGF0YShjcm9wQm94RGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogR2V0IHRoZSBjb250YWluZXIgc2l6ZSBkYXRhLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNvbnRhaW5lciBkYXRhLlxuICAgKi9cbiAgZ2V0Q29udGFpbmVyRGF0YTogZnVuY3Rpb24gZ2V0Q29udGFpbmVyRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkeSA/IGFzc2lnbih7fSwgdGhpcy5jb250YWluZXJEYXRhKSA6IHt9O1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgcG9zaXRpb24gYW5kIHNpemUgZGF0YS5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBpbWFnZSBkYXRhLlxuICAgKi9cbiAgZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbiBnZXRJbWFnZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZWQgPyBhc3NpZ24oe30sIHRoaXMuaW1hZ2VEYXRhKSA6IHt9O1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2FudmFzIHBvc2l0aW9uIGFuZCBzaXplIGRhdGEuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgY2FudmFzIGRhdGEuXG4gICAqL1xuICBnZXRDYW52YXNEYXRhOiBmdW5jdGlvbiBnZXRDYW52YXNEYXRhKCkge1xuICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xuXG4gICAgdmFyIGRhdGEgPSB7fTtcblxuICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICBmb3JFYWNoKFsnbGVmdCcsICd0b3AnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ25hdHVyYWxXaWR0aCcsICduYXR1cmFsSGVpZ2h0J10sIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGRhdGFbbl0gPSBjYW52YXNEYXRhW25dO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cblxuICAvKipcbiAgICogU2V0IHRoZSBjYW52YXMgcG9zaXRpb24gYW5kIHNpemUgd2l0aCBuZXcgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGNhbnZhcyBkYXRhLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgc2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gc2V0Q2FudmFzRGF0YShkYXRhKSB7XG4gICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gY2FudmFzRGF0YS5hc3BlY3RSYXRpbztcblxuXG4gICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEubGVmdCkpIHtcbiAgICAgICAgY2FudmFzRGF0YS5sZWZ0ID0gZGF0YS5sZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1iZXIoZGF0YS50b3ApKSB7XG4gICAgICAgIGNhbnZhc0RhdGEudG9wID0gZGF0YS50b3A7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bWJlcihkYXRhLndpZHRoKSkge1xuICAgICAgICBjYW52YXNEYXRhLndpZHRoID0gZGF0YS53aWR0aDtcbiAgICAgICAgY2FudmFzRGF0YS5oZWlnaHQgPSBkYXRhLndpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xuICAgICAgICBjYW52YXNEYXRhLmhlaWdodCA9IGRhdGEuaGVpZ2h0O1xuICAgICAgICBjYW52YXNEYXRhLndpZHRoID0gZGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJDYW52YXModHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogR2V0IHRoZSBjcm9wIGJveCBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNyb3AgYm94IGRhdGEuXG4gICAqL1xuICBnZXRDcm9wQm94RGF0YTogZnVuY3Rpb24gZ2V0Q3JvcEJveERhdGEoKSB7XG4gICAgdmFyIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcblxuICAgIHZhciBkYXRhID0gdm9pZCAwO1xuXG4gICAgaWYgKHRoaXMucmVhZHkgJiYgdGhpcy5jcm9wcGVkKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICBsZWZ0OiBjcm9wQm94RGF0YS5sZWZ0LFxuICAgICAgICB0b3A6IGNyb3BCb3hEYXRhLnRvcCxcbiAgICAgICAgd2lkdGg6IGNyb3BCb3hEYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNyb3BCb3hEYXRhLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSB8fCB7fTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNyb3AgYm94IHBvc2l0aW9uIGFuZCBzaXplIHdpdGggbmV3IGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIG5ldyBjcm9wIGJveCBkYXRhLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgc2V0Q3JvcEJveERhdGE6IGZ1bmN0aW9uIHNldENyb3BCb3hEYXRhKGRhdGEpIHtcbiAgICB2YXIgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IHRoaXMub3B0aW9ucy5hc3BlY3RSYXRpbztcblxuICAgIHZhciB3aWR0aENoYW5nZWQgPSB2b2lkIDA7XG4gICAgdmFyIGhlaWdodENoYW5nZWQgPSB2b2lkIDA7XG5cbiAgICBpZiAodGhpcy5yZWFkeSAmJiB0aGlzLmNyb3BwZWQgJiYgIXRoaXMuZGlzYWJsZWQgJiYgaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEubGVmdCkpIHtcbiAgICAgICAgY3JvcEJveERhdGEubGVmdCA9IGRhdGEubGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEudG9wKSkge1xuICAgICAgICBjcm9wQm94RGF0YS50b3AgPSBkYXRhLnRvcDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEud2lkdGgpICYmIGRhdGEud2lkdGggIT09IGNyb3BCb3hEYXRhLndpZHRoKSB7XG4gICAgICAgIHdpZHRoQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGNyb3BCb3hEYXRhLndpZHRoID0gZGF0YS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSAmJiBkYXRhLmhlaWdodCAhPT0gY3JvcEJveERhdGEuaGVpZ2h0KSB7XG4gICAgICAgIGhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBkYXRhLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmICh3aWR0aENoYW5nZWQpIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBjcm9wQm94RGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKGhlaWdodENoYW5nZWQpIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS53aWR0aCA9IGNyb3BCb3hEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyQ3JvcEJveCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdldCBhIGNhbnZhcyBkcmF3biB0aGUgY3JvcHBlZCBpbWFnZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIFRoZSBjb25maWcgb3B0aW9ucy5cbiAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fSAtIFRoZSByZXN1bHQgY2FudmFzLlxuICAgKi9cbiAgZ2V0Q3JvcHBlZENhbnZhczogZnVuY3Rpb24gZ2V0Q3JvcHBlZENhbnZhcygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBpZiAoIXRoaXMucmVhZHkgfHwgIXdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG5cbiAgICB2YXIgc291cmNlID0gZ2V0U291cmNlQ2FudmFzKHRoaXMuaW1hZ2UsIHRoaXMuaW1hZ2VEYXRhLCBjYW52YXNEYXRhLCBvcHRpb25zKTtcblxuICAgIC8vIFJldHVybnMgdGhlIHNvdXJjZSBjYW52YXMgaWYgaXQgaXMgbm90IGNyb3BwZWQuXG4gICAgaWYgKCF0aGlzLmNyb3BwZWQpIHtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgdmFyIF9nZXREYXRhID0gdGhpcy5nZXREYXRhKCksXG4gICAgICAgIGluaXRpYWxYID0gX2dldERhdGEueCxcbiAgICAgICAgaW5pdGlhbFkgPSBfZ2V0RGF0YS55LFxuICAgICAgICBpbml0aWFsV2lkdGggPSBfZ2V0RGF0YS53aWR0aCxcbiAgICAgICAgaW5pdGlhbEhlaWdodCA9IF9nZXREYXRhLmhlaWdodDtcblxuICAgIHZhciByYXRpbyA9IHNvdXJjZS53aWR0aCAvIE1hdGguZmxvb3IoY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgpO1xuXG4gICAgaWYgKHJhdGlvICE9PSAxKSB7XG4gICAgICBpbml0aWFsWCAqPSByYXRpbztcbiAgICAgIGluaXRpYWxZICo9IHJhdGlvO1xuICAgICAgaW5pdGlhbFdpZHRoICo9IHJhdGlvO1xuICAgICAgaW5pdGlhbEhlaWdodCAqPSByYXRpbztcbiAgICB9XG5cbiAgICB2YXIgYXNwZWN0UmF0aW8gPSBpbml0aWFsV2lkdGggLyBpbml0aWFsSGVpZ2h0O1xuICAgIHZhciBtYXhTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgd2lkdGg6IG9wdGlvbnMubWF4V2lkdGggfHwgSW5maW5pdHksXG4gICAgICBoZWlnaHQ6IG9wdGlvbnMubWF4SGVpZ2h0IHx8IEluZmluaXR5XG4gICAgfSk7XG4gICAgdmFyIG1pblNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICB3aWR0aDogb3B0aW9ucy5taW5XaWR0aCB8fCAwLFxuICAgICAgaGVpZ2h0OiBvcHRpb25zLm1pbkhlaWdodCB8fCAwXG4gICAgfSwgJ2NvdmVyJyk7XG5cbiAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoIHx8IChyYXRpbyAhPT0gMSA/IHNvdXJjZS53aWR0aCA6IGluaXRpYWxXaWR0aCksXG4gICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0IHx8IChyYXRpbyAhPT0gMSA/IHNvdXJjZS5oZWlnaHQgOiBpbml0aWFsSGVpZ2h0KVxuICAgIH0pLFxuICAgICAgICB3aWR0aCA9IF9nZXRBZGp1c3RlZFNpemVzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfZ2V0QWRqdXN0ZWRTaXplcy5oZWlnaHQ7XG5cbiAgICB3aWR0aCA9IE1hdGgubWluKG1heFNpemVzLndpZHRoLCBNYXRoLm1heChtaW5TaXplcy53aWR0aCwgd2lkdGgpKTtcbiAgICBoZWlnaHQgPSBNYXRoLm1pbihtYXhTaXplcy5oZWlnaHQsIE1hdGgubWF4KG1pblNpemVzLmhlaWdodCwgaGVpZ2h0KSk7XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGNhbnZhcy53aWR0aCA9IG5vcm1hbGl6ZURlY2ltYWxOdW1iZXIod2lkdGgpO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBub3JtYWxpemVEZWNpbWFsTnVtYmVyKGhlaWdodCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIHZhciBfb3B0aW9ucyRpbWFnZVNtb290aGkgPSBvcHRpb25zLmltYWdlU21vb3RoaW5nRW5hYmxlZCxcbiAgICAgICAgaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gX29wdGlvbnMkaW1hZ2VTbW9vdGhpID09PSB1bmRlZmluZWQgPyB0cnVlIDogX29wdGlvbnMkaW1hZ2VTbW9vdGhpLFxuICAgICAgICBpbWFnZVNtb290aGluZ1F1YWxpdHkgPSBvcHRpb25zLmltYWdlU21vb3RoaW5nUXVhbGl0eTtcblxuXG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpbWFnZVNtb290aGluZ0VuYWJsZWQ7XG5cbiAgICBpZiAoaW1hZ2VTbW9vdGhpbmdRdWFsaXR5KSB7XG4gICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9IGltYWdlU21vb3RoaW5nUXVhbGl0eTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmRyYXdJbWFnZVxuICAgIHZhciBzb3VyY2VXaWR0aCA9IHNvdXJjZS53aWR0aDtcbiAgICB2YXIgc291cmNlSGVpZ2h0ID0gc291cmNlLmhlaWdodDtcblxuICAgIC8vIFNvdXJjZSBjYW52YXMgcGFyYW1ldGVyc1xuICAgIHZhciBzcmNYID0gaW5pdGlhbFg7XG4gICAgdmFyIHNyY1kgPSBpbml0aWFsWTtcbiAgICB2YXIgc3JjV2lkdGggPSB2b2lkIDA7XG4gICAgdmFyIHNyY0hlaWdodCA9IHZvaWQgMDtcblxuICAgIC8vIERlc3RpbmF0aW9uIGNhbnZhcyBwYXJhbWV0ZXJzXG4gICAgdmFyIGRzdFggPSB2b2lkIDA7XG4gICAgdmFyIGRzdFkgPSB2b2lkIDA7XG4gICAgdmFyIGRzdFdpZHRoID0gdm9pZCAwO1xuICAgIHZhciBkc3RIZWlnaHQgPSB2b2lkIDA7XG5cbiAgICBpZiAoc3JjWCA8PSAtaW5pdGlhbFdpZHRoIHx8IHNyY1ggPiBzb3VyY2VXaWR0aCkge1xuICAgICAgc3JjWCA9IDA7XG4gICAgICBzcmNXaWR0aCA9IDA7XG4gICAgICBkc3RYID0gMDtcbiAgICAgIGRzdFdpZHRoID0gMDtcbiAgICB9IGVsc2UgaWYgKHNyY1ggPD0gMCkge1xuICAgICAgZHN0WCA9IC1zcmNYO1xuICAgICAgc3JjWCA9IDA7XG4gICAgICBzcmNXaWR0aCA9IE1hdGgubWluKHNvdXJjZVdpZHRoLCBpbml0aWFsV2lkdGggKyBzcmNYKTtcbiAgICAgIGRzdFdpZHRoID0gc3JjV2lkdGg7XG4gICAgfSBlbHNlIGlmIChzcmNYIDw9IHNvdXJjZVdpZHRoKSB7XG4gICAgICBkc3RYID0gMDtcbiAgICAgIHNyY1dpZHRoID0gTWF0aC5taW4oaW5pdGlhbFdpZHRoLCBzb3VyY2VXaWR0aCAtIHNyY1gpO1xuICAgICAgZHN0V2lkdGggPSBzcmNXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoc3JjV2lkdGggPD0gMCB8fCBzcmNZIDw9IC1pbml0aWFsSGVpZ2h0IHx8IHNyY1kgPiBzb3VyY2VIZWlnaHQpIHtcbiAgICAgIHNyY1kgPSAwO1xuICAgICAgc3JjSGVpZ2h0ID0gMDtcbiAgICAgIGRzdFkgPSAwO1xuICAgICAgZHN0SGVpZ2h0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHNyY1kgPD0gMCkge1xuICAgICAgZHN0WSA9IC1zcmNZO1xuICAgICAgc3JjWSA9IDA7XG4gICAgICBzcmNIZWlnaHQgPSBNYXRoLm1pbihzb3VyY2VIZWlnaHQsIGluaXRpYWxIZWlnaHQgKyBzcmNZKTtcbiAgICAgIGRzdEhlaWdodCA9IHNyY0hlaWdodDtcbiAgICB9IGVsc2UgaWYgKHNyY1kgPD0gc291cmNlSGVpZ2h0KSB7XG4gICAgICBkc3RZID0gMDtcbiAgICAgIHNyY0hlaWdodCA9IE1hdGgubWluKGluaXRpYWxIZWlnaHQsIHNvdXJjZUhlaWdodCAtIHNyY1kpO1xuICAgICAgZHN0SGVpZ2h0ID0gc3JjSGVpZ2h0O1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSBbc3JjWCwgc3JjWSwgc3JjV2lkdGgsIHNyY0hlaWdodF07XG5cbiAgICAvLyBBdm9pZCBcIkluZGV4U2l6ZUVycm9yXCJcbiAgICBpZiAoZHN0V2lkdGggPiAwICYmIGRzdEhlaWdodCA+IDApIHtcbiAgICAgIHZhciBzY2FsZSA9IHdpZHRoIC8gaW5pdGlhbFdpZHRoO1xuXG4gICAgICBwYXJhbXMucHVzaChkc3RYICogc2NhbGUsIGRzdFkgKiBzY2FsZSwgZHN0V2lkdGggKiBzY2FsZSwgZHN0SGVpZ2h0ICogc2NhbGUpO1xuICAgIH1cblxuICAgIC8vIEFsbCB0aGUgbnVtZXJpY2FsIHBhcmFtZXRlcnMgc2hvdWxkIGJlIGludGVnZXIgZm9yIGBkcmF3SW1hZ2VgXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlbmd5dWFuY2hlbi9jcm9wcGVyL2lzc3Vlcy80NzZcbiAgICBjb250ZXh0LmRyYXdJbWFnZS5hcHBseShjb250ZXh0LCBbc291cmNlXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkocGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKG5vcm1hbGl6ZURlY2ltYWxOdW1iZXIocGFyYW0pKTtcbiAgICB9KSkpKTtcblxuICAgIHJldHVybiBjYW52YXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIGNyb3AgYm94LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0UmF0aW8gLSBUaGUgbmV3IGFzcGVjdCByYXRpby5cbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIHNldEFzcGVjdFJhdGlvOiBmdW5jdGlvbiBzZXRBc3BlY3RSYXRpbyhhc3BlY3RSYXRpbykge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIWlzVW5kZWZpbmVkKGFzcGVjdFJhdGlvKSkge1xuICAgICAgLy8gMCAtPiBOYU5cbiAgICAgIG9wdGlvbnMuYXNwZWN0UmF0aW8gPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbykgfHwgTmFOO1xuXG4gICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICB0aGlzLmluaXRDcm9wQm94KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY3JvcHBlZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyQ3JvcEJveCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBkcmFnIG1vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gVGhlIG5ldyBkcmFnIG1vZGUuXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICBzZXREcmFnTW9kZTogZnVuY3Rpb24gc2V0RHJhZ01vZGUobW9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBkcmFnQm94ID0gdGhpcy5kcmFnQm94LFxuICAgICAgICBmYWNlID0gdGhpcy5mYWNlO1xuXG5cbiAgICBpZiAodGhpcy5yZWFkeSAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdmFyIGNyb3BwYWJsZSA9IG1vZGUgPT09IERSQUdfTU9ERV9DUk9QO1xuICAgICAgdmFyIG1vdmFibGUgPSBvcHRpb25zLm1vdmFibGUgJiYgbW9kZSA9PT0gRFJBR19NT0RFX01PVkU7XG5cbiAgICAgIG1vZGUgPSBjcm9wcGFibGUgfHwgbW92YWJsZSA/IG1vZGUgOiBEUkFHX01PREVfTk9ORTtcblxuICAgICAgb3B0aW9ucy5kcmFnTW9kZSA9IG1vZGU7XG4gICAgICBzZXREYXRhKGRyYWdCb3gsIERBVEFfQUNUSU9OLCBtb2RlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGRyYWdCb3gsIENMQVNTX0NST1AsIGNyb3BwYWJsZSk7XG4gICAgICB0b2dnbGVDbGFzcyhkcmFnQm94LCBDTEFTU19NT1ZFLCBtb3ZhYmxlKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNyb3BCb3hNb3ZhYmxlKSB7XG4gICAgICAgIC8vIFN5bmMgZHJhZyBtb2RlIHRvIGNyb3AgYm94IHdoZW4gaXQgaXMgbm90IG1vdmFibGVcbiAgICAgICAgc2V0RGF0YShmYWNlLCBEQVRBX0FDVElPTiwgbW9kZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGZhY2UsIENMQVNTX0NST1AsIGNyb3BwYWJsZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGZhY2UsIENMQVNTX01PVkUsIG1vdmFibGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG52YXIgQW5vdGhlckNyb3BwZXIgPSBXSU5ET1cuQ3JvcHBlcjtcblxudmFyIENyb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQ3JvcHBlci5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50IGZvciBjcm9wcGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDcm9wcGVyKGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3JvcHBlcik7XG5cbiAgICBpZiAoIWVsZW1lbnQgfHwgIVJFR0VYUF9UQUdfTkFNRS50ZXN0KGVsZW1lbnQudGFnTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGFuIDxpbWc+IG9yIDxjYW52YXM+IGVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIERFRkFVTFRTLCBpc1BsYWluT2JqZWN0KG9wdGlvbnMpICYmIG9wdGlvbnMpO1xuICAgIHRoaXMuY3JvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMucmVsb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5yZXBsYWNlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2l6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNpemluZyA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQ3JvcHBlciwgW3tcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHVybCA9IHZvaWQgMDtcblxuICAgICAgaWYgKGdldERhdGEoZWxlbWVudCwgTkFNRVNQQUNFKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNldERhdGEoZWxlbWVudCwgTkFNRVNQQUNFLCB0aGlzKTtcblxuICAgICAgaWYgKHRhZ05hbWUgPT09ICdpbWcnKSB7XG4gICAgICAgIHRoaXMuaXNJbWcgPSB0cnVlO1xuXG4gICAgICAgIC8vIGUuZy46IFwiaW1nL3BpY3R1cmUuanBnXCJcbiAgICAgICAgdXJsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpIHx8ICcnO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVXJsID0gdXJsO1xuXG4gICAgICAgIC8vIFN0b3Agd2hlbiBpdCdzIGEgYmxhbmsgaW1hZ2VcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlLmcuOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9pbWcvcGljdHVyZS5qcGdcIlxuICAgICAgICB1cmwgPSBlbGVtZW50LnNyYztcbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ2NhbnZhcycgJiYgd2luZG93LkhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgIHVybCA9IGVsZW1lbnQudG9EYXRhVVJMKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9hZCh1cmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgIHRoaXMuaW1hZ2VEYXRhID0ge307XG5cbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblxuICAgICAgaWYgKCFvcHRpb25zLnJvdGF0YWJsZSAmJiAhb3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBvcHRpb25zLmNoZWNrT3JpZW50YXRpb24gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLmNoZWNrT3JpZW50YXRpb24gfHwgIXdpbmRvdy5BcnJheUJ1ZmZlcikge1xuICAgICAgICB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gWE1MSHR0cFJlcXVlc3QgZGlzYWxsb3dzIHRvIG9wZW4gYSBEYXRhIFVSTCBpbiBzb21lIGJyb3dzZXJzIGxpa2UgSUUxMSBhbmQgU2FmYXJpXG4gICAgICBpZiAoUkVHRVhQX0RBVEFfVVJMLnRlc3QodXJsKSkge1xuICAgICAgICBpZiAoUkVHRVhQX0RBVEFfVVJMX0pQRUcudGVzdCh1cmwpKSB7XG4gICAgICAgICAgdGhpcy5yZWFkKGRhdGFVUkxUb0FycmF5QnVmZmVyKHVybCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB0aGlzLnJlbG9hZGluZyA9IHRydWU7XG4gICAgICB0aGlzLnhociA9IHhocjtcblxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICBfdGhpcy5yZWxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMueGhyID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBkb25lO1xuICAgICAgeGhyLm9uYWJvcnQgPSBkb25lO1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgX3RoaXMuY2xvbmUoKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgX3RoaXMucmVhZCh4aHIucmVzcG9uc2UpO1xuICAgICAgfTtcblxuICAgICAgLy8gQnVzdCBjYWNoZSB3aGVuIHRoZXJlIGlzIGEgXCJjcm9zc09yaWdpblwiIHByb3BlcnR5XG4gICAgICBpZiAob3B0aW9ucy5jaGVja0Nyb3NzT3JpZ2luICYmIGlzQ3Jvc3NPcmlnaW5VUkwodXJsKSAmJiBlbGVtZW50LmNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHVybCA9IGFkZFRpbWVzdGFtcCh1cmwpO1xuICAgICAgfVxuXG4gICAgICB4aHIub3BlbignZ2V0JywgdXJsKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGVsZW1lbnQuY3Jvc3NPcmlnaW4gPT09ICd1c2UtY3JlZGVudGlhbHMnO1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZChhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG5cbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IGdldE9yaWVudGF0aW9uKGFycmF5QnVmZmVyKTtcbiAgICAgIHZhciByb3RhdGUgPSAwO1xuICAgICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgICB2YXIgc2NhbGVZID0gMTtcblxuICAgICAgaWYgKG9yaWVudGF0aW9uID4gMSkge1xuICAgICAgICB0aGlzLnVybCA9IGFycmF5QnVmZmVyVG9EYXRhVVJMKGFycmF5QnVmZmVyLCAnaW1hZ2UvanBlZycpO1xuXG4gICAgICAgIHZhciBfcGFyc2VPcmllbnRhdGlvbiA9IHBhcnNlT3JpZW50YXRpb24ob3JpZW50YXRpb24pO1xuXG4gICAgICAgIHJvdGF0ZSA9IF9wYXJzZU9yaWVudGF0aW9uLnJvdGF0ZTtcbiAgICAgICAgc2NhbGVYID0gX3BhcnNlT3JpZW50YXRpb24uc2NhbGVYO1xuICAgICAgICBzY2FsZVkgPSBfcGFyc2VPcmllbnRhdGlvbi5zY2FsZVk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJvdGF0YWJsZSkge1xuICAgICAgICBpbWFnZURhdGEucm90YXRlID0gcm90YXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICBpbWFnZURhdGEuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsb25lKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xvbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgIHVybCA9IHRoaXMudXJsO1xuXG4gICAgICB2YXIgY3Jvc3NPcmlnaW4gPSB2b2lkIDA7XG4gICAgICB2YXIgY3Jvc3NPcmlnaW5VcmwgPSB2b2lkIDA7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2hlY2tDcm9zc09yaWdpbiAmJiBpc0Nyb3NzT3JpZ2luVVJMKHVybCkpIHtcbiAgICAgICAgY3Jvc3NPcmlnaW4gPSBlbGVtZW50LmNyb3NzT3JpZ2luO1xuXG5cbiAgICAgICAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgY3Jvc3NPcmlnaW5VcmwgPSB1cmw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblxuICAgICAgICAgIC8vIEJ1c3QgY2FjaGUgd2hlbiB0aGVyZSBpcyBub3QgYSBcImNyb3NzT3JpZ2luXCIgcHJvcGVydHlcbiAgICAgICAgICBjcm9zc09yaWdpblVybCA9IGFkZFRpbWVzdGFtcCh1cmwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW5VcmwgPSBjcm9zc09yaWdpblVybDtcblxuICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBpbWFnZS5zcmMgPSBjcm9zc09yaWdpblVybCB8fCB1cmw7XG4gICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICBpbWFnZS5vbmxvYWQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICBpbWFnZS5vbmVycm9yID0gdGhpcy5zdG9wLmJpbmQodGhpcyk7XG4gICAgICBhZGRDbGFzcyhpbWFnZSwgQ0xBU1NfSElERSk7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGltYWdlLCBlbGVtZW50Lm5leHRTaWJsaW5nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuaXNJbWcgPyB0aGlzLmVsZW1lbnQgOiB0aGlzLmltYWdlO1xuXG4gICAgICBpbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgaW1hZ2Uub25lcnJvciA9IG51bGw7XG4gICAgICB0aGlzLnNpemluZyA9IHRydWU7XG5cbiAgICAgIHZhciBJU19TQUZBUkkgPSBXSU5ET1cubmF2aWdhdG9yICYmIC8oTWFjaW50b3NofGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdC9pLnRlc3QoV0lORE9XLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCkge1xuICAgICAgICBhc3NpZ24oX3RoaXMyLmltYWdlRGF0YSwge1xuICAgICAgICAgIG5hdHVyYWxXaWR0aDogbmF0dXJhbFdpZHRoLFxuICAgICAgICAgIG5hdHVyYWxIZWlnaHQ6IG5hdHVyYWxIZWlnaHQsXG4gICAgICAgICAgYXNwZWN0UmF0aW86IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzMi5zaXppbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMyLnNpemVkID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMyLmJ1aWxkKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgKGV4Y2VwdCBTYWZhcmkpXG4gICAgICBpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmICFJU19TQUZBUkkpIHtcbiAgICAgICAgZG9uZShpbWFnZS5uYXR1cmFsV2lkdGgsIGltYWdlLm5hdHVyYWxIZWlnaHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXppbmdJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgdGhpcy5zaXppbmdJbWFnZSA9IHNpemluZ0ltYWdlO1xuXG4gICAgICBzaXppbmdJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUoc2l6aW5nSW1hZ2Uud2lkdGgsIHNpemluZ0ltYWdlLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKCFJU19TQUZBUkkpIHtcbiAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKHNpemluZ0ltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2l6aW5nSW1hZ2Uuc3JjID0gaW1hZ2Uuc3JjO1xuXG4gICAgICAvLyBpT1MgU2FmYXJpIHdpbGwgY29udmVydCB0aGUgaW1hZ2UgYXV0b21hdGljYWxseVxuICAgICAgLy8gd2l0aCBpdHMgb3JpZW50YXRpb24gb25jZSBhcHBlbmQgaXQgaW50byBET00gKCMyNzkpXG4gICAgICBpZiAoIUlTX1NBRkFSSSkge1xuICAgICAgICBzaXppbmdJbWFnZS5zdHlsZS5jc3NUZXh0ID0gJ2xlZnQ6MDsnICsgJ21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnQ7JyArICdtYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnQ7JyArICdtaW4taGVpZ2h0OjAhaW1wb3J0YW50OycgKyAnbWluLXdpZHRoOjAhaW1wb3J0YW50OycgKyAnb3BhY2l0eTowOycgKyAncG9zaXRpb246YWJzb2x1dGU7JyArICd0b3A6MDsnICsgJ3otaW5kZXg6LTE7JztcbiAgICAgICAgYm9keS5hcHBlbmRDaGlsZChzaXppbmdJbWFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG5cbiAgICAgIGltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICBpbWFnZS5vbmVycm9yID0gbnVsbDtcbiAgICAgIGltYWdlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1hZ2UpO1xuICAgICAgdGhpcy5pbWFnZSA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIGlmICghdGhpcy5zaXplZCB8fCB0aGlzLnJlYWR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBpbWFnZSA9IHRoaXMuaW1hZ2U7XG5cbiAgICAgIC8vIENyZWF0ZSBjcm9wcGVyIGVsZW1lbnRzXG5cbiAgICAgIHZhciBjb250YWluZXIgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gVEVNUExBVEU7XG5cbiAgICAgIHZhciBjcm9wcGVyID0gdGVtcGxhdGUucXVlcnlTZWxlY3RvcignLicgKyBOQU1FU1BBQ0UgKyAnLWNvbnRhaW5lcicpO1xuICAgICAgdmFyIGNhbnZhcyA9IGNyb3BwZXIucXVlcnlTZWxlY3RvcignLicgKyBOQU1FU1BBQ0UgKyAnLWNhbnZhcycpO1xuICAgICAgdmFyIGRyYWdCb3ggPSBjcm9wcGVyLnF1ZXJ5U2VsZWN0b3IoJy4nICsgTkFNRVNQQUNFICsgJy1kcmFnLWJveCcpO1xuICAgICAgdmFyIGNyb3BCb3ggPSBjcm9wcGVyLnF1ZXJ5U2VsZWN0b3IoJy4nICsgTkFNRVNQQUNFICsgJy1jcm9wLWJveCcpO1xuICAgICAgdmFyIGZhY2UgPSBjcm9wQm94LnF1ZXJ5U2VsZWN0b3IoJy4nICsgTkFNRVNQQUNFICsgJy1mYWNlJyk7XG5cbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5jcm9wcGVyID0gY3JvcHBlcjtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5kcmFnQm94ID0gZHJhZ0JveDtcbiAgICAgIHRoaXMuY3JvcEJveCA9IGNyb3BCb3g7XG4gICAgICB0aGlzLnZpZXdCb3ggPSBjcm9wcGVyLnF1ZXJ5U2VsZWN0b3IoJy4nICsgTkFNRVNQQUNFICsgJy12aWV3LWJveCcpO1xuICAgICAgdGhpcy5mYWNlID0gZmFjZTtcblxuICAgICAgY2FudmFzLmFwcGVuZENoaWxkKGltYWdlKTtcblxuICAgICAgLy8gSGlkZSB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICAgIGFkZENsYXNzKGVsZW1lbnQsIENMQVNTX0hJRERFTik7XG5cbiAgICAgIC8vIEluc2VydHMgdGhlIGNyb3BwZXIgYWZ0ZXIgdG8gdGhlIGN1cnJlbnQgaW1hZ2VcbiAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY3JvcHBlciwgZWxlbWVudC5uZXh0U2libGluZyk7XG5cbiAgICAgIC8vIFNob3cgdGhlIGltYWdlIGlmIGlzIGhpZGRlblxuICAgICAgaWYgKCF0aGlzLmlzSW1nKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGltYWdlLCBDTEFTU19ISURFKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbml0UHJldmlldygpO1xuICAgICAgdGhpcy5iaW5kKCk7XG5cbiAgICAgIG9wdGlvbnMuaW5pdGlhbEFzcGVjdFJhdGlvID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5pbml0aWFsQXNwZWN0UmF0aW8pIHx8IE5hTjtcbiAgICAgIG9wdGlvbnMuYXNwZWN0UmF0aW8gPSBNYXRoLm1heCgwLCBvcHRpb25zLmFzcGVjdFJhdGlvKSB8fCBOYU47XG4gICAgICBvcHRpb25zLnZpZXdNb2RlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMywgTWF0aC5yb3VuZChvcHRpb25zLnZpZXdNb2RlKSkpIHx8IDA7XG5cbiAgICAgIGFkZENsYXNzKGNyb3BCb3gsIENMQVNTX0hJRERFTik7XG5cbiAgICAgIGlmICghb3B0aW9ucy5ndWlkZXMpIHtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKE5BTUVTUEFDRSArICctZGFzaGVkJyksIENMQVNTX0hJRERFTik7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5jZW50ZXIpIHtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKE5BTUVTUEFDRSArICctY2VudGVyJyksIENMQVNTX0hJRERFTik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmQpIHtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcHBlciwgTkFNRVNQQUNFICsgJy1iZycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIGFkZENsYXNzKGZhY2UsIENMQVNTX0lOVklTSUJMRSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNyb3BCb3hNb3ZhYmxlKSB7XG4gICAgICAgIGFkZENsYXNzKGZhY2UsIENMQVNTX01PVkUpO1xuICAgICAgICBzZXREYXRhKGZhY2UsIERBVEFfQUNUSU9OLCBBQ1RJT05fQUxMKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLmNyb3BCb3hSZXNpemFibGUpIHtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKE5BTUVTUEFDRSArICctbGluZScpLCBDTEFTU19ISURERU4pO1xuICAgICAgICBhZGRDbGFzcyhjcm9wQm94LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoTkFNRVNQQUNFICsgJy1wb2ludCcpLCBDTEFTU19ISURERU4pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLnNldERyYWdNb2RlKG9wdGlvbnMuZHJhZ01vZGUpO1xuXG4gICAgICBpZiAob3B0aW9ucy5hdXRvQ3JvcCkge1xuICAgICAgICB0aGlzLmNyb3AoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXREYXRhKG9wdGlvbnMuZGF0YSk7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMucmVhZHkpKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1JFQURZLCBvcHRpb25zLnJlYWR5LCB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9SRUFEWSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW5idWlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYnVpbGQoKSB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgdGhpcy5yZXNldFByZXZpZXcoKTtcbiAgICAgIHRoaXMuY3JvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3JvcHBlcik7XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX0hJRERFTik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW5jcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmNyZWF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgIHRoaXMudW5idWlsZCgpO1xuICAgICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3JvcHBlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNpemluZykge1xuICAgICAgICB0aGlzLnNpemluZ0ltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2l6ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWxvYWRpbmcpIHtcbiAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbWFnZSkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5vIGNvbmZsaWN0IGNyb3BwZXIgY2xhc3MuXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IFRoZSBjcm9wcGVyIGNsYXNzLlxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogJ25vQ29uZmxpY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgd2luZG93LkNyb3BwZXIgPSBBbm90aGVyQ3JvcHBlcjtcbiAgICAgIHJldHVybiBDcm9wcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG5ldyBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldERlZmF1bHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgYXNzaWduKERFRkFVTFRTLCBpc1BsYWluT2JqZWN0KG9wdGlvbnMpICYmIG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ3JvcHBlcjtcbn0oKTtcblxuYXNzaWduKENyb3BwZXIucHJvdG90eXBlLCByZW5kZXIsIHByZXZpZXcsIGV2ZW50cywgaGFuZGxlcnMsIGNoYW5nZSwgbWV0aG9kcyk7XG5cbmV4cG9ydCBkZWZhdWx0IENyb3BwZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/cropperjs/dist/cropper.esm.js\n");

/***/ }),

/***/ "./node_modules/cropperjs/dist/cropper.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/cropperjs/dist/cropper.min.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../css-loader!./cropper.min.css */ \"./node_modules/css-loader/index.js!./node_modules/cropperjs/dist/cropper.min.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5taW4uY3NzPzgxM2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw2SEFBK0M7O0FBRXJFLDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RkFBc0M7O0FBRTNEOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nyb3BwZXJqcy9kaXN0L2Nyb3BwZXIubWluLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY3JvcHBlci5taW4uY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jcm9wcGVyLm1pbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY3JvcHBlci5taW4uY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cropperjs/dist/cropper.min.css\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/cropperjs/dist/cropper.min.css":
/*!*******************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/cropperjs/dist/cropper.min.css ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/*!\\n * Cropper.js v1.4.1\\n * https://fengyuanchen.github.io/cropperjs\\n *\\n * Copyright 2015-present Chen Fengyuan\\n * Released under the MIT license\\n *\\n * Date: 2018-07-15T09:54:43.167Z\\n */.cropper-container{-moz-user-select:none;-ms-touch-action:none;-ms-user-select:none;-webkit-user-select:none;direction:ltr;font-size:0;line-height:0;position:relative;touch-action:none;user-select:none}.cropper-container img{display:block;height:100%;image-orientation:0deg;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;width:100%}.cropper-canvas,.cropper-crop-box,.cropper-drag-box,.cropper-modal,.cropper-wrap-box{bottom:0;left:0;position:absolute;right:0;top:0}.cropper-canvas,.cropper-wrap-box{overflow:hidden}.cropper-drag-box{background-color:#fff;opacity:0}.cropper-modal{background-color:#000;opacity:.5}.cropper-view-box{display:block;height:100%;outline:1px solid #39f;outline-color:rgba(51,153,255,.75);overflow:hidden;width:100%}.cropper-dashed{border:0 dashed #eee;display:block;opacity:.5;position:absolute}.cropper-dashed.dashed-h{border-bottom-width:1px;border-top-width:1px;height:33.33333%;left:0;top:33.33333%;width:100%}.cropper-dashed.dashed-v{border-left-width:1px;border-right-width:1px;height:100%;left:33.33333%;top:0;width:33.33333%}.cropper-center{display:block;height:0;left:50%;opacity:.75;position:absolute;top:50%;width:0}.cropper-center:after,.cropper-center:before{background-color:#eee;content:\\\" \\\";display:block;position:absolute}.cropper-center:before{height:1px;left:-3px;top:0;width:7px}.cropper-center:after{height:7px;left:0;top:-3px;width:1px}.cropper-face,.cropper-line,.cropper-point{display:block;height:100%;opacity:.1;position:absolute;width:100%}.cropper-face{background-color:#fff;left:0;top:0}.cropper-line{background-color:#39f}.cropper-line.line-e{cursor:ew-resize;right:-3px;top:0;width:5px}.cropper-line.line-n{cursor:ns-resize;height:5px;left:0;top:-3px}.cropper-line.line-w{cursor:ew-resize;left:-3px;top:0;width:5px}.cropper-line.line-s{bottom:-3px;cursor:ns-resize;height:5px;left:0}.cropper-point{background-color:#39f;height:5px;opacity:.75;width:5px}.cropper-point.point-e{cursor:ew-resize;margin-top:-3px;right:-3px;top:50%}.cropper-point.point-n{cursor:ns-resize;left:50%;margin-left:-3px;top:-3px}.cropper-point.point-w{cursor:ew-resize;left:-3px;margin-top:-3px;top:50%}.cropper-point.point-s{bottom:-3px;cursor:s-resize;left:50%;margin-left:-3px}.cropper-point.point-ne{cursor:nesw-resize;right:-3px;top:-3px}.cropper-point.point-nw{cursor:nwse-resize;left:-3px;top:-3px}.cropper-point.point-sw{bottom:-3px;cursor:nesw-resize;left:-3px}.cropper-point.point-se{bottom:-3px;cursor:nwse-resize;height:20px;opacity:1;right:-3px;width:20px}@media (min-width:768px){.cropper-point.point-se{height:15px;width:15px}}@media (min-width:992px){.cropper-point.point-se{height:10px;width:10px}}@media (min-width:1200px){.cropper-point.point-se{height:5px;opacity:.75;width:5px}}.cropper-point.point-se:before{background-color:#39f;bottom:-50%;content:\\\" \\\";display:block;height:200%;opacity:0;position:absolute;right:-50%;width:200%}.cropper-invisible{opacity:0}.cropper-bg{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC\\\")}.cropper-hide{display:block;height:0;position:absolute;width:0}.cropper-hidden{display:none!important}.cropper-move{cursor:move}.cropper-crop{cursor:crosshair}.cropper-disabled .cropper-drag-box,.cropper-disabled .cropper-face,.cropper-disabled .cropper-line,.cropper-disabled .cropper-point{cursor:not-allowed}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5taW4uY3NzPzA2YWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsbUZBQWtDO0FBQ3JFOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyx3TkFBd04sc0JBQXNCLHNCQUFzQixxQkFBcUIseUJBQXlCLGNBQWMsWUFBWSxjQUFjLGtCQUFrQixrQkFBa0IsaUJBQWlCLHVCQUF1QixjQUFjLFlBQVksdUJBQXVCLDBCQUEwQix5QkFBeUIsdUJBQXVCLHNCQUFzQixXQUFXLHFGQUFxRixTQUFTLE9BQU8sa0JBQWtCLFFBQVEsTUFBTSxrQ0FBa0MsZ0JBQWdCLGtCQUFrQixzQkFBc0IsVUFBVSxlQUFlLHNCQUFzQixXQUFXLGtCQUFrQixjQUFjLFlBQVksdUJBQXVCLG1DQUFtQyxnQkFBZ0IsV0FBVyxnQkFBZ0IscUJBQXFCLGNBQWMsV0FBVyxrQkFBa0IseUJBQXlCLHdCQUF3QixxQkFBcUIsaUJBQWlCLE9BQU8sY0FBYyxXQUFXLHlCQUF5QixzQkFBc0IsdUJBQXVCLFlBQVksZUFBZSxNQUFNLGdCQUFnQixnQkFBZ0IsY0FBYyxTQUFTLFNBQVMsWUFBWSxrQkFBa0IsUUFBUSxRQUFRLDZDQUE2QyxzQkFBc0IsY0FBYyxjQUFjLGtCQUFrQix1QkFBdUIsV0FBVyxVQUFVLE1BQU0sVUFBVSxzQkFBc0IsV0FBVyxPQUFPLFNBQVMsVUFBVSwyQ0FBMkMsY0FBYyxZQUFZLFdBQVcsa0JBQWtCLFdBQVcsY0FBYyxzQkFBc0IsT0FBTyxNQUFNLGNBQWMsc0JBQXNCLHFCQUFxQixpQkFBaUIsV0FBVyxNQUFNLFVBQVUscUJBQXFCLGlCQUFpQixXQUFXLE9BQU8sU0FBUyxxQkFBcUIsaUJBQWlCLFVBQVUsTUFBTSxVQUFVLHFCQUFxQixZQUFZLGlCQUFpQixXQUFXLE9BQU8sZUFBZSxzQkFBc0IsV0FBVyxZQUFZLFVBQVUsdUJBQXVCLGlCQUFpQixnQkFBZ0IsV0FBVyxRQUFRLHVCQUF1QixpQkFBaUIsU0FBUyxpQkFBaUIsU0FBUyx1QkFBdUIsaUJBQWlCLFVBQVUsZ0JBQWdCLFFBQVEsdUJBQXVCLFlBQVksZ0JBQWdCLFNBQVMsaUJBQWlCLHdCQUF3QixtQkFBbUIsV0FBVyxTQUFTLHdCQUF3QixtQkFBbUIsVUFBVSxTQUFTLHdCQUF3QixZQUFZLG1CQUFtQixVQUFVLHdCQUF3QixZQUFZLG1CQUFtQixZQUFZLFVBQVUsV0FBVyxXQUFXLHlCQUF5Qix3QkFBd0IsWUFBWSxZQUFZLHlCQUF5Qix3QkFBd0IsWUFBWSxZQUFZLDBCQUEwQix3QkFBd0IsV0FBVyxZQUFZLFdBQVcsK0JBQStCLHNCQUFzQixZQUFZLGNBQWMsY0FBYyxZQUFZLFVBQVUsa0JBQWtCLFdBQVcsV0FBVyxtQkFBbUIsVUFBVSxZQUFZLHNDQUFzQywyT0FBMk8sY0FBYyxjQUFjLFNBQVMsa0JBQWtCLFFBQVEsZ0JBQWdCLHVCQUF1QixjQUFjLFlBQVksY0FBYyxpQkFBaUIscUlBQXFJLG1CQUFtQjs7QUFFcnNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5taW4uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcbiAqIENyb3BwZXIuanMgdjEuNC4xXFxuICogaHR0cHM6Ly9mZW5neXVhbmNoZW4uZ2l0aHViLmlvL2Nyb3BwZXJqc1xcbiAqXFxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCBDaGVuIEZlbmd5dWFuXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE4LTA3LTE1VDA5OjU0OjQzLjE2N1pcXG4gKi8uY3JvcHBlci1jb250YWluZXJ7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy10b3VjaC1hY3Rpb246bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7ZGlyZWN0aW9uOmx0cjtmb250LXNpemU6MDtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3RvdWNoLWFjdGlvbjpub25lO3VzZXItc2VsZWN0Om5vbmV9LmNyb3BwZXItY29udGFpbmVyIGltZ3tkaXNwbGF5OmJsb2NrO2hlaWdodDoxMDAlO2ltYWdlLW9yaWVudGF0aW9uOjBkZWc7bWF4LWhlaWdodDpub25lIWltcG9ydGFudDttYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnQ7bWluLWhlaWdodDowIWltcG9ydGFudDttaW4td2lkdGg6MCFpbXBvcnRhbnQ7d2lkdGg6MTAwJX0uY3JvcHBlci1jYW52YXMsLmNyb3BwZXItY3JvcC1ib3gsLmNyb3BwZXItZHJhZy1ib3gsLmNyb3BwZXItbW9kYWwsLmNyb3BwZXItd3JhcC1ib3h7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmNyb3BwZXItY2FudmFzLC5jcm9wcGVyLXdyYXAtYm94e292ZXJmbG93OmhpZGRlbn0uY3JvcHBlci1kcmFnLWJveHtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7b3BhY2l0eTowfS5jcm9wcGVyLW1vZGFse2JhY2tncm91bmQtY29sb3I6IzAwMDtvcGFjaXR5Oi41fS5jcm9wcGVyLXZpZXctYm94e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMCU7b3V0bGluZToxcHggc29saWQgIzM5ZjtvdXRsaW5lLWNvbG9yOnJnYmEoNTEsMTUzLDI1NSwuNzUpO292ZXJmbG93OmhpZGRlbjt3aWR0aDoxMDAlfS5jcm9wcGVyLWRhc2hlZHtib3JkZXI6MCBkYXNoZWQgI2VlZTtkaXNwbGF5OmJsb2NrO29wYWNpdHk6LjU7cG9zaXRpb246YWJzb2x1dGV9LmNyb3BwZXItZGFzaGVkLmRhc2hlZC1oe2JvcmRlci1ib3R0b20td2lkdGg6MXB4O2JvcmRlci10b3Atd2lkdGg6MXB4O2hlaWdodDozMy4zMzMzMyU7bGVmdDowO3RvcDozMy4zMzMzMyU7d2lkdGg6MTAwJX0uY3JvcHBlci1kYXNoZWQuZGFzaGVkLXZ7Ym9yZGVyLWxlZnQtd2lkdGg6MXB4O2JvcmRlci1yaWdodC13aWR0aDoxcHg7aGVpZ2h0OjEwMCU7bGVmdDozMy4zMzMzMyU7dG9wOjA7d2lkdGg6MzMuMzMzMzMlfS5jcm9wcGVyLWNlbnRlcntkaXNwbGF5OmJsb2NrO2hlaWdodDowO2xlZnQ6NTAlO29wYWNpdHk6Ljc1O3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7d2lkdGg6MH0uY3JvcHBlci1jZW50ZXI6YWZ0ZXIsLmNyb3BwZXItY2VudGVyOmJlZm9yZXtiYWNrZ3JvdW5kLWNvbG9yOiNlZWU7Y29udGVudDpcXFwiIFxcXCI7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZX0uY3JvcHBlci1jZW50ZXI6YmVmb3Jle2hlaWdodDoxcHg7bGVmdDotM3B4O3RvcDowO3dpZHRoOjdweH0uY3JvcHBlci1jZW50ZXI6YWZ0ZXJ7aGVpZ2h0OjdweDtsZWZ0OjA7dG9wOi0zcHg7d2lkdGg6MXB4fS5jcm9wcGVyLWZhY2UsLmNyb3BwZXItbGluZSwuY3JvcHBlci1wb2ludHtkaXNwbGF5OmJsb2NrO2hlaWdodDoxMDAlO29wYWNpdHk6LjE7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJX0uY3JvcHBlci1mYWNle2JhY2tncm91bmQtY29sb3I6I2ZmZjtsZWZ0OjA7dG9wOjB9LmNyb3BwZXItbGluZXtiYWNrZ3JvdW5kLWNvbG9yOiMzOWZ9LmNyb3BwZXItbGluZS5saW5lLWV7Y3Vyc29yOmV3LXJlc2l6ZTtyaWdodDotM3B4O3RvcDowO3dpZHRoOjVweH0uY3JvcHBlci1saW5lLmxpbmUtbntjdXJzb3I6bnMtcmVzaXplO2hlaWdodDo1cHg7bGVmdDowO3RvcDotM3B4fS5jcm9wcGVyLWxpbmUubGluZS13e2N1cnNvcjpldy1yZXNpemU7bGVmdDotM3B4O3RvcDowO3dpZHRoOjVweH0uY3JvcHBlci1saW5lLmxpbmUtc3tib3R0b206LTNweDtjdXJzb3I6bnMtcmVzaXplO2hlaWdodDo1cHg7bGVmdDowfS5jcm9wcGVyLXBvaW50e2JhY2tncm91bmQtY29sb3I6IzM5ZjtoZWlnaHQ6NXB4O29wYWNpdHk6Ljc1O3dpZHRoOjVweH0uY3JvcHBlci1wb2ludC5wb2ludC1le2N1cnNvcjpldy1yZXNpemU7bWFyZ2luLXRvcDotM3B4O3JpZ2h0Oi0zcHg7dG9wOjUwJX0uY3JvcHBlci1wb2ludC5wb2ludC1ue2N1cnNvcjpucy1yZXNpemU7bGVmdDo1MCU7bWFyZ2luLWxlZnQ6LTNweDt0b3A6LTNweH0uY3JvcHBlci1wb2ludC5wb2ludC13e2N1cnNvcjpldy1yZXNpemU7bGVmdDotM3B4O21hcmdpbi10b3A6LTNweDt0b3A6NTAlfS5jcm9wcGVyLXBvaW50LnBvaW50LXN7Ym90dG9tOi0zcHg7Y3Vyc29yOnMtcmVzaXplO2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi0zcHh9LmNyb3BwZXItcG9pbnQucG9pbnQtbmV7Y3Vyc29yOm5lc3ctcmVzaXplO3JpZ2h0Oi0zcHg7dG9wOi0zcHh9LmNyb3BwZXItcG9pbnQucG9pbnQtbnd7Y3Vyc29yOm53c2UtcmVzaXplO2xlZnQ6LTNweDt0b3A6LTNweH0uY3JvcHBlci1wb2ludC5wb2ludC1zd3tib3R0b206LTNweDtjdXJzb3I6bmVzdy1yZXNpemU7bGVmdDotM3B4fS5jcm9wcGVyLXBvaW50LnBvaW50LXNle2JvdHRvbTotM3B4O2N1cnNvcjpud3NlLXJlc2l6ZTtoZWlnaHQ6MjBweDtvcGFjaXR5OjE7cmlnaHQ6LTNweDt3aWR0aDoyMHB4fUBtZWRpYSAobWluLXdpZHRoOjc2OHB4KXsuY3JvcHBlci1wb2ludC5wb2ludC1zZXtoZWlnaHQ6MTVweDt3aWR0aDoxNXB4fX1AbWVkaWEgKG1pbi13aWR0aDo5OTJweCl7LmNyb3BwZXItcG9pbnQucG9pbnQtc2V7aGVpZ2h0OjEwcHg7d2lkdGg6MTBweH19QG1lZGlhIChtaW4td2lkdGg6MTIwMHB4KXsuY3JvcHBlci1wb2ludC5wb2ludC1zZXtoZWlnaHQ6NXB4O29wYWNpdHk6Ljc1O3dpZHRoOjVweH19LmNyb3BwZXItcG9pbnQucG9pbnQtc2U6YmVmb3Jle2JhY2tncm91bmQtY29sb3I6IzM5Zjtib3R0b206LTUwJTtjb250ZW50OlxcXCIgXFxcIjtkaXNwbGF5OmJsb2NrO2hlaWdodDoyMDAlO29wYWNpdHk6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotNTAlO3dpZHRoOjIwMCV9LmNyb3BwZXItaW52aXNpYmxle29wYWNpdHk6MH0uY3JvcHBlci1iZ3tiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQVFNQUFBQWxQVzBpQUFBQUEzTkNTVlFJQ0FqYjRVL2dBQUFBQmxCTVZFWE16TXovLy8vVGpSVjJBQUFBQ1hCSVdYTUFBQXJyQUFBSzZ3R0NpdzFhQUFBQUhIUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkdhWEpsZDI5eWEzTWdRMU0yNkx5eWpBQUFBQkZKUkVGVUNKbGorTS9BZ0JWaEYvMFBBSDYvRC9Ia0R4T0dBQUFBQUVsRlRrU3VRbUNDXFxcIil9LmNyb3BwZXItaGlkZXtkaXNwbGF5OmJsb2NrO2hlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjB9LmNyb3BwZXItaGlkZGVue2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LmNyb3BwZXItbW92ZXtjdXJzb3I6bW92ZX0uY3JvcHBlci1jcm9we2N1cnNvcjpjcm9zc2hhaXJ9LmNyb3BwZXItZGlzYWJsZWQgLmNyb3BwZXItZHJhZy1ib3gsLmNyb3BwZXItZGlzYWJsZWQgLmNyb3BwZXItZmFjZSwuY3JvcHBlci1kaXNhYmxlZCAuY3JvcHBlci1saW5lLC5jcm9wcGVyLWRpc2FibGVkIC5jcm9wcGVyLXBvaW50e2N1cnNvcjpub3QtYWxsb3dlZH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./node_modules/cropperjs/dist/cropper.min.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/fastpriorityqueue/FastPriorityQueue.js":
/*!*************************************************************!*\
  !*** ./node_modules/fastpriorityqueue/FastPriorityQueue.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {/**\n * FastPriorityQueue.js : a fast heap-based priority queue  in JavaScript.\n * (c) the authors\n * Licensed under the Apache License, Version 2.0.\n *\n * Speed-optimized heap-based priority queue for modern browsers and JavaScript engines.\n *\n * Usage :\n         Installation (in shell, if you use node):\n         $ npm install fastpriorityqueue\n\n         Running test program (in JavaScript):\n\n         // var FastPriorityQueue = require(\"fastpriorityqueue\");// in node\n         var x = new FastPriorityQueue();\n         x.add(1);\n         x.add(0);\n         x.add(5);\n         x.add(4);\n         x.add(3);\n         x.peek(); // should return 0, leaves x unchanged\n         x.size; // should return 5, leaves x unchanged\n         while(!x.isEmpty()) {\n           console.log(x.poll());\n         } // will print 0 1 3 4 5\n         x.trim(); // (optional) optimizes memory usage\n */\n\n\nvar defaultcomparator = function(a, b) {\n  return a < b;\n};\n\n// the provided comparator function should take a, b and return *true* when a < b\nfunction FastPriorityQueue(comparator) {\n  if (!(this instanceof FastPriorityQueue)) return new FastPriorityQueue(comparator);\n  this.array = [];\n  this.size = 0;\n  this.compare = comparator || defaultcomparator;\n}\n\n// copy the priority queue into another, and return it. Queue items are shallow-copied.\n// Runs in `O(n)` time.\nFastPriorityQueue.prototype.clone = function() {\n  var fpq = new FastPriorityQueue(this.compare);\n  fpq.size = this.size;\n  for (var i = 0; i < this.size; i++) {\n    fpq.array.push(this.array[i]);\n  }\n  return fpq;\n};\n\n// Add an element into the queue\n// runs in O(log n) time\nFastPriorityQueue.prototype.add = function(myval) {\n  var i = this.size;\n  this.array[this.size] = myval;\n  this.size += 1;\n  var p;\n  var ap;\n  while (i > 0) {\n    p = (i - 1) >> 1;\n    ap = this.array[p];\n    if (!this.compare(myval, ap)) {\n      break;\n    }\n    this.array[i] = ap;\n    i = p;\n  }\n  this.array[i] = myval;\n};\n\n// replace the content of the heap by provided array and \"heapify it\"\nFastPriorityQueue.prototype.heapify = function(arr) {\n  this.array = arr;\n  this.size = arr.length;\n  var i;\n  for (i = this.size >> 1; i >= 0; i--) {\n    this._percolateDown(i);\n  }\n};\n\n// for internal use\nFastPriorityQueue.prototype._percolateUp = function(i, force) {\n  var myval = this.array[i];\n  var p;\n  var ap;\n  while (i > 0) {\n    p = (i - 1) >> 1;\n    ap = this.array[p];\n    // force will skip the compare\n    if (!force && !this.compare(myval, ap)) {\n      break;\n    }\n    this.array[i] = ap;\n    i = p;\n  }\n  this.array[i] = myval;\n};\n\n// for internal use\nFastPriorityQueue.prototype._percolateDown = function(i) {\n  var size = this.size;\n  var hsize = this.size >>> 1;\n  var ai = this.array[i];\n  var l;\n  var r;\n  var bestc;\n  while (i < hsize) {\n    l = (i << 1) + 1;\n    r = l + 1;\n    bestc = this.array[l];\n    if (r < size) {\n      if (this.compare(this.array[r], bestc)) {\n        l = r;\n        bestc = this.array[r];\n      }\n    }\n    if (!this.compare(bestc, ai)) {\n      break;\n    }\n    this.array[i] = bestc;\n    i = l;\n  }\n  this.array[i] = ai;\n};\n\n// internal\n// _removeAt(index) will remove the item at the given index from the queue,\n// retaining balance. returns the removed item, or undefined if nothing is removed.\nFastPriorityQueue.prototype._removeAt = function(index) {\n  if (index > this.size - 1 || index < 0) return undefined;\n\n  // impl1:\n  //this.array.splice(index, 1);\n  //this.heapify(this.array);\n  // impl2:\n  this._percolateUp(index, true);\n  return this.poll();\n};\n\n// remove(myval) will remove an item matching the provided value from the\n// queue, checked for equality by using the queue's comparator.\n// return true if removed, false otherwise.\nFastPriorityQueue.prototype.remove = function(myval) {\n  for (var i = 0; i < this.size; i++) {\n    if (!this.compare(this.array[i], myval) && !this.compare(myval, this.array[i])) {\n      // items match, comparator returns false both ways, remove item\n      this._removeAt(i);\n      return true;\n    }\n  }\n  return false;\n};\n\n// internal\n// removes and returns items for which the callback returns true.\nFastPriorityQueue.prototype._batchRemove = function(callback, limit) {\n  // initialize return array with max size of the limit or current queue size\n  var retArr = new Array(limit ? limit : this.size);\n  var count = 0;\n\n  if (typeof callback === 'function' && this.size) {\n    var i = 0;\n    while (i < this.size && count < retArr.length) {\n      if (callback(this.array[i])) {\n        retArr[count] = this._removeAt(i);\n        count++;\n        // move up a level in the heap if we remove an item\n        i = i >> 1;\n      } else {\n        i++;\n      }\n    } \n  }\n  retArr.length = count;\n  return retArr;\n}\n\n// removeOne(callback) will execute the callback function for each item of the queue\n// and will remove the first item for which the callback will return true.\n// return the removed item, or undefined if nothing is removed.\nFastPriorityQueue.prototype.removeOne = function(callback) {\n  var arr = this._batchRemove(callback, 1);\n  return arr.length > 0 ? arr[0] : undefined;\n};\n\n// remove(callback[, limit]) will execute the callback function for each item of\n// the queue and will remove each item for which the callback returns true, up to\n// a max limit of removed items if specified or no limit if unspecified.\n// return an array containing the removed items.\nFastPriorityQueue.prototype.removeMany = function(callback, limit) {\n  return this._batchRemove(callback, limit);\n};\n\n// Look at the top of the queue (one of the smallest elements) without removing it\n// executes in constant time\n//\n// Calling peek on an empty priority queue returns\n// the \"undefined\" value.\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined\n//\nFastPriorityQueue.prototype.peek = function() {\n  if (this.size == 0) return undefined;\n  return this.array[0];\n};\n\n// remove the element on top of the heap (one of the smallest elements)\n// runs in logarithmic time\n//\n// If the priority queue is empty, the function returns the\n// \"undefined\" value.\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined\n//\n// For long-running and large priority queues, or priority queues\n// storing large objects, you may  want to call the trim function\n// at strategic times to recover allocated memory.\nFastPriorityQueue.prototype.poll = function() {\n  if (this.size == 0) return undefined;\n  var ans = this.array[0];\n  if (this.size > 1) {\n    this.array[0] = this.array[--this.size];\n    this._percolateDown(0);\n  } else {\n    this.size -= 1;\n  }\n  return ans;\n};\n\n// This function adds the provided value to the heap, while removing\n// and returning one of the smallest elements (like poll). The size of the queue\n// thus remains unchanged.\nFastPriorityQueue.prototype.replaceTop = function(myval) {\n  if (this.size == 0) return undefined;\n  var ans = this.array[0];\n  this.array[0] = myval;\n  this._percolateDown(0);\n  return ans;\n};\n\n// recover unused memory (for long-running priority queues)\nFastPriorityQueue.prototype.trim = function() {\n  this.array = this.array.slice(0, this.size);\n};\n\n// Check whether the heap is empty\nFastPriorityQueue.prototype.isEmpty = function() {\n  return this.size === 0;\n};\n\n// iterate over the items in order, pass a callback that receives (item, index) as args.\n// TODO once we transpile, uncomment\n// if (Symbol && Symbol.iterator) {\n//   FastPriorityQueue.prototype[Symbol.iterator] = function*() {\n//     if (this.isEmpty()) return;\n//     var fpq = this.clone();\n//     while (!fpq.isEmpty()) {\n//       yield fpq.poll();\n//     }\n//   };\n// }\nFastPriorityQueue.prototype.forEach = function(callback) {\n  if (this.isEmpty() || typeof callback != 'function') return;\n  var i = 0;\n  var fpq = this.clone();\n  while (!fpq.isEmpty()) {\n    callback(fpq.poll(), i++);\n  }\n};\n\n// return the k 'smallest' elements of the queue\n// runs in O(k log k) time\n// this is the equivalent of repeatedly calling poll, but\n// it has a better computational complexity, which can be\n// important for large data sets.\nFastPriorityQueue.prototype.kSmallest = function(k) {\n  if (this.size == 0) return [];\n  var comparator = this.compare;\n  var arr = this.array\n  var fpq = new FastPriorityQueue(function(a,b){\n   return comparator(arr[a],arr[b]);\n  });\n  k = Math.min(this.size, k);\n  var smallest = new Array(k);\n  var j = 0;\n  fpq.add(0);\n  while (j < k) {\n    var small = fpq.poll();\n    smallest[j++] = this.array[small];\n    var l = (small << 1) + 1;\n    var r = l + 1;\n    if (l < this.size) fpq.add(l);\n    if (r < this.size) fpq.add(r);\n  }\n  return smallest;\n}\n\n// just for illustration purposes\nvar main = function() {\n  // main code\n  var x = new FastPriorityQueue(function(a, b) {\n    return a < b;\n  });\n  x.add(1);\n  x.add(0);\n  x.add(5);\n  x.add(4);\n  x.add(3);\n  while (!x.isEmpty()) {\n    console.log(x.poll());\n  }\n};\n\nif (__webpack_require__.c[__webpack_require__.s] === module) {\n  main();\n}\n\nmodule.exports = FastPriorityQueue;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmFzdHByaW9yaXR5cXVldWUvRmFzdFByaW9yaXR5UXVldWUuanM/ZDkzMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtCQUFrQjtBQUNsQjtBQUNhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDRDQUFZO0FBQ2hCO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdHByaW9yaXR5cXVldWUvRmFzdFByaW9yaXR5UXVldWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZhc3RQcmlvcml0eVF1ZXVlLmpzIDogYSBmYXN0IGhlYXAtYmFzZWQgcHJpb3JpdHkgcXVldWUgIGluIEphdmFTY3JpcHQuXG4gKiAoYykgdGhlIGF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuXG4gKlxuICogU3BlZWQtb3B0aW1pemVkIGhlYXAtYmFzZWQgcHJpb3JpdHkgcXVldWUgZm9yIG1vZGVybiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICpcbiAqIFVzYWdlIDpcbiAgICAgICAgIEluc3RhbGxhdGlvbiAoaW4gc2hlbGwsIGlmIHlvdSB1c2Ugbm9kZSk6XG4gICAgICAgICAkIG5wbSBpbnN0YWxsIGZhc3Rwcmlvcml0eXF1ZXVlXG5cbiAgICAgICAgIFJ1bm5pbmcgdGVzdCBwcm9ncmFtIChpbiBKYXZhU2NyaXB0KTpcblxuICAgICAgICAgLy8gdmFyIEZhc3RQcmlvcml0eVF1ZXVlID0gcmVxdWlyZShcImZhc3Rwcmlvcml0eXF1ZXVlXCIpOy8vIGluIG5vZGVcbiAgICAgICAgIHZhciB4ID0gbmV3IEZhc3RQcmlvcml0eVF1ZXVlKCk7XG4gICAgICAgICB4LmFkZCgxKTtcbiAgICAgICAgIHguYWRkKDApO1xuICAgICAgICAgeC5hZGQoNSk7XG4gICAgICAgICB4LmFkZCg0KTtcbiAgICAgICAgIHguYWRkKDMpO1xuICAgICAgICAgeC5wZWVrKCk7IC8vIHNob3VsZCByZXR1cm4gMCwgbGVhdmVzIHggdW5jaGFuZ2VkXG4gICAgICAgICB4LnNpemU7IC8vIHNob3VsZCByZXR1cm4gNSwgbGVhdmVzIHggdW5jaGFuZ2VkXG4gICAgICAgICB3aGlsZSgheC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgY29uc29sZS5sb2coeC5wb2xsKCkpO1xuICAgICAgICAgfSAvLyB3aWxsIHByaW50IDAgMSAzIDQgNVxuICAgICAgICAgeC50cmltKCk7IC8vIChvcHRpb25hbCkgb3B0aW1pemVzIG1lbW9yeSB1c2FnZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0Y29tcGFyYXRvciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiO1xufTtcblxuLy8gdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IgZnVuY3Rpb24gc2hvdWxkIHRha2UgYSwgYiBhbmQgcmV0dXJuICp0cnVlKiB3aGVuIGEgPCBiXG5mdW5jdGlvbiBGYXN0UHJpb3JpdHlRdWV1ZShjb21wYXJhdG9yKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGYXN0UHJpb3JpdHlRdWV1ZSkpIHJldHVybiBuZXcgRmFzdFByaW9yaXR5UXVldWUoY29tcGFyYXRvcik7XG4gIHRoaXMuYXJyYXkgPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5jb21wYXJlID0gY29tcGFyYXRvciB8fCBkZWZhdWx0Y29tcGFyYXRvcjtcbn1cblxuLy8gY29weSB0aGUgcHJpb3JpdHkgcXVldWUgaW50byBhbm90aGVyLCBhbmQgcmV0dXJuIGl0LiBRdWV1ZSBpdGVtcyBhcmUgc2hhbGxvdy1jb3BpZWQuXG4vLyBSdW5zIGluIGBPKG4pYCB0aW1lLlxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmcHEgPSBuZXcgRmFzdFByaW9yaXR5UXVldWUodGhpcy5jb21wYXJlKTtcbiAgZnBxLnNpemUgPSB0aGlzLnNpemU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICBmcHEuYXJyYXkucHVzaCh0aGlzLmFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gZnBxO1xufTtcblxuLy8gQWRkIGFuIGVsZW1lbnQgaW50byB0aGUgcXVldWVcbi8vIHJ1bnMgaW4gTyhsb2cgbikgdGltZVxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG15dmFsKSB7XG4gIHZhciBpID0gdGhpcy5zaXplO1xuICB0aGlzLmFycmF5W3RoaXMuc2l6ZV0gPSBteXZhbDtcbiAgdGhpcy5zaXplICs9IDE7XG4gIHZhciBwO1xuICB2YXIgYXA7XG4gIHdoaWxlIChpID4gMCkge1xuICAgIHAgPSAoaSAtIDEpID4+IDE7XG4gICAgYXAgPSB0aGlzLmFycmF5W3BdO1xuICAgIGlmICghdGhpcy5jb21wYXJlKG15dmFsLCBhcCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmFycmF5W2ldID0gYXA7XG4gICAgaSA9IHA7XG4gIH1cbiAgdGhpcy5hcnJheVtpXSA9IG15dmFsO1xufTtcblxuLy8gcmVwbGFjZSB0aGUgY29udGVudCBvZiB0aGUgaGVhcCBieSBwcm92aWRlZCBhcnJheSBhbmQgXCJoZWFwaWZ5IGl0XCJcbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHRoaXMuYXJyYXkgPSBhcnI7XG4gIHRoaXMuc2l6ZSA9IGFyci5sZW5ndGg7XG4gIHZhciBpO1xuICBmb3IgKGkgPSB0aGlzLnNpemUgPj4gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0aGlzLl9wZXJjb2xhdGVEb3duKGkpO1xuICB9XG59O1xuXG4vLyBmb3IgaW50ZXJuYWwgdXNlXG5GYXN0UHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX3BlcmNvbGF0ZVVwID0gZnVuY3Rpb24oaSwgZm9yY2UpIHtcbiAgdmFyIG15dmFsID0gdGhpcy5hcnJheVtpXTtcbiAgdmFyIHA7XG4gIHZhciBhcDtcbiAgd2hpbGUgKGkgPiAwKSB7XG4gICAgcCA9IChpIC0gMSkgPj4gMTtcbiAgICBhcCA9IHRoaXMuYXJyYXlbcF07XG4gICAgLy8gZm9yY2Ugd2lsbCBza2lwIHRoZSBjb21wYXJlXG4gICAgaWYgKCFmb3JjZSAmJiAhdGhpcy5jb21wYXJlKG15dmFsLCBhcCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmFycmF5W2ldID0gYXA7XG4gICAgaSA9IHA7XG4gIH1cbiAgdGhpcy5hcnJheVtpXSA9IG15dmFsO1xufTtcblxuLy8gZm9yIGludGVybmFsIHVzZVxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLl9wZXJjb2xhdGVEb3duID0gZnVuY3Rpb24oaSkge1xuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgdmFyIGhzaXplID0gdGhpcy5zaXplID4+PiAxO1xuICB2YXIgYWkgPSB0aGlzLmFycmF5W2ldO1xuICB2YXIgbDtcbiAgdmFyIHI7XG4gIHZhciBiZXN0YztcbiAgd2hpbGUgKGkgPCBoc2l6ZSkge1xuICAgIGwgPSAoaSA8PCAxKSArIDE7XG4gICAgciA9IGwgKyAxO1xuICAgIGJlc3RjID0gdGhpcy5hcnJheVtsXTtcbiAgICBpZiAociA8IHNpemUpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBhcmUodGhpcy5hcnJheVtyXSwgYmVzdGMpKSB7XG4gICAgICAgIGwgPSByO1xuICAgICAgICBiZXN0YyA9IHRoaXMuYXJyYXlbcl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5jb21wYXJlKGJlc3RjLCBhaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmFycmF5W2ldID0gYmVzdGM7XG4gICAgaSA9IGw7XG4gIH1cbiAgdGhpcy5hcnJheVtpXSA9IGFpO1xufTtcblxuLy8gaW50ZXJuYWxcbi8vIF9yZW1vdmVBdChpbmRleCkgd2lsbCByZW1vdmUgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4IGZyb20gdGhlIHF1ZXVlLFxuLy8gcmV0YWluaW5nIGJhbGFuY2UuIHJldHVybnMgdGhlIHJlbW92ZWQgaXRlbSwgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgaXMgcmVtb3ZlZC5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fcmVtb3ZlQXQgPSBmdW5jdGlvbihpbmRleCkge1xuICBpZiAoaW5kZXggPiB0aGlzLnNpemUgLSAxIHx8IGluZGV4IDwgMCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAvLyBpbXBsMTpcbiAgLy90aGlzLmFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gIC8vdGhpcy5oZWFwaWZ5KHRoaXMuYXJyYXkpO1xuICAvLyBpbXBsMjpcbiAgdGhpcy5fcGVyY29sYXRlVXAoaW5kZXgsIHRydWUpO1xuICByZXR1cm4gdGhpcy5wb2xsKCk7XG59O1xuXG4vLyByZW1vdmUobXl2YWwpIHdpbGwgcmVtb3ZlIGFuIGl0ZW0gbWF0Y2hpbmcgdGhlIHByb3ZpZGVkIHZhbHVlIGZyb20gdGhlXG4vLyBxdWV1ZSwgY2hlY2tlZCBmb3IgZXF1YWxpdHkgYnkgdXNpbmcgdGhlIHF1ZXVlJ3MgY29tcGFyYXRvci5cbi8vIHJldHVybiB0cnVlIGlmIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZS5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihteXZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBhcmUodGhpcy5hcnJheVtpXSwgbXl2YWwpICYmICF0aGlzLmNvbXBhcmUobXl2YWwsIHRoaXMuYXJyYXlbaV0pKSB7XG4gICAgICAvLyBpdGVtcyBtYXRjaCwgY29tcGFyYXRvciByZXR1cm5zIGZhbHNlIGJvdGggd2F5cywgcmVtb3ZlIGl0ZW1cbiAgICAgIHRoaXMuX3JlbW92ZUF0KGkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGludGVybmFsXG4vLyByZW1vdmVzIGFuZCByZXR1cm5zIGl0ZW1zIGZvciB3aGljaCB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVlLlxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLl9iYXRjaFJlbW92ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBsaW1pdCkge1xuICAvLyBpbml0aWFsaXplIHJldHVybiBhcnJheSB3aXRoIG1heCBzaXplIG9mIHRoZSBsaW1pdCBvciBjdXJyZW50IHF1ZXVlIHNpemVcbiAgdmFyIHJldEFyciA9IG5ldyBBcnJheShsaW1pdCA/IGxpbWl0IDogdGhpcy5zaXplKTtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nICYmIHRoaXMuc2l6ZSkge1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHRoaXMuc2l6ZSAmJiBjb3VudCA8IHJldEFyci5sZW5ndGgpIHtcbiAgICAgIGlmIChjYWxsYmFjayh0aGlzLmFycmF5W2ldKSkge1xuICAgICAgICByZXRBcnJbY291bnRdID0gdGhpcy5fcmVtb3ZlQXQoaSk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIC8vIG1vdmUgdXAgYSBsZXZlbCBpbiB0aGUgaGVhcCBpZiB3ZSByZW1vdmUgYW4gaXRlbVxuICAgICAgICBpID0gaSA+PiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gXG4gIH1cbiAgcmV0QXJyLmxlbmd0aCA9IGNvdW50O1xuICByZXR1cm4gcmV0QXJyO1xufVxuXG4vLyByZW1vdmVPbmUoY2FsbGJhY2spIHdpbGwgZXhlY3V0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbSBvZiB0aGUgcXVldWVcbi8vIGFuZCB3aWxsIHJlbW92ZSB0aGUgZmlyc3QgaXRlbSBmb3Igd2hpY2ggdGhlIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRydWUuXG4vLyByZXR1cm4gdGhlIHJlbW92ZWQgaXRlbSwgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgaXMgcmVtb3ZlZC5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZW1vdmVPbmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgYXJyID0gdGhpcy5fYmF0Y2hSZW1vdmUoY2FsbGJhY2ssIDEpO1xuICByZXR1cm4gYXJyLmxlbmd0aCA+IDAgPyBhcnJbMF0gOiB1bmRlZmluZWQ7XG59O1xuXG4vLyByZW1vdmUoY2FsbGJhY2tbLCBsaW1pdF0pIHdpbGwgZXhlY3V0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbSBvZlxuLy8gdGhlIHF1ZXVlIGFuZCB3aWxsIHJlbW92ZSBlYWNoIGl0ZW0gZm9yIHdoaWNoIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWUsIHVwIHRvXG4vLyBhIG1heCBsaW1pdCBvZiByZW1vdmVkIGl0ZW1zIGlmIHNwZWNpZmllZCBvciBubyBsaW1pdCBpZiB1bnNwZWNpZmllZC5cbi8vIHJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSByZW1vdmVkIGl0ZW1zLlxuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLnJlbW92ZU1hbnkgPSBmdW5jdGlvbihjYWxsYmFjaywgbGltaXQpIHtcbiAgcmV0dXJuIHRoaXMuX2JhdGNoUmVtb3ZlKGNhbGxiYWNrLCBsaW1pdCk7XG59O1xuXG4vLyBMb29rIGF0IHRoZSB0b3Agb2YgdGhlIHF1ZXVlIChvbmUgb2YgdGhlIHNtYWxsZXN0IGVsZW1lbnRzKSB3aXRob3V0IHJlbW92aW5nIGl0XG4vLyBleGVjdXRlcyBpbiBjb25zdGFudCB0aW1lXG4vL1xuLy8gQ2FsbGluZyBwZWVrIG9uIGFuIGVtcHR5IHByaW9yaXR5IHF1ZXVlIHJldHVybnNcbi8vIHRoZSBcInVuZGVmaW5lZFwiIHZhbHVlLlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvdW5kZWZpbmVkXG4vL1xuRmFzdFByaW9yaXR5UXVldWUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc2l6ZSA9PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICByZXR1cm4gdGhpcy5hcnJheVswXTtcbn07XG5cbi8vIHJlbW92ZSB0aGUgZWxlbWVudCBvbiB0b3Agb2YgdGhlIGhlYXAgKG9uZSBvZiB0aGUgc21hbGxlc3QgZWxlbWVudHMpXG4vLyBydW5zIGluIGxvZ2FyaXRobWljIHRpbWVcbi8vXG4vLyBJZiB0aGUgcHJpb3JpdHkgcXVldWUgaXMgZW1wdHksIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZVxuLy8gXCJ1bmRlZmluZWRcIiB2YWx1ZS5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL3VuZGVmaW5lZFxuLy9cbi8vIEZvciBsb25nLXJ1bm5pbmcgYW5kIGxhcmdlIHByaW9yaXR5IHF1ZXVlcywgb3IgcHJpb3JpdHkgcXVldWVzXG4vLyBzdG9yaW5nIGxhcmdlIG9iamVjdHMsIHlvdSBtYXkgIHdhbnQgdG8gY2FsbCB0aGUgdHJpbSBmdW5jdGlvblxuLy8gYXQgc3RyYXRlZ2ljIHRpbWVzIHRvIHJlY292ZXIgYWxsb2NhdGVkIG1lbW9yeS5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNpemUgPT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIGFucyA9IHRoaXMuYXJyYXlbMF07XG4gIGlmICh0aGlzLnNpemUgPiAxKSB7XG4gICAgdGhpcy5hcnJheVswXSA9IHRoaXMuYXJyYXlbLS10aGlzLnNpemVdO1xuICAgIHRoaXMuX3BlcmNvbGF0ZURvd24oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zaXplIC09IDE7XG4gIH1cbiAgcmV0dXJuIGFucztcbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWRkcyB0aGUgcHJvdmlkZWQgdmFsdWUgdG8gdGhlIGhlYXAsIHdoaWxlIHJlbW92aW5nXG4vLyBhbmQgcmV0dXJuaW5nIG9uZSBvZiB0aGUgc21hbGxlc3QgZWxlbWVudHMgKGxpa2UgcG9sbCkuIFRoZSBzaXplIG9mIHRoZSBxdWV1ZVxuLy8gdGh1cyByZW1haW5zIHVuY2hhbmdlZC5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZXBsYWNlVG9wID0gZnVuY3Rpb24obXl2YWwpIHtcbiAgaWYgKHRoaXMuc2l6ZSA9PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgYW5zID0gdGhpcy5hcnJheVswXTtcbiAgdGhpcy5hcnJheVswXSA9IG15dmFsO1xuICB0aGlzLl9wZXJjb2xhdGVEb3duKDApO1xuICByZXR1cm4gYW5zO1xufTtcblxuLy8gcmVjb3ZlciB1bnVzZWQgbWVtb3J5IChmb3IgbG9uZy1ydW5uaW5nIHByaW9yaXR5IHF1ZXVlcylcbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LnNsaWNlKDAsIHRoaXMuc2l6ZSk7XG59O1xuXG4vLyBDaGVjayB3aGV0aGVyIHRoZSBoZWFwIGlzIGVtcHR5XG5GYXN0UHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zaXplID09PSAwO1xufTtcblxuLy8gaXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBpbiBvcmRlciwgcGFzcyBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgKGl0ZW0sIGluZGV4KSBhcyBhcmdzLlxuLy8gVE9ETyBvbmNlIHdlIHRyYW5zcGlsZSwgdW5jb21tZW50XG4vLyBpZiAoU3ltYm9sICYmIFN5bWJvbC5pdGVyYXRvcikge1xuLy8gICBGYXN0UHJpb3JpdHlRdWV1ZS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKigpIHtcbi8vICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHJldHVybjtcbi8vICAgICB2YXIgZnBxID0gdGhpcy5jbG9uZSgpO1xuLy8gICAgIHdoaWxlICghZnBxLmlzRW1wdHkoKSkge1xuLy8gICAgICAgeWllbGQgZnBxLnBvbGwoKTtcbi8vICAgICB9XG4vLyAgIH07XG4vLyB9XG5GYXN0UHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLmlzRW1wdHkoKSB8fCB0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICB2YXIgaSA9IDA7XG4gIHZhciBmcHEgPSB0aGlzLmNsb25lKCk7XG4gIHdoaWxlICghZnBxLmlzRW1wdHkoKSkge1xuICAgIGNhbGxiYWNrKGZwcS5wb2xsKCksIGkrKyk7XG4gIH1cbn07XG5cbi8vIHJldHVybiB0aGUgayAnc21hbGxlc3QnIGVsZW1lbnRzIG9mIHRoZSBxdWV1ZVxuLy8gcnVucyBpbiBPKGsgbG9nIGspIHRpbWVcbi8vIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIHBvbGwsIGJ1dFxuLy8gaXQgaGFzIGEgYmV0dGVyIGNvbXB1dGF0aW9uYWwgY29tcGxleGl0eSwgd2hpY2ggY2FuIGJlXG4vLyBpbXBvcnRhbnQgZm9yIGxhcmdlIGRhdGEgc2V0cy5cbkZhc3RQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5rU21hbGxlc3QgPSBmdW5jdGlvbihrKSB7XG4gIGlmICh0aGlzLnNpemUgPT0gMCkgcmV0dXJuIFtdO1xuICB2YXIgY29tcGFyYXRvciA9IHRoaXMuY29tcGFyZTtcbiAgdmFyIGFyciA9IHRoaXMuYXJyYXlcbiAgdmFyIGZwcSA9IG5ldyBGYXN0UHJpb3JpdHlRdWV1ZShmdW5jdGlvbihhLGIpe1xuICAgcmV0dXJuIGNvbXBhcmF0b3IoYXJyW2FdLGFycltiXSk7XG4gIH0pO1xuICBrID0gTWF0aC5taW4odGhpcy5zaXplLCBrKTtcbiAgdmFyIHNtYWxsZXN0ID0gbmV3IEFycmF5KGspO1xuICB2YXIgaiA9IDA7XG4gIGZwcS5hZGQoMCk7XG4gIHdoaWxlIChqIDwgaykge1xuICAgIHZhciBzbWFsbCA9IGZwcS5wb2xsKCk7XG4gICAgc21hbGxlc3RbaisrXSA9IHRoaXMuYXJyYXlbc21hbGxdO1xuICAgIHZhciBsID0gKHNtYWxsIDw8IDEpICsgMTtcbiAgICB2YXIgciA9IGwgKyAxO1xuICAgIGlmIChsIDwgdGhpcy5zaXplKSBmcHEuYWRkKGwpO1xuICAgIGlmIChyIDwgdGhpcy5zaXplKSBmcHEuYWRkKHIpO1xuICB9XG4gIHJldHVybiBzbWFsbGVzdDtcbn1cblxuLy8ganVzdCBmb3IgaWxsdXN0cmF0aW9uIHB1cnBvc2VzXG52YXIgbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBtYWluIGNvZGVcbiAgdmFyIHggPSBuZXcgRmFzdFByaW9yaXR5UXVldWUoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhIDwgYjtcbiAgfSk7XG4gIHguYWRkKDEpO1xuICB4LmFkZCgwKTtcbiAgeC5hZGQoNSk7XG4gIHguYWRkKDQpO1xuICB4LmFkZCgzKTtcbiAgd2hpbGUgKCF4LmlzRW1wdHkoKSkge1xuICAgIGNvbnNvbGUubG9nKHgucG9sbCgpKTtcbiAgfVxufTtcblxuaWYgKHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XG4gIG1haW4oKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGYXN0UHJpb3JpdHlRdWV1ZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fastpriorityqueue/FastPriorityQueue.js\n");

/***/ }),

/***/ "./node_modules/iota-array/iota.js":
/*!*****************************************!*\
  !*** ./node_modules/iota-array/iota.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW90YS1hcnJheS9pb3RhLmpzPzIwMzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpb3RhKG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlvdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/iota-array/iota.js\n");

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzPzA0NGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/is-buffer/index.js\n");

/***/ }),

/***/ "./node_modules/ndarray/ndarray.js":
/*!*****************************************!*\
  !*** ./node_modules/ndarray/ndarray.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iota = __webpack_require__(/*! iota-array */ \"./node_modules/iota-array/iota.js\")\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzP2I1YmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLHFEQUFZO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxvREFBVzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0Msa0NBQWtDO0FBQ2xDLHdCQUF3QjtBQUN4Qix1QkFBdUIsV0FBVztBQUNsQyxhQUFhO0FBQ2IsbUJBQW1CO0FBQ25CLHdDQUF3QztBQUN4QztBQUNBLFdBQVcsc0NBQXNDO0FBQ2pELGlDQUFpQztBQUNqQyxzQkFBc0IsYUFBYTtBQUNuQywyQ0FBMkMsNkJBQTZCO0FBQ3hFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxjQUFjO0FBQ2Q7QUFDQSxFQUFFO0FBQ0Ysa0NBQWtDO0FBQ2xDLHdCQUF3QjtBQUN4Qix1QkFBdUIsb0JBQW9CO0FBQzNDLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxFQUFFO0FBQ0YseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQixFQUFFO0FBQ0YscURBQXFEO0FBQ3JEO0FBQ0EsR0FBRztBQUNILHdDQUF3QztBQUN4QztBQUNBLEVBQUU7QUFDRixpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNM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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoXCJpcy1idWZmZXJcIilcblxudmFyIGhhc1R5cGVkQXJyYXlzICA9ICgodHlwZW9mIEZsb2F0NjRBcnJheSkgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuXG4gIC8vQ3JlYXRlIGNvbnN0cnVjdG9yIGZvciB2aWV3XG4gIHZhciBpbmRpY2VzID0gaW90YShkaW1lbnNpb24pXG4gIHZhciBhcmdzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJpXCIraSB9KVxuICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgdmFyIHN0cmlkZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgY29kZS5wdXNoKFxuICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgIFwidGhpcy5zaGFwZT1bXCIgKyBzaGFwZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLnN0cmlkZT1bXCIgKyBzdHJpZGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgIFwidmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGVcIixcbiAgICBcInByb3RvLmR0eXBlPSdcIitkdHlwZStcIidcIixcbiAgICBcInByb3RvLmRpbWVuc2lvbj1cIitkaW1lbnNpb24pXG5cbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLnNoYXBlW1wiK2krXCJdXCIgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpXG4gICAgICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgIGNvZGUucHVzaChcblwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO1xcXG5pZihzMD5zMSl7XFxcbmlmKHMxPnMyKXtcXFxucmV0dXJuIFsyLDEsMF07XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsxLDIsMF07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzEsMCwyXTtcXFxufVxcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMiwwLDFdO1xcXG59ZWxzZSBpZihzMj5zMSl7XFxcbnJldHVybiBbMCwxLDJdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFswLDIsMV07XFxcbn19fSlcIilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cblxuICAvL3ZpZXcuaW5kZXg6XG4gIGNvZGUucHVzaChcbiAgICBcInByb3RvLmluZGV4PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9pbmRleChcIiwgYXJncy5qb2luKCksIFwiKXtyZXR1cm4gXCIraW5kZXhfc3RyK1wifVwiKVxuXG4gIC8vdmlldy5oaSgpOlxuICBjb2RlLnB1c2goXCJwcm90by5oaT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaGkoXCIrYXJncy5qb2luKFwiLFwiKStcIil7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBbXCIodHlwZW9mIGlcIixpLFwiIT09J251bWJlcid8fGlcIixpLFwiPDApP3RoaXMuc2hhcGVbXCIsIGksIFwiXTppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIraSArIFwiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCIgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIiB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG5cbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcblxuICAvL3ZpZXcudHJhbnNwb3NlKCk6XG4gIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICB2YXIgdFN0cmlkZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdFNoYXBlW2ldID0gXCJhW2lcIitpK1wiXVwiXG4gICAgdFN0cmlkZVtpXSA9IFwiYltpXCIraStcIl1cIlxuICB9XG4gIGNvZGUucHVzaChcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfdHJhbnNwb3NlKFwiK2FyZ3MrXCIpe1wiK1xuICAgIGFyZ3MubWFwKGZ1bmN0aW9uKG4saWR4KSB7IHJldHVybiBuICsgXCI9KFwiICsgbiArIFwiPT09dW5kZWZpbmVkP1wiICsgaWR4ICsgXCI6XCIgKyBuICsgXCJ8MClcIn0pLmpvaW4oXCI7XCIpLFxuICAgIFwidmFyIGE9dGhpcy5zaGFwZSxiPXRoaXMuc3RyaWRlO3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIit0U2hhcGUuam9pbihcIixcIikrXCIsXCIrdFN0cmlkZS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIraStcIl0qaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5zaGFwZVtcIitpK1wiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiK2krXCJdKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcblxuICAvL0FkZCByZXR1cm4gc3RhdGVtZW50XG4gIGNvZGUucHVzaChcInJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixvZmZzZXQpfVwiKVxuXG4gIC8vQ29tcGlsZSBwcm9jZWR1cmVcbiAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIkNUT1JfTElTVFwiLCBcIk9SREVSXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXSwgb3JkZXIpXG59XG5cbmZ1bmN0aW9uIGFycmF5RFR5cGUoZGF0YSkge1xuICBpZihpc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBcImJ1ZmZlclwiXG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3JcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ndarray/ndarray.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() {\n  return this || (typeof self === \"object\" && self);\n})() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcz9iYmRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGdFQUFXOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmKTtcbn0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime-module.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() {\n    return this || (typeof self === \"object\" && self);\n  })() || Function(\"return this\")()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzPzk2Y2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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ZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZik7XG4gIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx1REFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsS0FBSyxLQUF3QyxFQUFFLEVBRTdDOztBQUVGLFFBQVEsc0JBQWlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./src/math-util.js":
/*!**************************!*\
  !*** ./src/math-util.js ***!
  \**************************/
/*! exports provided: range, permutationGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"range\", function() { return range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"permutationGenerator\", function() { return permutationGenerator; });\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime-module.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__);\nvar _marked =\n/*#__PURE__*/\nregenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.mark(range),\n    _marked2 =\n/*#__PURE__*/\nregenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.mark(permutationGenerator);\n\n // returns generator over values in range\n// supports range(start, end[, step]) and range(end)\n// (start inclusive, end exclusive)\n// start = 0 by default\n// step = 1 by default\n\nfunction range() {\n  var start,\n      end,\n      step,\n      _len,\n      args,\n      _key,\n      i,\n      _i,\n      _args = arguments;\n\n  return regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function range$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = _args[_key];\n          }\n\n          if (args.length === 1) {\n            start = 0;\n            end = args[0];\n            step = 1;\n          } else if (args.length === 2) {\n            start = args[0];\n            end = args[1];\n            step = 1;\n          } else if (args.length === 3) {\n            start = args[0];\n            end = args[1];\n            step = args[2];\n          }\n\n          if (!(end > start)) {\n            _context.next = 14;\n            break;\n          }\n\n          if (!(step < 0)) {\n            _context.next = 5;\n            break;\n          }\n\n          throw new Error(\"Step must bring start closer to end\");\n\n        case 5:\n          i = start;\n\n        case 6:\n          if (!(i < end)) {\n            _context.next = 12;\n            break;\n          }\n\n          _context.next = 9;\n          return i;\n\n        case 9:\n          i += step;\n          _context.next = 6;\n          break;\n\n        case 12:\n          _context.next = 23;\n          break;\n\n        case 14:\n          if (!(step > 0)) {\n            _context.next = 16;\n            break;\n          }\n\n          throw new Error(\"Step must bring start closer to end\");\n\n        case 16:\n          _i = start;\n\n        case 17:\n          if (!(_i > end)) {\n            _context.next = 23;\n            break;\n          }\n\n          _context.next = 20;\n          return _i;\n\n        case 20:\n          _i += step;\n          _context.next = 17;\n          break;\n\n        case 23:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, this);\n} // TODO: consider moving to utility class\n// returns Generator over all permutations of values in arr with length r\n// adapted from python's itertools.permutations\n\n\nfunction permutationGenerator(arr) {\n  var r,\n      pool,\n      n,\n      inds,\n      cycles,\n      output,\n      i,\n      yielded,\n      _i2,\n      temp,\n      j,\n      swapInd,\n      _ref,\n      k,\n      _args2 = arguments;\n\n  return regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function permutationGenerator$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          r = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : arr.length;\n          pool = arr;\n          n = arr.length;\n          inds = Uint8Array.from(range(n));\n          cycles = Uint8Array.from(range(n, n - r, -1));\n          output = new Uint8Array(r);\n\n          for (i = 0; i < r; i++) {\n            output[i] = pool[inds[i]];\n          }\n\n          _context2.next = 9;\n          return output;\n\n        case 9:\n          yielded = true;\n\n        case 10:\n          if (!yielded) {\n            _context2.next = 37;\n            break;\n          }\n\n          yielded = false;\n          _i2 = r - 1;\n\n        case 13:\n          if (!(_i2 >= 0)) {\n            _context2.next = 35;\n            break;\n          }\n\n          cycles[_i2]--;\n\n          if (!(cycles[_i2] === 0)) {\n            _context2.next = 22;\n            break;\n          }\n\n          // moves inds[i] to end, push other inds left to fill space\n          temp = inds[_i2];\n          inds.copyWithin(_i2, _i2 + 1);\n          inds[inds.length - 1] = temp;\n          cycles[_i2] = n - _i2;\n          _context2.next = 32;\n          break;\n\n        case 22:\n          j = cycles[_i2];\n          swapInd = j === 0 ? 0 : inds.length - j;\n          _ref = [inds[swapInd], inds[_i2]];\n          inds[_i2] = _ref[0];\n          inds[swapInd] = _ref[1];\n\n          for (k = 0; k < r; k++) {\n            output[k] = pool[inds[k]];\n          }\n\n          _context2.next = 30;\n          return output;\n\n        case 30:\n          yielded = true;\n          return _context2.abrupt(\"break\", 35);\n\n        case 32:\n          _i2--;\n          _context2.next = 13;\n          break;\n\n        case 35:\n          _context2.next = 10;\n          break;\n\n        case 37:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, this);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC11dGlsLmpzP2VhYjEiXSwibmFtZXMiOlsicmFuZ2UiLCJwZXJtdXRhdGlvbkdlbmVyYXRvciIsImFyZ3MiLCJsZW5ndGgiLCJzdGFydCIsImVuZCIsInN0ZXAiLCJFcnJvciIsImkiLCJhcnIiLCJyIiwicG9vbCIsIm4iLCJpbmRzIiwiVWludDhBcnJheSIsImZyb20iLCJjeWNsZXMiLCJvdXRwdXQiLCJ5aWVsZGVkIiwidGVtcCIsImNvcHlXaXRoaW4iLCJqIiwic3dhcEluZCIsImsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Z0VBT1VBLEs7OztnRUE2QkFDLG9COztDQWxDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVVELEtBQVY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQ0FBbUJFLElBQW5CO0FBQW1CQSxnQkFBbkI7QUFBQTs7QUFFSSxjQUFJQSxJQUFJLENBQUNDLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkJDLGlCQUFLLEdBQUcsQ0FBUjtBQUNBQyxlQUFHLEdBQUdILElBQUksQ0FBQyxDQUFELENBQVY7QUFDQUksZ0JBQUksR0FBRyxDQUFQO0FBQ0gsV0FKRCxNQUlPLElBQUlKLElBQUksQ0FBQ0MsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUN6QkMsaUJBRHlCLEdBQ1hGLElBRFc7QUFDbEJHLGVBRGtCLEdBQ1hILElBRFc7QUFFMUJJLGdCQUFJLEdBQUcsQ0FBUDtBQUNILFdBSE0sTUFHQSxJQUFJSixJQUFJLENBQUNDLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDekJDLGlCQUR5QixHQUNMRixJQURLO0FBQ2xCRyxlQURrQixHQUNMSCxJQURLO0FBQ2JJLGdCQURhLEdBQ0xKLElBREs7QUFFN0I7O0FBWEwsZ0JBYVFHLEdBQUcsR0FBR0QsS0FiZDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxnQkFjWUUs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LENBQUNSLElBQUksQ0FBQ1MsT0FBRCxDQUFMLEVBQWdCVCxJQUFJLENBQUNMLEdBQUQsQ0FBcEIsQ0EzQjNDO0FBMkJpQkssY0FBSSxDQUFDTCxHQUFELENBM0JyQjtBQTJCMEJLLGNBQUksQ0FBQ1MsT0FBRCxDQTNCOUI7O0FBNkJnQixlQUFTQyxDQUFULEdBQWEsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHYixDQUFwQixFQUF1QmEsQ0FBQyxFQUF4QjtBQUE0Qk4sa0JBQU0sQ0FBQ00sQ0FBRCxDQUFOLEdBQVlaLElBQUksQ0FBQ0UsSUFBSSxDQUFDVSxDQUFELENBQUwsQ0FBaEI7QUFBNUI7O0FBN0JoQjtBQThCZ0IsaUJBQU1OLE1BQU47O0FBOUJoQjtBQWdDZ0JDLGlCQUFPLEdBQUcsSUFBVjtBQWhDaEI7O0FBQUE7QUFlbUNWLGFBQUMsRUFmcEM7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsImZpbGUiOiIuL3NyYy9tYXRoLXV0aWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVnZW5lcmF0b3JSdW50aW1lIGZyb20gXCJyZWdlbmVyYXRvci1ydW50aW1lXCJcblxuLy8gcmV0dXJucyBnZW5lcmF0b3Igb3ZlciB2YWx1ZXMgaW4gcmFuZ2Vcbi8vIHN1cHBvcnRzIHJhbmdlKHN0YXJ0LCBlbmRbLCBzdGVwXSkgYW5kIHJhbmdlKGVuZClcbi8vIChzdGFydCBpbmNsdXNpdmUsIGVuZCBleGNsdXNpdmUpXG4vLyBzdGFydCA9IDAgYnkgZGVmYXVsdFxuLy8gc3RlcCA9IDEgYnkgZGVmYXVsdFxuZnVuY3Rpb24qIHJhbmdlKC4uLmFyZ3MpIHtcbiAgICBsZXQgc3RhcnQsIGVuZCwgc3RlcDtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBhcmdzWzBdO1xuICAgICAgICBzdGVwID0gMTtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIFtzdGFydCwgZW5kXSA9IGFyZ3M7XG4gICAgICAgIHN0ZXAgPSAxO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgW3N0YXJ0LCBlbmQsIHN0ZXBdID0gYXJncztcbiAgICB9XG5cbiAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0ZXAgbXVzdCBicmluZyBzdGFydCBjbG9zZXIgdG8gZW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IHN0ZXApIHlpZWxkIGk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0ZXAgbXVzdCBicmluZyBzdGFydCBjbG9zZXIgdG8gZW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpID4gZW5kOyBpICs9IHN0ZXApIHlpZWxkIGk7XG4gICAgfVxufVxuXG4vLyBUT0RPOiBjb25zaWRlciBtb3ZpbmcgdG8gdXRpbGl0eSBjbGFzc1xuLy8gcmV0dXJucyBHZW5lcmF0b3Igb3ZlciBhbGwgcGVybXV0YXRpb25zIG9mIHZhbHVlcyBpbiBhcnIgd2l0aCBsZW5ndGggclxuLy8gYWRhcHRlZCBmcm9tIHB5dGhvbidzIGl0ZXJ0b29scy5wZXJtdXRhdGlvbnNcbmZ1bmN0aW9uKiBwZXJtdXRhdGlvbkdlbmVyYXRvcihhcnIsIHI9YXJyLmxlbmd0aCkge1xuICAgIGxldCBwb29sID0gYXJyO1xuICAgIGxldCBuID0gYXJyLmxlbmd0aDtcblxuICAgIGxldCBpbmRzID0gVWludDhBcnJheS5mcm9tKHJhbmdlKG4pKTtcbiAgICBsZXQgY3ljbGVzID0gVWludDhBcnJheS5mcm9tKHJhbmdlKG4sIG4gLSByLCAtMSkpO1xuXG4gICAgbGV0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrKSBvdXRwdXRbaV0gPSBwb29sW2luZHNbaV1dO1xuICAgIHlpZWxkIG91dHB1dDtcblxuICAgIGxldCB5aWVsZGVkID0gdHJ1ZTtcblxuICAgIHdoaWxlICh5aWVsZGVkKSB7XG4gICAgICAgIHlpZWxkZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHIgLSAxOyBpID49MDsgaS0tKSB7XG4gICAgICAgICAgICBjeWNsZXNbaV0tLTtcbiAgICAgICAgICAgIGlmIChjeWNsZXNbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlcyBpbmRzW2ldIHRvIGVuZCwgcHVzaCBvdGhlciBpbmRzIGxlZnQgdG8gZmlsbCBzcGFjZVxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gaW5kc1tpXTtcbiAgICAgICAgICAgICAgICBpbmRzLmNvcHlXaXRoaW4oaSwgaSArIDEpO1xuICAgICAgICAgICAgICAgIGluZHNbaW5kcy5sZW5ndGggLSAxXSA9IHRlbXA7XG5cbiAgICAgICAgICAgICAgICBjeWNsZXNbaV0gPSBuIC0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGogPSBjeWNsZXNbaV07XG4gICAgICAgICAgICAgICAgbGV0IHN3YXBJbmQgPSBqID09PSAwID8gMCA6IGluZHMubGVuZ3RoIC0gajtcbiAgICAgICAgICAgICAgICBbaW5kc1tpXSwgaW5kc1tzd2FwSW5kXV0gPSBbaW5kc1tzd2FwSW5kXSwgaW5kc1tpXV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHI7IGsrKykgb3V0cHV0W2tdID0gcG9vbFtpbmRzW2tdXTtcbiAgICAgICAgICAgICAgICB5aWVsZCBvdXRwdXQ7XG5cbiAgICAgICAgICAgICAgICB5aWVsZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHtyYW5nZSwgcGVybXV0YXRpb25HZW5lcmF0b3J9Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/math-util.js\n");

/***/ }),

/***/ "./src/script.js":
/*!***********************!*\
  !*** ./src/script.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var cropperjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cropperjs */ \"./node_modules/cropperjs/dist/cropper.esm.js\");\n/* harmony import */ var _sliding_puzzle_algorithms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sliding-puzzle-algorithms */ \"./src/sliding-puzzle-algorithms.js\");\n/* harmony import */ var _node_modules_cropperjs_dist_cropper_min_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/cropperjs/dist/cropper.min.css */ \"./node_modules/cropperjs/dist/cropper.min.css\");\n/* harmony import */ var _node_modules_cropperjs_dist_cropper_min_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_cropperjs_dist_cropper_min_css__WEBPACK_IMPORTED_MODULE_2__);\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// TODO: consider adding compression plugin to webpack\n// TODO: consider changing to vertical orientation if screen too narrow or input images are landscape orientation\n// TODO: decrease resolution of pictures to make cropping and moving tiles faster\n// TODO: consider cropping images and getting rid of svg-limit cropping for performance\n// TODO: implement IDA* to solve 4x4 puzzles\n// TODO: implement non-optimal solver for puzzles 4x4 and larger\n// TODO: consider moving all node_modules into dev dependencies since they are bundled\n// TODO: consider implementing \"play\" button disabling drag/select and only allowing arrow key movement and change drag/click to animate moves to neighboring tiles\n\n\n // TODO: uglify+minify re-enable after finish\n// TODO: reorganize: validation functions separate js file\n// TODO: consider moving each page to separate js file, with page manager switching between them\n\n(function () {\n  var Util =\n  /*#__PURE__*/\n  function () {\n    function Util() {\n      _classCallCheck(this, Util);\n    }\n\n    _createClass(Util, null, [{\n      key: \"hide\",\n      value: function hide(e) {\n        e = e instanceof d3.selection ? e : d3.select(e);\n        e.style('display', 'none');\n      }\n    }, {\n      key: \"show\",\n      value: function show(e) {\n        e = e instanceof d3.selection ? e : d3.select(e);\n        e.style('display', '');\n      }\n    }, {\n      key: \"toggle\",\n      value: function toggle(e) {\n        e = e instanceof d3.selection ? e : d3.select(e);\n        e.style('display', e.style('display') === 'none' ? '' : 'none');\n      }\n    }]);\n\n    return Util;\n  }();\n\n  ;\n  var container = d3.select('.container-fluid');\n  var messages = container.select('#messages'),\n      instructionDiv = messages.select('#instructions'),\n      warningDiv = messages.select('#warning'),\n      warningMessage = messages.select('#warning-message'),\n      errorDiv = messages.select('#error'),\n      errorMessage = messages.select('#error-message');\n  var imageUploadPage = d3.select('#image-upload-page'),\n      imageContainer = d3.select('#image-upload-container'),\n      imageRow = d3.select('#image-row'),\n      instructions = d3.select('#instructions');\n  var puzzlePage = d3.select('#puzzle-page'),\n      puzzleContainer = d3.select('#puzzle-container'); //--------------------------------------------------------------------------------------------------------\n  // IMAGE UPLOAD PAGE\n  //--------------------------------------------------------------------------------------------------------\n\n  var imageForm = d3.select('#image-form');\n  var imgUrlInput = d3.select('#image-url'),\n      imgFileInput = d3.select('#upload-img-input'),\n      imgFeedback = d3.select('#image-url ~ .invalid-feedback');\n  var img = d3.select('#uploaded-image');\n  var cropper = new cropperjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](img.node(), {\n    viewMode: 2,\n    guides: false,\n    center: false,\n    autoCropArea: 1,\n    dragMode: 'move'\n  });\n  var puzzleConfigForm = d3.select('#puzzle-config-form');\n  var rowSubmit = true,\n      colSubmit = true;\n  var rowInput = d3.select('#num-rows'),\n      rowFeedback = d3.select('#num-rows ~ .invalid-feedback');\n  var colInput = d3.select('#num-cols'),\n      colFeedback = d3.select('#num-cols ~ .invalid-feedback');\n  var cropButton = d3.select('#crop-image-button');\n  rowInput.on('input', validateRows);\n  colInput.on('input', validateColumns);\n  imageForm.on('submit', function () {\n    d3.event.stopPropagation();\n    d3.event.preventDefault();\n  });\n\n  function validateRows() {\n    // would be better if execution short-circuited but OK given low complexity of validation\n    // possible implementation: function as class instead, with params in constructor\n    // and execute() function to actually validate, called in processResponses()\n    rowSubmit = processResponses([numberValidation(rowInput, rowFeedback), twoInputValidation()], rowInput, rowFeedback);\n    cropButton.property('disabled', !rowSubmit || !colSubmit);\n  }\n\n  function validateColumns() {\n    colSubmit = processResponses([numberValidation(colInput, colFeedback)], colInput, colFeedback); // called separately as change in status of twoInputValidation means numberValidation\n    // needs to be checked to see what is displayed on row feedback\n\n    validateRows();\n  } // shows feedback for input based on responses [{status: 'valid'/'invalid'/'warning', message: '...'}, ...]\n  // returns whether input validation allows submission\n\n\n  function processResponses(responses, input, feedback) {\n    var warning;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = responses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _step$value = _step.value,\n            status = _step$value.status,\n            message = _step$value.message;\n\n        if (status === 'invalid') {\n          showError(input, feedback, message);\n          return false;\n        } else if (status === 'warning') {\n          // store instead of showing immediately to allow detection of errors in next responses\n          warning = message;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (warning) {\n      showWarning(input, feedback, warning);\n      return true;\n    }\n\n    hideMessages(input, feedback);\n    return true;\n  }\n\n  function showError(input, feedback, message) {\n    input.classed('has-warning', false);\n    input.classed('is-invalid', true);\n    feedback.classed('warning-feedback', false);\n    feedback.classed('invalid-feedback', true);\n    feedback.text(message);\n  }\n\n  function showWarning(input, feedback, message) {\n    input.classed('has-warning', true);\n    input.classed('is-invalid', false);\n    feedback.classed('warning-feedback', true);\n    feedback.classed('invalid-feedback', false);\n    feedback.text(message);\n  }\n\n  function hideMessages(input, feedback) {\n    input.classed('is-invalid', false);\n    input.classed('has-warning', false);\n    feedback.classed('invalid-feedback', false);\n    feedback.classed('warning-feedback', false);\n    feedback.text('');\n  }\n\n  function twoInputValidation() {\n    var numRows = +rowInput.property('value');\n    var numCols = +colInput.property('value');\n\n    if (numRows === numCols && numRows === 1) {\n      return {\n        status: 'invalid',\n        message: 'Cannot create 1x1 puzzles'\n      };\n    }\n\n    var numTiles = numCols * numRows;\n\n    if (numTiles > 400) {\n      return {\n        status: 'invalid',\n        message: 'Cannot create puzzle with more than 400 tiles (may crash your browser)'\n      };\n    }\n\n    if (numTiles > 12) {\n      return {\n        status: 'warning',\n        message: 'Caution: this site may not be able to optimally solve puzzles with more than 12 tiles'\n      };\n    }\n\n    if (numRows > 1 && numCols > 5 || numCols > 1 && numRows > 5) {\n      return {\n        status: 'warning',\n        message: 'Caution: this site may not be able to optimally solve 2D puzzles with a dimension\\\n                > 5'\n      };\n    }\n\n    return {\n      status: 'valid'\n    };\n  }\n\n  function numberValidation(input, feedback) {\n    var val = +input.property('value');\n\n    if (!Number.isInteger(val) || val < 1) {\n      return {\n        status: 'invalid',\n        message: 'Number must be positive integer'\n      };\n    }\n\n    return {\n      status: 'valid'\n    };\n  }\n\n  imgUrlInput.on('input', function () {\n    var _this = this;\n\n    var url = this.value;\n\n    if (url === '') {\n      hideMessages(imgUrlInput, imgFeedback);\n      return;\n    }\n\n    var img = new Image();\n\n    img.onerror = function () {\n      showError(imgUrlInput, imgFeedback, 'Image could not be loaded');\n    };\n\n    img.onload = function () {\n      cropper.replace(_this.value);\n      hideMessages(imgUrlInput, imgFeedback);\n    };\n\n    img.src = url;\n  });\n  imgFileInput.on('change', function () {\n    imgUrlInput.property('value', '');\n    var imgUpload = imgFileInput.property('files')[0];\n\n    if (imgUpload.type.includes('image')) {\n      var reader = new FileReader();\n\n      reader.onload = function (e) {\n        cropper.replace(e.target.result);\n      };\n\n      reader.readAsDataURL(imgUpload);\n      hideMessages(imgUrlInput, imgFeedback);\n    } else {\n      showError(imgUrlInput, imgFeedback, 'Uploaded file must be an image');\n    }\n  });\n  puzzleConfigForm.on('submit', function () {\n    d3.event.preventDefault();\n    d3.event.stopPropagation();\n\n    if (rowSubmit && colSubmit) {\n      imageContainer.remove();\n      var numRows = +rowInput.property('value');\n      var numCols = +colInput.property('value');\n      Util.hide(imageUploadPage);\n      Util.show(puzzlePage);\n\n      var _cropper$getCropBoxDa = cropper.getCropBoxData(),\n          width = _cropper$getCropBoxDa.width,\n          height = _cropper$getCropBoxDa.height;\n\n      splitImage(cropper.getCroppedCanvas().toDataURL(), width, height, numRows, numCols);\n    }\n  }); //--------------------------------------------------------------------------------------------------------\n  // PUZZLE PAGE\n  //--------------------------------------------------------------------------------------------------------\n\n  function splitImage(src, width, height, numRows, numCols) {\n    // TODO: stop relying on iteration limit and use memory/time limit instead\n    // (since larger puzzles make iterations take longer)\n    var strings = {\n      errors: {\n        unsolvable: 'Puzzle is unsolvable. Try swapping tiles in your goal and/or start state;\\\n                        simply sliding tiles around will not affect puzzle solvability.',\n        iterationLimit: 'Puzzle took too long to solve; further solve-time could crash your browser.'\n      },\n      warnings: {\n        solvability: 'Be careful when swapping and deleting tiles; not all puzzle-states are solvable.'\n      }\n    };\n    Util.show(warningDiv);\n    warningMessage.text(strings.warnings.solvability);\n    var maxGridHeight = 110;\n    var maxGridWidth = 110;\n    var gridWidth, gridHeight; // preserves aspect ratio of cropped image, with largest dim set to max dim above\n\n    if (width > height) {\n      gridWidth = maxGridWidth;\n      gridHeight = maxGridHeight * height / width;\n    } else {\n      gridHeight = maxGridHeight;\n      gridWidth = maxGridWidth * width / height;\n    }\n\n    var viewBox = {\n      x: 0,\n      y: 0,\n      width: 300,\n      height: gridHeight + 30\n    }; // NOTE: height not set in svg as overwritten by viewBox height scaling to width\n\n    var svg = puzzleContainer.append('svg').attr('width', '100%').attr('viewBox', \"\".concat(viewBox.x, \" \").concat(viewBox.y, \" \").concat(viewBox.width, \" \").concat(viewBox.height));\n    svg.append('defs').append('filter').attr('id', 'shadow').append('feDropShadow').attr('dx', 0).attr('dy', 0).attr('stdDeviation', 3);\n    var gridPadding = (300 - gridWidth * 2) / 3; // NOTE: 0.5 positioning helps make outlines crisper (as coords map to pixel square intersections)\n    // - also helps prevent noticeable outline darkening in outline coord overlap for same reason\n    // - difference can be seen more easily when strokeWidth increased\n\n    var startGrid = new StartGrid(svg, gridPadding, 20.5, numRows, numCols, src, {\n      height: gridHeight,\n      width: gridWidth\n    }).draw();\n    var goalGrid = new GoalGrid(svg, viewBox.width - gridPadding - gridWidth, 20.5, numRows, numCols, {\n      height: gridHeight,\n      width: gridWidth\n    }).draw();\n    var tileNumberSize = Math.min(gridHeight / numRows / 2, gridWidth / numCols / 2);\n    startGrid.tileNumbers.style('font-size', \"\".concat(tileNumberSize, \"px\"));\n    goalGrid.tileNumbers.style('font-size', \"\".concat(tileNumberSize, \"px\")); // NOTE: not inside Grid as not sure if want to display label\n    // Adding label would make tile coords a little more confusing\n\n    var startLabel = startGrid.container.append('text').attr('x', startGrid.x + startGrid.width / 2).attr('y', startGrid.y - 5).text('Start').classed('grid-title', true);\n    var goalLabel = goalGrid.container.append('text').attr('x', goalGrid.x + goalGrid.width / 2).attr('y', goalGrid.y - 5).text('Goal').classed('grid-title', true);\n    var buttonRight = svg.append('image').attr('x', startGrid.x + gridWidth + gridPadding / 2 - 8).attr('y', '50%').attr('width', 16).attr('height', 16).attr('href', 'icons/right-chevron.svg').classed('puzzle-arrow', true).on('click', function () {\n      startGrid.cloneTilesTo(goalGrid);\n      Util.hide(errorDiv);\n      checkSolvability();\n    });\n    var buttonToolbar = puzzlePage.append('div').attr('class', 'btn-toolbar mb-2 justify-content-center');\n    var puzzleButtons = buttonToolbar.append('div').attr('class', 'btn-group mr-2 my-1');\n    var overlayButtons = buttonToolbar.append('div').attr('class', 'btn-group my-1');\n    var solutionPanel = puzzlePage.append('div').attr('class', 'card').style('display', 'none');\n    var solutionPanelHeading = solutionPanel.append('div').attr('class', 'card-header').text('Solution');\n    var solutionPanelBody = solutionPanel.append('div').attr('class', 'card-body').style('max-height', '100px').style('overflow-y', 'scroll'); // NOTE: assumes starting state is solvable\n\n    var shuffleButton = puzzleButtons.append('button').attr('class', 'btn btn-secondary').attr('id', 'shuffle-button').property('disabled', true).text('Shuffle') // don't want to pass in \"this\" from click\n    .on('click', function () {\n      startGrid.shuffle();\n      Util.hide(errorDiv);\n    }); // TODO: consider having animations return promise that resolves after everything animated\n    // that way, can disable and enable solve/shuffle after promise resolves\n    // also add loading indication (at minimum, show loading cursor)\n\n    var solveButton = puzzleButtons.append('button').property('disabled', true).attr('class', 'btn btn-secondary').attr('id', 'solve-button').text('Solve').on('click', function () {\n      var puzzle = new _sliding_puzzle_algorithms__WEBPACK_IMPORTED_MODULE_1__[\"default\"](numRows, numCols, Grid.getArrayRepresentation(startGrid, goalGrid), startGrid.emptyPos);\n\n      try {\n        var ans = puzzle.solve();\n        Util.show(solutionPanel);\n        startGrid.animateMoves(ans, solutionPanelBody);\n      } catch (error) {\n        console.log(error);\n\n        if (error.message === 'Max number of iterations exceeded') {\n          Util.show(errorDiv);\n          errorMessage.text(strings.errors.iterationLimit);\n          errorDiv.node().scrollIntoView();\n        }\n      }\n    });\n    var resetPuzzleButton = puzzleButtons.append('button').attr('class', 'btn btn-secondary').attr('id', 'reset-puzzle-button').text('Reset').on('click', function () {\n      startGrid.resetTiles();\n      goalGrid.resetTiles();\n      Util.hide(solutionPanel);\n      solveButton.property('disabled', true); // switches mode to tile deletion mode\n\n      if (toggleMouseModeButton.text() === 'Tile Deletion Mode') {\n        toggleMouseModeButton.node().click();\n      }\n\n      toggleMouseModeButton.property('disabled', true);\n      shuffleButton.property('disabled', true);\n      Util.hide(errorDiv);\n    });\n    var numberOverlayButton = overlayButtons.append('button').attr('class', 'btn btn-secondary').attr('id', 'number-overlay-button').text('Show Number Overlay').on('click', function () {\n      startGrid.toggleNumberOverlay();\n      goalGrid.toggleNumberOverlay();\n      var text = numberOverlayButton.text() === 'Show Number Overlay' ? 'Hide Number Overlay' : 'Show Number Overlay';\n      numberOverlayButton.text(text);\n    });\n    var toggleMouseModeButton = overlayButtons.append('button') // cannot start moving tiles until one is deleted (empty position chosen)\n    .property('disabled', true).attr('class', 'btn btn-secondary').attr('id', 'toggle-mouse-mode-button').text('Tile Selection Mode').on('click', function () {\n      startGrid.toggleTileOverlay();\n      goalGrid.toggleTileOverlay();\n      var button = d3.select(this);\n      var text = button.text() === 'Tile Deletion Mode' ? 'Tile Selection Mode' : 'Tile Deletion Mode';\n      button.text(text);\n      startGrid.deselectAll();\n      goalGrid.deselectAll();\n    }); // TODO: consider looking into drop handler instead of getting tile from (x, y) in Grid\n\n    var dragHandler = d3.drag().subject(function (d) {\n      return {\n        x: d.cell.x,\n        y: d.cell.y\n      };\n    }) // don't drag tile if in delete mode or tile is empty\n    .filter(function (d) {\n      return !d.grid.deleteOverlay && !d.grid.hasEmptyTile(d.tile);\n    }).on('drag', function (d) {\n      // console.log('dragging');\n      d3.select(this).classed('dragging', true); // NOTE: raise() executes in 'drag' rather than 'start' as appendChild (called by raise())\n      // prevents call of click handler (undesirable, since 'start' is called on clicks)\n      // NOTE: not as inefficient as it may seem, as function only moves container\n      // if it is not last element in parent\n      // moves container of tile to front so that dragged tile drawn above other puzzle\n\n      d.grid.container.raise(); // moves tile to front so drawn in front of other tiles\n\n      d.tile.raise();\n      d.grid.container.node().focus();\n      d3.select(this).attr('x', d3.event.x).attr('y', d3.event.y);\n    }) // NOTE: d3 still calls start and end on click (fires before click handler)\n    .on('end', function (d) {\n      // console.log('drag end');\n      d3.select(this).classed('dragging', false); // return original image to starting position on release\n\n      var tileContainer = d3.select(this).attr('x', d.cell.x).attr('y', d.cell.y);\n\n      var _d3$mouse = d3.mouse(svg.node()),\n          _d3$mouse2 = _slicedToArray(_d3$mouse, 2),\n          mouseX = _d3$mouse2[0],\n          mouseY = _d3$mouse2[1];\n\n      if (!goalGrid.dropTile(tileContainer, mouseX, mouseY)) {\n        startGrid.dropTile(tileContainer, mouseX, mouseY);\n        checkSolvability();\n      }\n\n      checkSolvability();\n    });\n    startGrid.tileContainers.call(dragHandler);\n    goalGrid.tileContainers.call(dragHandler);\n    startGrid.tileContainers.on('click', function (d) {\n      var result = startGrid.clickTile(this);\n\n      if (result.method === 'delete') {\n        goalGrid.deleteTileWithStartingTile(result.tile);\n        toggleMouseModeButton.property('disabled', false);\n        shuffleButton.property('disabled', false);\n      } else if (result.method === 'select' && goalGrid.selectedTiles.size === 1) {\n        var goalTile = goalGrid.selectedTiles.values().next().value; // empty tiles cannot be cloned to goal Tile\n\n        if (!startGrid.hasEmptyTile(result.tile)) {\n          Grid.cloneTile(result.tile, goalTile);\n          goalGrid.deselectTile(goalTile);\n          startGrid.deselectTile(result.tile);\n        }\n      }\n\n      checkSolvability();\n    });\n    goalGrid.tileContainers.on('click', function (d) {\n      var result = goalGrid.clickTile(this);\n\n      if (result.method === 'select' && startGrid.selectedTiles.size === 1) {\n        var startTile = startGrid.selectedTiles.values().next().value; // empty tiles cannot be cloned to goal Tile\n\n        if (!startGrid.hasEmptyTile(startTile)) {\n          Grid.cloneTile(startTile, result.tile);\n          goalGrid.deselectTile(result.tile);\n          startGrid.deselectTile(startTile);\n        }\n      }\n\n      checkSolvability();\n    }); // TODO: consider allowing movement of selected tile (mainly for moving tiles in partially assigned goal)\n    // TODO: consider deselecting tile if it's dragged or dropped onto\n    // TODO: consider overwriting tile rather than swapping them when a tile with match is dragged to an occupied tile\n\n    var arrowMovementHandler = function arrowMovementHandler(selectedGrid) {\n      var key = d3.event.key;\n      var KEY_MAPPING = {\n        'ArrowLeft': 'l',\n        'ArrowRight': 'r',\n        'ArrowUp': 'u',\n        'ArrowDown': 'd',\n        'w': 'u',\n        'a': 'l',\n        's': 'd',\n        'd': 'r'\n      };\n      var move = KEY_MAPPING[key];\n\n      if (move) {\n        // prevents arrow keys from scrolling screen\n        d3.event.preventDefault();\n        selectedGrid.animateMove(move);\n      }\n    };\n\n    startGrid.container.on('keydown', arrowMovementHandler);\n    goalGrid.container.on('keydown', arrowMovementHandler);\n\n    function checkSolvability() {\n      if (startGrid.emptyPos !== null && goalGrid.isFull()) {\n        if (Grid.isSolvable(startGrid, goalGrid)) {\n          Util.hide(errorDiv);\n          solveButton.property('disabled', false);\n          return true;\n        }\n\n        errorMessage.text(strings.errors.unsolvable);\n        Util.show(errorDiv);\n        errorDiv.node().scrollIntoView();\n      }\n\n      solveButton.property('disabled', true);\n      return false;\n    } //--------------------------------------------------------------------------------------------------------\n\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0LmpzPzY4YjAiXSwibmFtZXMiOlsiVXRpbCIsImUiLCJkMyIsInNlbGVjdGlvbiIsInNlbGVjdCIsInN0eWxlIiwiY29udGFpbmVyIiwibWVzc2FnZXMiLCJpbnN0cnVjdGlvbkRpdiIsIndhcm5pbmdEaXYiLCJ3YXJuaW5nTWVzc2FnZSIsImVycm9yRGl2IiwiZXJyb3JNZXNzYWdlIiwiaW1hZ2VVcGxvYWRQYWdlIiwiaW1hZ2VDb250YWluZXIiLCJpbWFnZVJvdyIsImluc3RydWN0aW9ucyIsInB1enpsZVBhZ2UiLCJwdXp6bGVDb250YWluZXIiLCJpbWFnZUZvcm0iLCJpbWdVcmxJbnB1dCIsImltZ0ZpbGVJbnB1dCIsImltZ0ZlZWRiYWNrIiwiaW1nIiwiY3JvcHBlciIsIkNyb3BwZXIiLCJub2RlIiwidmlld01vZGUiLCJndWlkZXMiLCJjZW50ZXIiLCJhdXRvQ3JvcEFyZWEiLCJkcmFnTW9kZSIsInB1enpsZUNvbmZpZ0Zvcm0iLCJyb3dTdWJtaXQiLCJjb2xTdWJtaXQiLCJyb3dJbnB1dCIsInJvd0ZlZWRiYWNrIiwiY29sSW5wdXQiLCJjb2xGZWVkYmFjayIsImNyb3BCdXR0b24iLCJvbiIsInZhbGlkYXRlUm93cyIsInZhbGlkYXRlQ29sdW1ucyIsImV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJwcm9jZXNzUmVzcG9uc2VzIiwibnVtYmVyVmFsaWRhdGlvbiIsInR3b0lucHV0VmFsaWRhdGlvbiIsInByb3BlcnR5IiwicmVzcG9uc2VzIiwiaW5wdXQiLCJmZWVkYmFjayIsIndhcm5pbmciLCJzdGF0dXMiLCJtZXNzYWdlIiwic2hvd0Vycm9yIiwic2hvd1dhcm5pbmciLCJoaWRlTWVzc2FnZXMiLCJjbGFzc2VkIiwidGV4dCIsIm51bVJvd3MiLCJudW1Db2xzIiwibnVtVGlsZXMiLCJ2YWwiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ1cmwiLCJ2YWx1ZSIsIkltYWdlIiwib25lcnJvciIsIm9ubG9hZCIsInJlcGxhY2UiLCJzcmMiLCJpbWdVcGxvYWQiLCJ0eXBlIiwiaW5jbHVkZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwidGFyZ2V0IiwicmVzdWx0IiwicmVhZEFzRGF0YVVSTCIsInJlbW92ZSIsImhpZGUiLCJzaG93IiwiZ2V0Q3JvcEJveERhdGEiLCJ3aWR0aCIsImhlaWdodCIsInNwbGl0SW1hZ2UiLCJnZXRDcm9wcGVkQ2FudmFzIiwidG9EYXRhVVJMIiwic3RyaW5ncyIsImVycm9ycyIsInVuc29sdmFibGUiLCJpdGVyYXRpb25MaW1pdCIsIndhcm5pbmdzIiwic29sdmFiaWxpdHkiLCJtYXhHcmlkSGVpZ2h0IiwibWF4R3JpZFdpZHRoIiwiZ3JpZFdpZHRoIiwiZ3JpZEhlaWdodCIsInZpZXdCb3giLCJ4IiwieSIsInN2ZyIsImFwcGVuZCIsImF0dHIiLCJncmlkUGFkZGluZyIsInN0YXJ0R3JpZCIsIlN0YXJ0R3JpZCIsImRyYXciLCJnb2FsR3JpZCIsIkdvYWxHcmlkIiwidGlsZU51bWJlclNpemUiLCJNYXRoIiwibWluIiwidGlsZU51bWJlcnMiLCJzdGFydExhYmVsIiwiZ29hbExhYmVsIiwiYnV0dG9uUmlnaHQiLCJjbG9uZVRpbGVzVG8iLCJjaGVja1NvbHZhYmlsaXR5IiwiYnV0dG9uVG9vbGJhciIsInB1enpsZUJ1dHRvbnMiLCJvdmVybGF5QnV0dG9ucyIsInNvbHV0aW9uUGFuZWwiLCJzb2x1dGlvblBhbmVsSGVhZGluZyIsInNvbHV0aW9uUGFuZWxCb2R5Iiwic2h1ZmZsZUJ1dHRvbiIsInNodWZmbGUiLCJzb2x2ZUJ1dHRvbiIsInB1enpsZSIsIlB1enpsZSIsIkdyaWQiLCJnZXRBcnJheVJlcHJlc2VudGF0aW9uIiwiZW1wdHlQb3MiLCJhbnMiLCJzb2x2ZSIsImFuaW1hdGVNb3ZlcyIsImVycm9yIiwiY29uc29sZSIsImxvZyIsInNjcm9sbEludG9WaWV3IiwicmVzZXRQdXp6bGVCdXR0b24iLCJyZXNldFRpbGVzIiwidG9nZ2xlTW91c2VNb2RlQnV0dG9uIiwiY2xpY2siLCJudW1iZXJPdmVybGF5QnV0dG9uIiwidG9nZ2xlTnVtYmVyT3ZlcmxheSIsInRvZ2dsZVRpbGVPdmVybGF5IiwiYnV0dG9uIiwiZGVzZWxlY3RBbGwiLCJkcmFnSGFuZGxlciIsImRyYWciLCJzdWJqZWN0IiwiZCIsImNlbGwiLCJmaWx0ZXIiLCJncmlkIiwiZGVsZXRlT3ZlcmxheSIsImhhc0VtcHR5VGlsZSIsInRpbGUiLCJyYWlzZSIsImZvY3VzIiwidGlsZUNvbnRhaW5lciIsIm1vdXNlIiwibW91c2VYIiwibW91c2VZIiwiZHJvcFRpbGUiLCJ0aWxlQ29udGFpbmVycyIsImNhbGwiLCJjbGlja1RpbGUiLCJtZXRob2QiLCJkZWxldGVUaWxlV2l0aFN0YXJ0aW5nVGlsZSIsInNlbGVjdGVkVGlsZXMiLCJzaXplIiwiZ29hbFRpbGUiLCJ2YWx1ZXMiLCJuZXh0IiwiY2xvbmVUaWxlIiwiZGVzZWxlY3RUaWxlIiwic3RhcnRUaWxlIiwiYXJyb3dNb3ZlbWVudEhhbmRsZXIiLCJzZWxlY3RlZEdyaWQiLCJrZXkiLCJLRVlfTUFQUElORyIsIm1vdmUiLCJhbmltYXRlTW92ZSIsImlzRnVsbCIsImlzU29sdmFibGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtDQUdBO0FBRUE7QUFFQTs7QUFDQSxDQUFDLFlBQU07QUFBQSxNQUNHQSxJQURIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsMkJBRWFDLENBRmIsRUFFZ0I7QUFDWEEsU0FBQyxHQUFHQSxDQUFDLFlBQVlDLEVBQUUsQ0FBQ0MsU0FBaEIsR0FBNEJGLENBQTVCLEdBQWdDQyxFQUFFLENBQUNFLE1BQUgsQ0FBVUgsQ0FBVixDQUFwQztBQUNBQSxTQUFDLENBQUNJLEtBQUYsQ0FBUSxTQUFSLEVBQW1CLE1BQW5CO0FBQ0g7QUFMRjtBQUFBO0FBQUEsMkJBT2FKLENBUGIsRUFP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QUFVO0FBQ047QUFDQXhMLFVBQUUsQ0FBQ3lDLEtBQUgsQ0FBU0UsY0FBVDtBQUVBMEksb0JBQVksQ0FBQ0ksV0FBYixDQUF5QkQsSUFBekI7QUFDSDtBQUNKLEtBdEJEOztBQXdCQTlFLGFBQVMsQ0FBQ3RHLFNBQVYsQ0FBb0JrQyxFQUFwQixDQUF1QixTQUF2QixFQUFrQzhJLG9CQUFsQztBQUNBdkUsWUFBUSxDQUFDekcsU0FBVCxDQUFtQmtDLEVBQW5CLENBQXNCLFNBQXRCLEVBQWlDOEksb0JBQWpDOztBQUVBLGFBQVM3RCxnQkFBVCxHQUE0QjtBQUN4QixVQUFJYixTQUFTLENBQUMyQixRQUFWLEtBQXVCLElBQXZCLElBQStCeEIsUUFBUSxDQUFDNkUsTUFBVCxFQUFuQyxFQUFzRDtBQUNsRCxZQUFJdkQsSUFBSSxDQUFDd0QsVUFBTCxDQUFnQmpGLFNBQWhCLEVBQTJCRyxRQUEzQixDQUFKLEVBQTBDO0FBQ3RDL0csY0FBSSxDQUFDbUYsSUFBTCxDQUFVeEUsUUFBVjtBQUNBdUgscUJBQVcsQ0FBQ2pGLFFBQVosQ0FBcUIsVUFBckIsRUFBaUMsS0FBakM7QUFDQSxpQkFBTyxJQUFQO0FBQ0g7O0FBQ0RyQyxvQkFBWSxDQUFDZ0QsSUFBYixDQUFrQitCLE9BQU8sQ0FBQ0MsTUFBUixDQUFlQyxVQUFqQztBQUNBN0YsWUFBSSxDQUFDb0YsSUFBTCxDQUFVekUsUUFBVjtBQUNBQSxnQkFBUSxDQUFDZSxJQUFULEdBQWdCb0gsY0FBaEI7QUFDSDs7QUFFRFosaUJBQVcsQ0FBQ2pGLFFBQVosQ0FBcUIsVUFBckIsRUFBaUMsSUFBakM7QUFDQSxhQUFPLEtBQVA7QUFDSCxLQXBXcUQsQ0FzVzFEOztBQUNDO0FBQ0osQ0E3bEJEIiwiZmlsZSI6Ii4vc3JjL3NjcmlwdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE86IGNvbnNpZGVyIGFkZGluZyBjb21wcmVzc2lvbiBwbHVnaW4gdG8gd2VicGFja1xuXG4vLyBUT0RPOiBjb25zaWRlciBjaGFuZ2luZyB0byB2ZXJ0aWNhbCBvcmllbnRhdGlvbiBpZiBzY3JlZW4gdG9vIG5hcnJvdyBvciBpbnB1dCBpbWFnZXMgYXJlIGxhbmRzY2FwZSBvcmllbnRhdGlvblxuXG4vLyBUT0RPOiBkZWNyZWFzZSByZXNvbHV0aW9uIG9mIHBpY3R1cmVzIHRvIG1ha2UgY3JvcHBpbmcgYW5kIG1vdmluZyB0aWxlcyBmYXN0ZXJcbi8vIFRPRE86IGNvbnNpZGVyIGNyb3BwaW5nIGltYWdlcyBhbmQgZ2V0dGluZyByaWQgb2Ygc3ZnLWxpbWl0IGNyb3BwaW5nIGZvciBwZXJmb3JtYW5jZVxuXG4vLyBUT0RPOiBpbXBsZW1lbnQgSURBKiB0byBzb2x2ZSA0eDQgcHV6emxlc1xuLy8gVE9ETzogaW1wbGVtZW50IG5vbi1vcHRpbWFsIHNvbHZlciBmb3IgcHV6emxlcyA0eDQgYW5kIGxhcmdlclxuLy8gVE9ETzogY29uc2lkZXIgbW92aW5nIGFsbCBub2RlX21vZHVsZXMgaW50byBkZXYgZGVwZW5kZW5jaWVzIHNpbmNlIHRoZXkgYXJlIGJ1bmRsZWRcblxuLy8gVE9ETzogY29uc2lkZXIgaW1wbGVtZW50aW5nIFwicGxheVwiIGJ1dHRvbiBkaXNhYmxpbmcgZHJhZy9zZWxlY3QgYW5kIG9ubHkgYWxsb3dpbmcgYXJyb3cga2V5IG1vdmVtZW50IGFuZCBjaGFuZ2UgZHJhZy9jbGljayB0byBhbmltYXRlIG1vdmVzIHRvIG5laWdoYm9yaW5nIHRpbGVzXG5pbXBvcnQgQ3JvcHBlciBmcm9tICdjcm9wcGVyanMnXG5pbXBvcnQgUHV6emxlIGZyb20gJy4vc2xpZGluZy1wdXp6bGUtYWxnb3JpdGhtcydcbmltcG9ydCAnLi4vbm9kZV9tb2R1bGVzL2Nyb3BwZXJqcy9kaXN0L2Nyb3BwZXIubWluLmNzcydcblxuLy8gVE9ETzogdWdsaWZ5K21pbmlmeSByZS1lbmFibGUgYWZ0ZXIgZmluaXNoXG5cbi8vIFRPRE86IHJlb3JnYW5pemU6IHZhbGlkYXRpb24gZnVuY3Rpb25zIHNlcGFyYXRlIGpzIGZpbGVcblxuLy8gVE9ETzogY29uc2lkZXIgbW92aW5nIGVhY2ggcGFnZSB0byBzZXBhcmF0ZSBqcyBmaWxlLCB3aXRoIHBhZ2UgbWFuYWdlciBzd2l0Y2hpbmcgYmV0d2VlbiB0aGVtXG4oKCkgPT4ge1xuICAgIGNsYXNzIFV0aWwge1xuICAgICAgICBzdGF0aWMgaGlkZShlKSB7XG4gICAgICAgICAgICBlID0gZSBpbnN0YW5jZW9mIGQzLnNlbGVjdGlvbiA/IGUgOiBkMy5zZWxlY3QoZSk7XG4gICAgICAgICAgICBlLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBzaG93KGUpIHtcbiAgICAgICAgICAgIGUgPSBlIGluc3RhbmNlb2YgZDMuc2VsZWN0aW9uID8gZSA6IGQzLnNlbGVjdChlKTtcbiAgICAgICAgICAgIGUuc3R5bGUoJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgdG9nZ2xlKGUpIHtcbiAgICAgICAgICAgIGUgPSBlIGluc3RhbmNlb2YgZDMuc2VsZWN0aW9uID8gZSA6IGQzLnNlbGVjdChlKTtcbiAgICAgICAgICAgIGUuc3R5bGUoJ2Rpc3BsYXknLCBlLnN0eWxlKCdkaXNwbGF5JykgPT09ICdub25lJyA/ICcnIDogJ25vbmUnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkMy5zZWxlY3QoJy5jb250YWluZXItZmx1aWQnKTtcblxuICAgIGNvbnN0IG1lc3NhZ2VzID0gY29udGFpbmVyLnNlbGVjdCgnI21lc3NhZ2VzJyksXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25EaXYgPSBtZXNzYWdlcy5zZWxlY3QoJyNpbnN0cnVjdGlvbnMnKSxcbiAgICAgICAgICB3YXJuaW5nRGl2ID0gbWVzc2FnZXMuc2VsZWN0KCcjd2FybmluZycpLFxuICAgICAgICAgIHdhcm5pbmdNZXNzYWdlID0gbWVzc2FnZXMuc2VsZWN0KCcjd2FybmluZy1tZXNzYWdlJyksXG4gICAgICAgICAgZXJyb3JEaXYgPSBtZXNzYWdlcy5zZWxlY3QoJyNlcnJvcicpLFxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IG1lc3NhZ2VzLnNlbGVjdCgnI2Vycm9yLW1lc3NhZ2UnKTtcblxuICAgIGNvbnN0IGltYWdlVXBsb2FkUGFnZSA9IGQzLnNlbGVjdCgnI2ltYWdlLXVwbG9hZC1wYWdlJyksXG4gICAgICAgICAgaW1hZ2VDb250YWluZXIgPSBkMy5zZWxlY3QoJyNpbWFnZS11cGxvYWQtY29udGFpbmVyJyksXG4gICAgICAgICAgaW1hZ2VSb3cgPSBkMy5zZWxlY3QoJyNpbWFnZS1yb3cnKSxcbiAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBkMy5zZWxlY3QoJyNpbnN0cnVjdGlvbnMnKTtcblxuICAgIGNvbnN0IHB1enpsZVBhZ2UgPSBkMy5zZWxlY3QoJyNwdXp6bGUtcGFnZScpLFxuICAgICAgICAgIHB1enpsZUNvbnRhaW5lciA9IGQzLnNlbGVjdCgnI3B1enpsZS1jb250YWluZXInKTtcblxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIElNQUdFIFVQTE9BRCBQQUdFXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29uc3QgaW1hZ2VGb3JtID0gZDMuc2VsZWN0KCcjaW1hZ2UtZm9ybScpO1xuICAgIGNvbnN0IGltZ1VybElucHV0ID0gZDMuc2VsZWN0KCcjaW1hZ2UtdXJsJyksXG4gICAgICAgICAgaW1nRmlsZUlucHV0ID0gZDMuc2VsZWN0KCcjdXBsb2FkLWltZy1pbnB1dCcpLFxuICAgICAgICAgIGltZ0ZlZWRiYWNrID0gZDMuc2VsZWN0KCcjaW1hZ2UtdXJsIH4gLmludmFsaWQtZmVlZGJhY2snKTtcblxuICAgIGNvbnN0IGltZyA9IGQzLnNlbGVjdCgnI3VwbG9hZGVkLWltYWdlJyk7XG5cbiAgICBjb25zdCBjcm9wcGVyID0gbmV3IENyb3BwZXIoaW1nLm5vZGUoKSwge1xuICAgICAgICB2aWV3TW9kZTogMixcbiAgICAgICAgZ3VpZGVzOiBmYWxzZSxcbiAgICAgICAgY2VudGVyOiBmYWxzZSxcbiAgICAgICAgYXV0b0Nyb3BBcmVhOiAxLFxuICAgICAgICBkcmFnTW9kZTogJ21vdmUnXG4gICAgfSk7XG5cbiAgICBjb25zdCBwdXp6bGVDb25maWdGb3JtID0gZDMuc2VsZWN0KCcjcHV6emxlLWNvbmZpZy1mb3JtJyk7XG5cbiAgICBsZXQgcm93U3VibWl0ID0gdHJ1ZSxcbiAgICAgICAgY29sU3VibWl0ID0gdHJ1ZTtcblxuICAgIGNvbnN0IHJvd0lucHV0ID0gZDMuc2VsZWN0KCcjbnVtLXJvd3MnKSxcbiAgICAgICAgICByb3dGZWVkYmFjayA9IGQzLnNlbGVjdCgnI251bS1yb3dzIH4gLmludmFsaWQtZmVlZGJhY2snKTtcblxuICAgIGNvbnN0IGNvbElucHV0ID0gZDMuc2VsZWN0KCcjbnVtLWNvbHMnKSxcbiAgICAgICAgICBjb2xGZWVkYmFjayA9IGQzLnNlbGVjdCgnI251bS1jb2xzIH4gLmludmFsaWQtZmVlZGJhY2snKTtcblxuICAgIGNvbnN0IGNyb3BCdXR0b24gPSBkMy5zZWxlY3QoJyNjcm9wLWltYWdlLWJ1dHRvbicpO1xuXG4gICAgcm93SW5wdXQub24oJ2lucHV0JywgdmFsaWRhdGVSb3dzKTtcbiAgICBjb2xJbnB1dC5vbignaW5wdXQnLCB2YWxpZGF0ZUNvbHVtbnMpO1xuXG4gICAgaW1hZ2VGb3JtLm9uKCdzdWJtaXQnLCAoKSA9PiB7XG4gICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVSb3dzKCkge1xuICAgICAgICAvLyB3b3VsZCBiZSBiZXR0ZXIgaWYgZXhlY3V0aW9uIHNob3J0LWNpcmN1aXRlZCBidXQgT0sgZ2l2ZW4gbG93IGNvbXBsZXhpdHkgb2YgdmFsaWRhdGlvblxuICAgICAgICAvLyBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbjogZnVuY3Rpb24gYXMgY2xhc3MgaW5zdGVhZCwgd2l0aCBwYXJhbXMgaW4gY29uc3RydWN0b3JcbiAgICAgICAgLy8gYW5kIGV4ZWN1dGUoKSBmdW5jdGlvbiB0byBhY3R1YWxseSB2YWxpZGF0ZSwgY2FsbGVkIGluIHByb2Nlc3NSZXNwb25zZXMoKVxuICAgICAgICByb3dTdWJtaXQgPSBwcm9jZXNzUmVzcG9uc2VzKFtudW1iZXJWYWxpZGF0aW9uKHJvd0lucHV0LCByb3dGZWVkYmFjayksIHR3b0lucHV0VmFsaWRhdGlvbigpXSxcbiAgICAgICAgICAgIHJvd0lucHV0LCByb3dGZWVkYmFjayk7XG5cbiAgICAgICAgY3JvcEJ1dHRvbi5wcm9wZXJ0eSgnZGlzYWJsZWQnLCAhcm93U3VibWl0IHx8ICFjb2xTdWJtaXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ29sdW1ucygpIHtcbiAgICAgICAgY29sU3VibWl0ID0gcHJvY2Vzc1Jlc3BvbnNlcyhbbnVtYmVyVmFsaWRhdGlvbihjb2xJbnB1dCwgY29sRmVlZGJhY2spXSwgY29sSW5wdXQsIGNvbEZlZWRiYWNrKTtcblxuICAgICAgICAvLyBjYWxsZWQgc2VwYXJhdGVseSBhcyBjaGFuZ2UgaW4gc3RhdHVzIG9mIHR3b0lucHV0VmFsaWRhdGlvbiBtZWFucyBudW1iZXJWYWxpZGF0aW9uXG4gICAgICAgIC8vIG5lZWRzIHRvIGJlIGNoZWNrZWQgdG8gc2VlIHdoYXQgaXMgZGlzcGxheWVkIG9uIHJvdyBmZWVkYmFja1xuICAgICAgICB2YWxpZGF0ZVJvd3MoKTtcbiAgICB9XG5cbiAgICAvLyBzaG93cyBmZWVkYmFjayBmb3IgaW5wdXQgYmFzZWQgb24gcmVzcG9uc2VzIFt7c3RhdHVzOiAndmFsaWQnLydpbnZhbGlkJy8nd2FybmluZycsIG1lc3NhZ2U6ICcuLi4nfSwgLi4uXVxuICAgIC8vIHJldHVybnMgd2hldGhlciBpbnB1dCB2YWxpZGF0aW9uIGFsbG93cyBzdWJtaXNzaW9uXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jlc3BvbnNlcyhyZXNwb25zZXMsIGlucHV0LCBmZWVkYmFjaykge1xuICAgICAgICBsZXQgd2FybmluZztcbiAgICAgICAgZm9yIChsZXQge3N0YXR1cywgbWVzc2FnZX0gb2YgcmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnaW52YWxpZCcpIHtcbiAgICAgICAgICAgICAgICBzaG93RXJyb3IoaW5wdXQsIGZlZWRiYWNrLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gJ3dhcm5pbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgaW5zdGVhZCBvZiBzaG93aW5nIGltbWVkaWF0ZWx5IHRvIGFsbG93IGRldGVjdGlvbiBvZiBlcnJvcnMgaW4gbmV4dCByZXNwb25zZXNcbiAgICAgICAgICAgICAgICB3YXJuaW5nID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2FybmluZykge1xuICAgICAgICAgICAgc2hvd1dhcm5pbmcoaW5wdXQsIGZlZWRiYWNrLCB3YXJuaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGhpZGVNZXNzYWdlcyhpbnB1dCwgZmVlZGJhY2spO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93RXJyb3IoaW5wdXQsIGZlZWRiYWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGlucHV0LmNsYXNzZWQoJ2hhcy13YXJuaW5nJywgZmFsc2UpO1xuICAgICAgICBpbnB1dC5jbGFzc2VkKCdpcy1pbnZhbGlkJywgdHJ1ZSk7XG5cbiAgICAgICAgZmVlZGJhY2suY2xhc3NlZCgnd2FybmluZy1mZWVkYmFjaycsIGZhbHNlKTtcbiAgICAgICAgZmVlZGJhY2suY2xhc3NlZCgnaW52YWxpZC1mZWVkYmFjaycsIHRydWUpO1xuICAgICAgICBmZWVkYmFjay50ZXh0KG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dXYXJuaW5nKGlucHV0LCBmZWVkYmFjaywgbWVzc2FnZSkge1xuICAgICAgICBpbnB1dC5jbGFzc2VkKCdoYXMtd2FybmluZycsIHRydWUpO1xuICAgICAgICBpbnB1dC5jbGFzc2VkKCdpcy1pbnZhbGlkJywgZmFsc2UpO1xuXG4gICAgICAgIGZlZWRiYWNrLmNsYXNzZWQoJ3dhcm5pbmctZmVlZGJhY2snLCB0cnVlKTtcbiAgICAgICAgZmVlZGJhY2suY2xhc3NlZCgnaW52YWxpZC1mZWVkYmFjaycsIGZhbHNlKTtcbiAgICAgICAgZmVlZGJhY2sudGV4dChtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoaWRlTWVzc2FnZXMoaW5wdXQsIGZlZWRiYWNrKSB7XG4gICAgICAgIGlucHV0LmNsYXNzZWQoJ2lzLWludmFsaWQnLCBmYWxzZSk7XG4gICAgICAgIGlucHV0LmNsYXNzZWQoJ2hhcy13YXJuaW5nJywgZmFsc2UpO1xuXG4gICAgICAgIGZlZWRiYWNrLmNsYXNzZWQoJ2ludmFsaWQtZmVlZGJhY2snLCBmYWxzZSk7XG4gICAgICAgIGZlZWRiYWNrLmNsYXNzZWQoJ3dhcm5pbmctZmVlZGJhY2snLCBmYWxzZSk7XG4gICAgICAgIGZlZWRiYWNrLnRleHQoJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHR3b0lucHV0VmFsaWRhdGlvbigpIHtcbiAgICAgICAgbGV0IG51bVJvd3MgPSArcm93SW5wdXQucHJvcGVydHkoJ3ZhbHVlJyk7XG4gICAgICAgIGxldCBudW1Db2xzID0gK2NvbElucHV0LnByb3BlcnR5KCd2YWx1ZScpO1xuXG4gICAgICAgIGlmIChudW1Sb3dzID09PSBudW1Db2xzICYmIG51bVJvd3MgPT09IDEpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXM6ICdpbnZhbGlkJywgbWVzc2FnZTogJ0Nhbm5vdCBjcmVhdGUgMXgxIHB1enpsZXMnfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBudW1UaWxlcyA9IG51bUNvbHMgKiBudW1Sb3dzO1xuICAgICAgICBpZiAobnVtVGlsZXMgPiA0MDApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXM6ICdpbnZhbGlkJywgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBwdXp6bGUgd2l0aCBtb3JlIHRoYW4gNDAwIHRpbGVzIChtYXkgY3Jhc2ggeW91ciBicm93c2VyKSd9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bVRpbGVzID4gMTIpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXM6ICd3YXJuaW5nJywgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAnQ2F1dGlvbjogdGhpcyBzaXRlIG1heSBub3QgYmUgYWJsZSB0byBvcHRpbWFsbHkgc29sdmUgcHV6emxlcyB3aXRoIG1vcmUgdGhhbiAxMiB0aWxlcyd9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChudW1Sb3dzID4gMSAmJiBudW1Db2xzID4gNSkgfHwgKG51bUNvbHMgPiAxICYmIG51bVJvd3MgPiA1KSkge1xuXG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1czogJ3dhcm5pbmcnLCBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICdDYXV0aW9uOiB0aGlzIHNpdGUgbWF5IG5vdCBiZSBhYmxlIHRvIG9wdGltYWxseSBzb2x2ZSAyRCBwdXp6bGVzIHdpdGggYSBkaW1lbnNpb25cXFxuICAgICAgICAgICAgICAgID4gNSd9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge3N0YXR1czogJ3ZhbGlkJ307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbnVtYmVyVmFsaWRhdGlvbihpbnB1dCwgZmVlZGJhY2spIHtcbiAgICAgICAgbGV0IHZhbCA9ICtpbnB1dC5wcm9wZXJ0eSgndmFsdWUnKTtcblxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsKSB8fCB2YWwgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1czogJ2ludmFsaWQnLCBtZXNzYWdlOiAnTnVtYmVyIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcid9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7c3RhdHVzOiAndmFsaWQnfTtcbiAgICB9XG5cblxuICAgIGltZ1VybElucHV0Lm9uKCdpbnB1dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy52YWx1ZTtcblxuICAgICAgICBpZiAodXJsID09PSAnJykge1xuICAgICAgICAgICAgaGlkZU1lc3NhZ2VzKGltZ1VybElucHV0LCBpbWdGZWVkYmFjayk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICBzaG93RXJyb3IoaW1nVXJsSW5wdXQsIGltZ0ZlZWRiYWNrLCAnSW1hZ2UgY291bGQgbm90IGJlIGxvYWRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNyb3BwZXIucmVwbGFjZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGhpZGVNZXNzYWdlcyhpbWdVcmxJbnB1dCwgaW1nRmVlZGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9KTtcblxuICAgIGltZ0ZpbGVJbnB1dC5vbignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpbWdVcmxJbnB1dC5wcm9wZXJ0eSgndmFsdWUnLCAnJyk7XG5cbiAgICAgICAgY29uc3QgaW1nVXBsb2FkID0gaW1nRmlsZUlucHV0LnByb3BlcnR5KCdmaWxlcycpWzBdO1xuICAgICAgICBpZiAoaW1nVXBsb2FkLnR5cGUuaW5jbHVkZXMoJ2ltYWdlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBlID0+IHtcbiAgICAgICAgICAgICAgICBjcm9wcGVyLnJlcGxhY2UoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChpbWdVcGxvYWQpO1xuXG4gICAgICAgICAgICBoaWRlTWVzc2FnZXMoaW1nVXJsSW5wdXQsIGltZ0ZlZWRiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNob3dFcnJvcihpbWdVcmxJbnB1dCwgaW1nRmVlZGJhY2ssICdVcGxvYWRlZCBmaWxlIG11c3QgYmUgYW4gaW1hZ2UnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcHV6emxlQ29uZmlnRm9ybS5vbignc3VibWl0JywgKCkgPT4ge1xuICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAocm93U3VibWl0ICYmIGNvbFN1Ym1pdCkge1xuICAgICAgICAgICAgaW1hZ2VDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICBsZXQgbnVtUm93cyA9ICtyb3dJbnB1dC5wcm9wZXJ0eSgndmFsdWUnKTtcbiAgICAgICAgICAgIGxldCBudW1Db2xzID0gK2NvbElucHV0LnByb3BlcnR5KCd2YWx1ZScpO1xuXG4gICAgICAgICAgICBVdGlsLmhpZGUoaW1hZ2VVcGxvYWRQYWdlKTtcbiAgICAgICAgICAgIFV0aWwuc2hvdyhwdXp6bGVQYWdlKTtcblxuICAgICAgICAgICAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNyb3BwZXIuZ2V0Q3JvcEJveERhdGEoKTtcbiAgICAgICAgICAgIHNwbGl0SW1hZ2UoY3JvcHBlci5nZXRDcm9wcGVkQ2FudmFzKCkudG9EYXRhVVJMKCksIHdpZHRoLCBoZWlnaHQsIG51bVJvd3MsIG51bUNvbHMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFVaWkxFIFBBR0VcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmdW5jdGlvbiBzcGxpdEltYWdlKHNyYywgd2lkdGgsIGhlaWdodCwgbnVtUm93cywgbnVtQ29scykge1xuXG4gICAgICAgIC8vIFRPRE86IHN0b3AgcmVseWluZyBvbiBpdGVyYXRpb24gbGltaXQgYW5kIHVzZSBtZW1vcnkvdGltZSBsaW1pdCBpbnN0ZWFkXG4gICAgICAgIC8vIChzaW5jZSBsYXJnZXIgcHV6emxlcyBtYWtlIGl0ZXJhdGlvbnMgdGFrZSBsb25nZXIpXG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSB7XG4gICAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgICAgICB1bnNvbHZhYmxlOiAnUHV6emxlIGlzIHVuc29sdmFibGUuIFRyeSBzd2FwcGluZyB0aWxlcyBpbiB5b3VyIGdvYWwgYW5kL29yIHN0YXJ0IHN0YXRlO1xcXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW1wbHkgc2xpZGluZyB0aWxlcyBhcm91bmQgd2lsbCBub3QgYWZmZWN0IHB1enpsZSBzb2x2YWJpbGl0eS4nLFxuICAgICAgICAgICAgICAgIGl0ZXJhdGlvbkxpbWl0OiAnUHV6emxlIHRvb2sgdG9vIGxvbmcgdG8gc29sdmU7IGZ1cnRoZXIgc29sdmUtdGltZSBjb3VsZCBjcmFzaCB5b3VyIGJyb3dzZXIuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB7XG4gICAgICAgICAgICAgICAgc29sdmFiaWxpdHk6ICdCZSBjYXJlZnVsIHdoZW4gc3dhcHBpbmcgYW5kIGRlbGV0aW5nIHRpbGVzOyBub3QgYWxsIHB1enpsZS1zdGF0ZXMgYXJlIHNvbHZhYmxlLidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWwuc2hvdyh3YXJuaW5nRGl2KTtcbiAgICAgICAgd2FybmluZ01lc3NhZ2UudGV4dChzdHJpbmdzLndhcm5pbmdzLnNvbHZhYmlsaXR5KTtcblxuICAgICAgICBjb25zdCBtYXhHcmlkSGVpZ2h0ID0gMTEwO1xuICAgICAgICBjb25zdCBtYXhHcmlkV2lkdGggPSAxMTA7XG5cbiAgICAgICAgbGV0IGdyaWRXaWR0aCwgZ3JpZEhlaWdodDtcblxuICAgICAgICAvLyBwcmVzZXJ2ZXMgYXNwZWN0IHJhdGlvIG9mIGNyb3BwZWQgaW1hZ2UsIHdpdGggbGFyZ2VzdCBkaW0gc2V0IHRvIG1heCBkaW0gYWJvdmVcbiAgICAgICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICBncmlkV2lkdGggPSBtYXhHcmlkV2lkdGg7XG4gICAgICAgICAgICBncmlkSGVpZ2h0ID0gbWF4R3JpZEhlaWdodCAqIGhlaWdodC93aWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWRIZWlnaHQgPSBtYXhHcmlkSGVpZ2h0O1xuICAgICAgICAgICAgZ3JpZFdpZHRoID0gbWF4R3JpZFdpZHRoICogd2lkdGgvaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgdmlld0JveCA9IHt4OiAwLCB5OiAwLCB3aWR0aDogMzAwLCBoZWlnaHQ6IGdyaWRIZWlnaHQgKyAzMH07XG5cbiAgICAgICAgLy8gTk9URTogaGVpZ2h0IG5vdCBzZXQgaW4gc3ZnIGFzIG92ZXJ3cml0dGVuIGJ5IHZpZXdCb3ggaGVpZ2h0IHNjYWxpbmcgdG8gd2lkdGhcbiAgICAgICAgY29uc3Qgc3ZnID0gcHV6emxlQ29udGFpbmVyLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICcxMDAlJylcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgYCR7dmlld0JveC54fSAke3ZpZXdCb3gueX0gJHt2aWV3Qm94LndpZHRofSAke3ZpZXdCb3guaGVpZ2h0fWApO1xuXG4gICAgICAgIHN2Zy5hcHBlbmQoJ2RlZnMnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2ZpbHRlcicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3NoYWRvdycpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2ZlRHJvcFNoYWRvdycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdGREZXZpYXRpb24nLCAzKTtcblxuICAgICAgICBjb25zdCBncmlkUGFkZGluZyA9ICgzMDAgLSBncmlkV2lkdGggKiAyKSAvIDM7XG5cbiAgICAgICAgLy8gTk9URTogMC41IHBvc2l0aW9uaW5nIGhlbHBzIG1ha2Ugb3V0bGluZXMgY3Jpc3BlciAoYXMgY29vcmRzIG1hcCB0byBwaXhlbCBzcXVhcmUgaW50ZXJzZWN0aW9ucylcbiAgICAgICAgLy8gLSBhbHNvIGhlbHBzIHByZXZlbnQgbm90aWNlYWJsZSBvdXRsaW5lIGRhcmtlbmluZyBpbiBvdXRsaW5lIGNvb3JkIG92ZXJsYXAgZm9yIHNhbWUgcmVhc29uXG4gICAgICAgIC8vIC0gZGlmZmVyZW5jZSBjYW4gYmUgc2VlbiBtb3JlIGVhc2lseSB3aGVuIHN0cm9rZVdpZHRoIGluY3JlYXNlZFxuICAgICAgICBjb25zdCBzdGFydEdyaWQgPSBuZXcgU3RhcnRHcmlkKHN2ZywgZ3JpZFBhZGRpbmcsIDIwLjUsIG51bVJvd3MsIG51bUNvbHMsIHNyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBncmlkSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGdyaWRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5kcmF3KCk7XG5cbiAgICAgICAgY29uc3QgZ29hbEdyaWQgPSBuZXcgR29hbEdyaWQoc3ZnLCB2aWV3Qm94LndpZHRoIC0gZ3JpZFBhZGRpbmcgLSBncmlkV2lkdGgsIDIwLjUsIG51bVJvd3MsIG51bUNvbHMsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGdyaWRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZ3JpZFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmRyYXcoKTtcblxuICAgICAgICBjb25zdCB0aWxlTnVtYmVyU2l6ZSA9IE1hdGgubWluKGdyaWRIZWlnaHQgLyBudW1Sb3dzIC8gMiwgZ3JpZFdpZHRoIC8gbnVtQ29scyAvIDIpO1xuXG4gICAgICAgIHN0YXJ0R3JpZC50aWxlTnVtYmVycy5zdHlsZSgnZm9udC1zaXplJywgYCR7dGlsZU51bWJlclNpemV9cHhgKTtcbiAgICAgICAgZ29hbEdyaWQudGlsZU51bWJlcnMuc3R5bGUoJ2ZvbnQtc2l6ZScsIGAke3RpbGVOdW1iZXJTaXplfXB4YCk7XG5cbiAgICAgICAgLy8gTk9URTogbm90IGluc2lkZSBHcmlkIGFzIG5vdCBzdXJlIGlmIHdhbnQgdG8gZGlzcGxheSBsYWJlbFxuICAgICAgICAvLyBBZGRpbmcgbGFiZWwgd291bGQgbWFrZSB0aWxlIGNvb3JkcyBhIGxpdHRsZSBtb3JlIGNvbmZ1c2luZ1xuICAgICAgICBjb25zdCBzdGFydExhYmVsID0gc3RhcnRHcmlkLmNvbnRhaW5lci5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBzdGFydEdyaWQueCArIHN0YXJ0R3JpZC53aWR0aCAvIDIpXG4gICAgICAgICAgICAuYXR0cigneScsIHN0YXJ0R3JpZC55IC0gNSlcbiAgICAgICAgICAgIC50ZXh0KCdTdGFydCcpXG4gICAgICAgICAgICAuY2xhc3NlZCgnZ3JpZC10aXRsZScsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IGdvYWxMYWJlbCA9IGdvYWxHcmlkLmNvbnRhaW5lci5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBnb2FsR3JpZC54ICsgZ29hbEdyaWQud2lkdGggLyAyKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCBnb2FsR3JpZC55IC0gNSlcbiAgICAgICAgICAgIC50ZXh0KCdHb2FsJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdncmlkLXRpdGxlJywgdHJ1ZSk7XG5cbiAgICAgICAgY29uc3QgYnV0dG9uUmlnaHQgPSBzdmcuYXBwZW5kKCdpbWFnZScpXG4gICAgICAgICAgICAuYXR0cigneCcsIHN0YXJ0R3JpZC54ICsgZ3JpZFdpZHRoICsgZ3JpZFBhZGRpbmcgLyAyIC0gOClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgJzUwJScpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxNilcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxNilcbiAgICAgICAgICAgIC5hdHRyKCdocmVmJywgJ2ljb25zL3JpZ2h0LWNoZXZyb24uc3ZnJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdwdXp6bGUtYXJyb3cnLCB0cnVlKVxuICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGFydEdyaWQuY2xvbmVUaWxlc1RvKGdvYWxHcmlkKTtcbiAgICAgICAgICAgICAgICBVdGlsLmhpZGUoZXJyb3JEaXYpO1xuICAgICAgICAgICAgICAgIGNoZWNrU29sdmFiaWxpdHkoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGJ1dHRvblRvb2xiYXIgPSBwdXp6bGVQYWdlLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2J0bi10b29sYmFyIG1iLTIganVzdGlmeS1jb250ZW50LWNlbnRlcicpO1xuXG4gICAgICAgIGNvbnN0IHB1enpsZUJ1dHRvbnMgPSBidXR0b25Ub29sYmFyLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2J0bi1ncm91cCBtci0yIG15LTEnKTtcblxuICAgICAgICBjb25zdCBvdmVybGF5QnV0dG9ucyA9IGJ1dHRvblRvb2xiYXIuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnRuLWdyb3VwIG15LTEnKTtcblxuICAgICAgICBjb25zdCBzb2x1dGlvblBhbmVsID0gcHV6emxlUGFnZS5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnY2FyZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICAgIGNvbnN0IHNvbHV0aW9uUGFuZWxIZWFkaW5nID0gc29sdXRpb25QYW5lbC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2NhcmQtaGVhZGVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGV4dCgnU29sdXRpb24nKTtcblxuICAgICAgICBjb25zdCBzb2x1dGlvblBhbmVsQm9keSA9IHNvbHV0aW9uUGFuZWwuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2NhcmQtYm9keScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ21heC1oZWlnaHQnLCAnMTAwcHgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvdmVyZmxvdy15JywgJ3Njcm9sbCcpO1xuXG4gICAgICAgIC8vIE5PVEU6IGFzc3VtZXMgc3RhcnRpbmcgc3RhdGUgaXMgc29sdmFibGVcbiAgICAgICAgY29uc3Qgc2h1ZmZsZUJ1dHRvbiA9IHB1enpsZUJ1dHRvbnMuYXBwZW5kKCdidXR0b24nKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2J0biBidG4tc2Vjb25kYXJ5JylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdzaHVmZmxlLWJ1dHRvbicpXG4gICAgICAgICAgICAucHJvcGVydHkoJ2Rpc2FibGVkJywgdHJ1ZSlcbiAgICAgICAgICAgIC50ZXh0KCdTaHVmZmxlJylcbiAgICAgICAgICAgIC8vIGRvbid0IHdhbnQgdG8gcGFzcyBpbiBcInRoaXNcIiBmcm9tIGNsaWNrXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0R3JpZC5zaHVmZmxlKCk7XG4gICAgICAgICAgICAgICAgVXRpbC5oaWRlKGVycm9yRGl2KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGhhdmluZyBhbmltYXRpb25zIHJldHVybiBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgZXZlcnl0aGluZyBhbmltYXRlZFxuICAgICAgICAvLyB0aGF0IHdheSwgY2FuIGRpc2FibGUgYW5kIGVuYWJsZSBzb2x2ZS9zaHVmZmxlIGFmdGVyIHByb21pc2UgcmVzb2x2ZXNcbiAgICAgICAgLy8gYWxzbyBhZGQgbG9hZGluZyBpbmRpY2F0aW9uIChhdCBtaW5pbXVtLCBzaG93IGxvYWRpbmcgY3Vyc29yKVxuICAgICAgICBjb25zdCBzb2x2ZUJ1dHRvbiA9IHB1enpsZUJ1dHRvbnMuYXBwZW5kKCdidXR0b24nKVxuICAgICAgICAgICAgLnByb3BlcnR5KCdkaXNhYmxlZCcsIHRydWUpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnRuIGJ0bi1zZWNvbmRhcnknKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3NvbHZlLWJ1dHRvbicpXG4gICAgICAgICAgICAudGV4dCgnU29sdmUnKVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IHB1enpsZSA9IG5ldyBQdXp6bGUobnVtUm93cywgbnVtQ29scywgR3JpZC5nZXRBcnJheVJlcHJlc2VudGF0aW9uKHN0YXJ0R3JpZCwgZ29hbEdyaWQpLFxuICAgICAgICAgICAgICAgIHN0YXJ0R3JpZC5lbXB0eVBvcyk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGFucyA9IHB1enpsZS5zb2x2ZSgpO1xuXG4gICAgICAgICAgICAgICAgVXRpbC5zaG93KHNvbHV0aW9uUGFuZWwpO1xuICAgICAgICAgICAgICAgIHN0YXJ0R3JpZC5hbmltYXRlTW92ZXMoYW5zLCBzb2x1dGlvblBhbmVsQm9keSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ01heCBudW1iZXIgb2YgaXRlcmF0aW9ucyBleGNlZWRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5zaG93KGVycm9yRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlLnRleHQoc3RyaW5ncy5lcnJvcnMuaXRlcmF0aW9uTGltaXQpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvckRpdi5ub2RlKCkuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc2V0UHV6emxlQnV0dG9uID0gcHV6emxlQnV0dG9ucy5hcHBlbmQoJ2J1dHRvbicpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnRuIGJ0bi1zZWNvbmRhcnknKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3Jlc2V0LXB1enpsZS1idXR0b24nKVxuICAgICAgICAgICAgLnRleHQoJ1Jlc2V0JylcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhcnRHcmlkLnJlc2V0VGlsZXMoKTtcbiAgICAgICAgICAgICAgICBnb2FsR3JpZC5yZXNldFRpbGVzKCk7XG4gICAgICAgICAgICAgICAgVXRpbC5oaWRlKHNvbHV0aW9uUGFuZWwpO1xuICAgICAgICAgICAgICAgIHNvbHZlQnV0dG9uLnByb3BlcnR5KCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGVzIG1vZGUgdG8gdGlsZSBkZWxldGlvbiBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZU1vdXNlTW9kZUJ1dHRvbi50ZXh0KCkgPT09ICdUaWxlIERlbGV0aW9uIE1vZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZU1vdXNlTW9kZUJ1dHRvbi5ub2RlKCkuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9nZ2xlTW91c2VNb2RlQnV0dG9uLnByb3BlcnR5KCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNodWZmbGVCdXR0b24ucHJvcGVydHkoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgVXRpbC5oaWRlKGVycm9yRGl2KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG51bWJlck92ZXJsYXlCdXR0b24gPSBvdmVybGF5QnV0dG9ucy5hcHBlbmQoJ2J1dHRvbicpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnRuIGJ0bi1zZWNvbmRhcnknKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ251bWJlci1vdmVybGF5LWJ1dHRvbicpXG4gICAgICAgICAgICAudGV4dCgnU2hvdyBOdW1iZXIgT3ZlcmxheScpXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0R3JpZC50b2dnbGVOdW1iZXJPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgZ29hbEdyaWQudG9nZ2xlTnVtYmVyT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbnVtYmVyT3ZlcmxheUJ1dHRvbi50ZXh0KCkgPT09ICdTaG93IE51bWJlciBPdmVybGF5JyA/XG4gICAgICAgICAgICAgICAgICAgICdIaWRlIE51bWJlciBPdmVybGF5JyA6ICdTaG93IE51bWJlciBPdmVybGF5JztcbiAgICAgICAgICAgICAgICBudW1iZXJPdmVybGF5QnV0dG9uLnRleHQodGV4dCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0b2dnbGVNb3VzZU1vZGVCdXR0b24gPSBvdmVybGF5QnV0dG9ucy5hcHBlbmQoJ2J1dHRvbicpXG4gICAgICAgICAgICAvLyBjYW5ub3Qgc3RhcnQgbW92aW5nIHRpbGVzIHVudGlsIG9uZSBpcyBkZWxldGVkIChlbXB0eSBwb3NpdGlvbiBjaG9zZW4pXG4gICAgICAgICAgICAucHJvcGVydHkoJ2Rpc2FibGVkJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdidG4gYnRuLXNlY29uZGFyeScpXG4gICAgICAgICAgICAuYXR0cignaWQnLCAndG9nZ2xlLW1vdXNlLW1vZGUtYnV0dG9uJylcbiAgICAgICAgICAgIC50ZXh0KCdUaWxlIFNlbGVjdGlvbiBNb2RlJylcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRHcmlkLnRvZ2dsZVRpbGVPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgZ29hbEdyaWQudG9nZ2xlVGlsZU92ZXJsYXkoKTtcblxuICAgICAgICAgICAgICAgIGxldCBidXR0b24gPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSBidXR0b24udGV4dCgpID09PSAnVGlsZSBEZWxldGlvbiBNb2RlJyA/XG4gICAgICAgICAgICAgICAgICAgICAnVGlsZSBTZWxlY3Rpb24gTW9kZScgOiAnVGlsZSBEZWxldGlvbiBNb2RlJztcblxuICAgICAgICAgICAgICAgIGJ1dHRvbi50ZXh0KHRleHQpO1xuXG4gICAgICAgICAgICAgICAgc3RhcnRHcmlkLmRlc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgZ29hbEdyaWQuZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGxvb2tpbmcgaW50byBkcm9wIGhhbmRsZXIgaW5zdGVhZCBvZiBnZXR0aW5nIHRpbGUgZnJvbSAoeCwgeSkgaW4gR3JpZFxuICAgICAgICBjb25zdCBkcmFnSGFuZGxlciA9IGQzLmRyYWcoKVxuICAgICAgICAgICAgLnN1YmplY3QoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7eDogZC5jZWxsLngsIHk6IGQuY2VsbC55fVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIGRvbid0IGRyYWcgdGlsZSBpZiBpbiBkZWxldGUgbW9kZSBvciB0aWxlIGlzIGVtcHR5XG4gICAgICAgICAgICAuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhZC5ncmlkLmRlbGV0ZU92ZXJsYXkgJiYgIWQuZ3JpZC5oYXNFbXB0eVRpbGUoZC50aWxlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkcmFnZ2luZycpO1xuXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2RyYWdnaW5nJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiByYWlzZSgpIGV4ZWN1dGVzIGluICdkcmFnJyByYXRoZXIgdGhhbiAnc3RhcnQnIGFzIGFwcGVuZENoaWxkIChjYWxsZWQgYnkgcmFpc2UoKSlcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50cyBjYWxsIG9mIGNsaWNrIGhhbmRsZXIgKHVuZGVzaXJhYmxlLCBzaW5jZSAnc3RhcnQnIGlzIGNhbGxlZCBvbiBjbGlja3MpXG5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBub3QgYXMgaW5lZmZpY2llbnQgYXMgaXQgbWF5IHNlZW0sIGFzIGZ1bmN0aW9uIG9ubHkgbW92ZXMgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgbm90IGxhc3QgZWxlbWVudCBpbiBwYXJlbnRcblxuICAgICAgICAgICAgICAgIC8vIG1vdmVzIGNvbnRhaW5lciBvZiB0aWxlIHRvIGZyb250IHNvIHRoYXQgZHJhZ2dlZCB0aWxlIGRyYXduIGFib3ZlIG90aGVyIHB1enpsZVxuICAgICAgICAgICAgICAgIGQuZ3JpZC5jb250YWluZXIucmFpc2UoKTtcblxuICAgICAgICAgICAgICAgIC8vIG1vdmVzIHRpbGUgdG8gZnJvbnQgc28gZHJhd24gaW4gZnJvbnQgb2Ygb3RoZXIgdGlsZXNcbiAgICAgICAgICAgICAgICBkLnRpbGUucmFpc2UoKTtcblxuICAgICAgICAgICAgICAgIGQuZ3JpZC5jb250YWluZXIubm9kZSgpLmZvY3VzKCk7XG5cbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBkMy5ldmVudC54KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGQzLmV2ZW50LnkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIE5PVEU6IGQzIHN0aWxsIGNhbGxzIHN0YXJ0IGFuZCBlbmQgb24gY2xpY2sgKGZpcmVzIGJlZm9yZSBjbGljayBoYW5kbGVyKVxuICAgICAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkcmFnIGVuZCcpO1xuXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2RyYWdnaW5nJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG9yaWdpbmFsIGltYWdlIHRvIHN0YXJ0aW5nIHBvc2l0aW9uIG9uIHJlbGVhc2VcbiAgICAgICAgICAgICAgICBsZXQgdGlsZUNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGQuY2VsbC54KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGQuY2VsbC55KTtcblxuICAgICAgICAgICAgICAgIGxldCBbbW91c2VYLCBtb3VzZVldID0gZDMubW91c2Uoc3ZnLm5vZGUoKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWdvYWxHcmlkLmRyb3BUaWxlKHRpbGVDb250YWluZXIsIG1vdXNlWCwgbW91c2VZKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydEdyaWQuZHJvcFRpbGUodGlsZUNvbnRhaW5lciwgbW91c2VYLCBtb3VzZVkpO1xuICAgICAgICAgICAgICAgICAgICBjaGVja1NvbHZhYmlsaXR5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hlY2tTb2x2YWJpbGl0eSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhcnRHcmlkLnRpbGVDb250YWluZXJzLmNhbGwoZHJhZ0hhbmRsZXIpO1xuICAgICAgICBnb2FsR3JpZC50aWxlQ29udGFpbmVycy5jYWxsKGRyYWdIYW5kbGVyKTtcblxuICAgICAgICBzdGFydEdyaWQudGlsZUNvbnRhaW5lcnMub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXJ0R3JpZC5jbGlja1RpbGUodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQubWV0aG9kID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgIGdvYWxHcmlkLmRlbGV0ZVRpbGVXaXRoU3RhcnRpbmdUaWxlKHJlc3VsdC50aWxlKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVNb3VzZU1vZGVCdXR0b24ucHJvcGVydHkoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNodWZmbGVCdXR0b24ucHJvcGVydHkoJ2Rpc2FibGVkJywgZmFsc2UpO1xuXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lm1ldGhvZCA9PT0gJ3NlbGVjdCcgJiYgZ29hbEdyaWQuc2VsZWN0ZWRUaWxlcy5zaXplID09PSAxKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgZ29hbFRpbGUgPSBnb2FsR3JpZC5zZWxlY3RlZFRpbGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHRpbGVzIGNhbm5vdCBiZSBjbG9uZWQgdG8gZ29hbCBUaWxlXG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydEdyaWQuaGFzRW1wdHlUaWxlKHJlc3VsdC50aWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBHcmlkLmNsb25lVGlsZShyZXN1bHQudGlsZSwgZ29hbFRpbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdvYWxHcmlkLmRlc2VsZWN0VGlsZShnb2FsVGlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0R3JpZC5kZXNlbGVjdFRpbGUocmVzdWx0LnRpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hlY2tTb2x2YWJpbGl0eSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBnb2FsR3JpZC50aWxlQ29udGFpbmVycy5vbignY2xpY2snLCBmdW5jdGlvbihkKSB7XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBnb2FsR3JpZC5jbGlja1RpbGUodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQubWV0aG9kID09PSAnc2VsZWN0JyAmJiBzdGFydEdyaWQuc2VsZWN0ZWRUaWxlcy5zaXplID09PSAxKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRUaWxlID0gc3RhcnRHcmlkLnNlbGVjdGVkVGlsZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgdGlsZXMgY2Fubm90IGJlIGNsb25lZCB0byBnb2FsIFRpbGVcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0R3JpZC5oYXNFbXB0eVRpbGUoc3RhcnRUaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBHcmlkLmNsb25lVGlsZShzdGFydFRpbGUsIHJlc3VsdC50aWxlKTtcblxuICAgICAgICAgICAgICAgICAgICBnb2FsR3JpZC5kZXNlbGVjdFRpbGUocmVzdWx0LnRpbGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydEdyaWQuZGVzZWxlY3RUaWxlKHN0YXJ0VGlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGVja1NvbHZhYmlsaXR5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGFsbG93aW5nIG1vdmVtZW50IG9mIHNlbGVjdGVkIHRpbGUgKG1haW5seSBmb3IgbW92aW5nIHRpbGVzIGluIHBhcnRpYWxseSBhc3NpZ25lZCBnb2FsKVxuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGRlc2VsZWN0aW5nIHRpbGUgaWYgaXQncyBkcmFnZ2VkIG9yIGRyb3BwZWQgb250b1xuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIG92ZXJ3cml0aW5nIHRpbGUgcmF0aGVyIHRoYW4gc3dhcHBpbmcgdGhlbSB3aGVuIGEgdGlsZSB3aXRoIG1hdGNoIGlzIGRyYWdnZWQgdG8gYW4gb2NjdXBpZWQgdGlsZVxuXG4gICAgICAgIGNvbnN0IGFycm93TW92ZW1lbnRIYW5kbGVyID0gZnVuY3Rpb24oc2VsZWN0ZWRHcmlkKSB7XG5cbiAgICAgICAgICAgIGxldCBrZXkgPSBkMy5ldmVudC5rZXk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IEtFWV9NQVBQSU5HID0ge1xuICAgICAgICAgICAgICAgICdBcnJvd0xlZnQnOiAnbCcsXG4gICAgICAgICAgICAgICAgJ0Fycm93UmlnaHQnOiAncicsXG4gICAgICAgICAgICAgICAgJ0Fycm93VXAnOiAndScsXG4gICAgICAgICAgICAgICAgJ0Fycm93RG93bic6ICdkJyxcbiAgICAgICAgICAgICAgICAndycgOiAndScsXG4gICAgICAgICAgICAgICAgJ2EnOiAnbCcsXG4gICAgICAgICAgICAgICAgJ3MnOiAnZCcsXG4gICAgICAgICAgICAgICAgJ2QnOiAncidcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1vdmUgPSBLRVlfTUFQUElOR1trZXldO1xuICAgICAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50cyBhcnJvdyBrZXlzIGZyb20gc2Nyb2xsaW5nIHNjcmVlblxuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RlZEdyaWQuYW5pbWF0ZU1vdmUobW92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydEdyaWQuY29udGFpbmVyLm9uKCdrZXlkb3duJywgYXJyb3dNb3ZlbWVudEhhbmRsZXIpO1xuICAgICAgICBnb2FsR3JpZC5jb250YWluZXIub24oJ2tleWRvd24nLCBhcnJvd01vdmVtZW50SGFuZGxlcik7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tTb2x2YWJpbGl0eSgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydEdyaWQuZW1wdHlQb3MgIT09IG51bGwgJiYgZ29hbEdyaWQuaXNGdWxsKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoR3JpZC5pc1NvbHZhYmxlKHN0YXJ0R3JpZCwgZ29hbEdyaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWwuaGlkZShlcnJvckRpdik7XG4gICAgICAgICAgICAgICAgICAgIHNvbHZlQnV0dG9uLnByb3BlcnR5KCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZS50ZXh0KHN0cmluZ3MuZXJyb3JzLnVuc29sdmFibGUpO1xuICAgICAgICAgICAgICAgIFV0aWwuc2hvdyhlcnJvckRpdik7XG4gICAgICAgICAgICAgICAgZXJyb3JEaXYubm9kZSgpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNvbHZlQnV0dG9uLnByb3BlcnR5KCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgfVxufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/script.js\n");

/***/ }),

/***/ "./src/sliding-puzzle-algorithms.js":
/*!******************************************!*\
  !*** ./src/sliding-puzzle-algorithms.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime-module.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fastpriorityqueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fastpriorityqueue */ \"./node_modules/fastpriorityqueue/FastPriorityQueue.js\");\n/* harmony import */ var fastpriorityqueue__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fastpriorityqueue__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ndarray */ \"./node_modules/ndarray/ndarray.js\");\n/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var avl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avl */ \"./node_modules/avl/src/index.js\");\n/* harmony import */ var _math_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math-util */ \"./src/math-util.js\");\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Operator pre-computation, in-place modification of grid state for ida* based on\n// \"Implementing Fast Heuristic Search Code\"\n// by Ethan Burns and Matthew Hatem and Michael J. Leighton and Wheeler Ruml\n// Linear conflict heuristic based on\n// \"Criticizing Solutions to Relaxed Models Yields Powerful Admissible Heuristics\"\n// by Othar Hansson and Andrew Mayer\n// TODO: write function to time performance of different alg+heuristic combos\n// TODO: fix freeze when trying to solve some 5x4 puzzles (and presumably those larger than that)\n// iteration limit should work, but not working and/or iterations taking substantially more memory + longer\n// TODO: consider storing precomputed values in global object\n// pros: simple, makes all solve()s on same dimension puzzle faster\n// cons: memory leak that can pile up if user switches between many different puzzle dimensions\n// alternative: precompute once per Puzzle, and make sure calling functions remember to reuse\n// Puzzle instance when size is the same;\n// cons: messier, calling functions required to maintain logic for which Puzzle to use,\n// puzzle object needs method for updating it, cache can't be used between Puzzle objects\n// alternative: store cache globally/as Class property, but set object to null within Puzzle constructor\n// when puzzle dimensions change\n// pros: fairly simple, avoids memory leak, faster solving of same size puzzle\n// cons: a little messier, can't manage multiple independent Puzzles at same time with different size\n// ex: 2 puzzles with 2x2, 3x3 dimensions, cache would be reset each time one was solved\n// Addon: precompute values in script.js before \"solve\" button is clicked, to avoid longer\n// solve time on first click. May need to be async to be invisible to user\n\n\n\n\n\nvar REVERSE_MOVE_MAP = {\n  'r': 'l',\n  'l': 'r',\n  'd': 'u',\n  'u': 'd' // TODO: re-investigate whether using typedArrays worth it (probably not, given small arrays and casting)\n  // TODO: combine multiple heuristics max(manhattan, corner, pattern database, linear conflict), or additive disjoint patterns\n  // TODO: if using pattern database, consider encoding pattern numbers into bytes and storing in int\n  // TODO: note that pattern dbs will make it difficult to allow non-square puzzles with dimensions > 4\n  // TODO: consider precomputing LC for each possible state to reduce updates to table lookups\n  // NOTE: methods not static to support using cached MD data specific to puzzle\n  // grid not part of constructor as single heuristic passed between all grids in a given Puzzle\n\n};\n\nvar ManhattanHeuristic =\n/*#__PURE__*/\nfunction () {\n  function ManhattanHeuristic(numRows, numCols) {\n    _classCallCheck(this, ManhattanHeuristic);\n\n    this.numRows = numRows;\n    this.numCols = numCols;\n    this.numTiles = numRows * numCols;\n\n    this._precompute();\n\n    this.moveNumberMap = {\n      'l': 0,\n      'r': 1,\n      'u': 2,\n      'd': 3\n    };\n  } // TODO: change so precompute called once for all puzzles of same size\n  // since no matter what user settings are called, all possible inds and goalInds accounted for\n  // store as class property, and change heuristics back to static\n  // TODO: make _precompute() status (cache existance) affect update() and calculate()\n  // returns false if could not be completed, true otherwise\n\n\n  _createClass(ManhattanHeuristic, [{\n    key: \"_precompute\",\n    value: function _precompute() {\n      // stop precomputing when numTiles > 100 (50,000 array entries in cache)\n      if (this.numTiles > 100) {\n        return false;\n      } // _md.get(i, j) = md value at ind = i, goalInd = j\n\n\n      this._md = ndarray__WEBPACK_IMPORTED_MODULE_2___default()(new Uint16Array(Math.pow(this.numTiles, 2)), [this.numTiles, this.numTiles]); // _mdDelta.get(i, j, k) = change in MD when ind = i, goalInd = j, and move = k\n      // where move = 0 -> 'l', 1 -> 'r', 2 -> 'u' 3 -> 'd'\n\n      this._mdDelta = ndarray__WEBPACK_IMPORTED_MODULE_2___default()(new Int8Array(4 * Math.pow(this.numTiles, 2)), [this.numTiles, this.numTiles, 4]); // l, r, u, d\n\n      var moveDeltaMap = Int16Array.from([-1, 1, -this.numCols, this.numCols]);\n      var ind, goalInd;\n      ind = 0;\n\n      for (var row1 = 0; row1 < this.numRows; row1++) {\n        for (var col1 = 0; col1 < this.numCols; col1++) {\n          goalInd = 0;\n\n          for (var row2 = 0; row2 < this.numRows; row2++) {\n            for (var col2 = 0; col2 < this.numCols; col2++) {\n              this._md.set(ind, goalInd, Math.abs(row2 - row1) + Math.abs(col2 - col1));\n\n              goalInd++;\n            }\n          }\n\n          ind++;\n        }\n      }\n\n      ind = 0;\n\n      for (var _row = 0; _row < this.numRows; _row++) {\n        for (var _col = 0; _col < this.numCols; _col++) {\n          goalInd = 0;\n\n          for (var _row2 = 0; _row2 < this.numRows; _row2++) {\n            for (var _col2 = 0; _col2 < this.numCols; _col2++) {\n              var startMD = this._md.get(ind, goalInd); // l, r, u, d\n\n\n              for (var move = 0; move < 4; move++) {\n                var endMD = this._md.get(ind + moveDeltaMap[move], goalInd);\n\n                this._mdDelta.set(ind, goalInd, move, endMD - startMD);\n              }\n\n              goalInd++;\n            }\n          }\n\n          ind++;\n        }\n      }\n\n      return true;\n    } // returns heuristic distance from goal\n\n  }, {\n    key: \"calculate\",\n    value: function calculate(grid) {\n      var dist = 0;\n\n      for (var i = 0; i < grid.tiles.length; i++) {\n        if (i !== grid.emptyPos) {\n          if (this._md) {\n            dist += this._md.get(i, grid.tiles[i]);\n          } else {\n            dist += grid.getTileDist(i, grid.tiles[i]);\n          }\n        }\n      }\n\n      return dist;\n    } // TODO: consider refactoring to just use \"grid\" to prevent confusion\n    // Returns updated heuristic distance from goal after move\n    // newGrid = Grid after move (distinct object), with all properties updated besides heuristicValue\n    // startInd = ind moved tile started in\n    // endInd = ind moved tile ended up in\n    // move = single-letter move within 'l/r/u/d'\n    // NOTE: assumes newGrid's heuristic value is same as old grid (not yet updated)\n\n  }, {\n    key: \"update\",\n    value: function update(newGrid, startInd, endInd, move) {\n      return this.getUpdateDelta(newGrid, startInd, endInd, move) + newGrid.heuristicValue;\n    } // returns change in heuristic distance from move\n    // newGrid = Grid after move (distinct object), with all properties updated besides heuristicValue\n    // startInd = ind moved tile started in\n    // endInd = ind moved tile ended up in\n    // move = single-letter move within 'l/r/u/d'\n\n  }, {\n    key: \"getUpdateDelta\",\n    value: function getUpdateDelta(newGrid, startInd, endInd, move) {\n      if (this._mdDelta) {\n        // get(movedInd, goalInd, move)\n        // (goalInd is value of tile at endInd, as newGrid's endInd is oldGrid's startInd)\n        return this._mdDelta.get(startInd, newGrid.tiles[endInd], this.moveNumberMap[move]);\n      }\n\n      var goalInd = newGrid.tiles[endInd],\n          goalRow = newGrid.getTileRow(goalInd),\n          goalCol = newGrid.getTileCol(goalInd);\n      var startRow = newGrid.getTileRow(startInd),\n          startCol = newGrid.getTileCol(startInd);\n      var endRow = newGrid.getTileRow(endInd),\n          endCol = newGrid.getTileCol(endInd);\n      return Math.abs(goalRow - endRow) + Math.abs(goalCol - endCol) - Math.abs(goalRow - startRow) + Math.abs(goalCol - startCol);\n    } // returns whether heuristic value indicates if puzzle is solved\n\n  }, {\n    key: \"isSolved\",\n    value: function isSolved(heuristicValue) {\n      return heuristicValue === 0;\n    }\n  }]);\n\n  return ManhattanHeuristic;\n}(); // NOTE: methods not static to support using cached MD data specific to puzzle\n\n\nvar LinearConflictHeuristic =\n/*#__PURE__*/\nfunction (_ManhattanHeuristic) {\n  _inherits(LinearConflictHeuristic, _ManhattanHeuristic);\n\n  function LinearConflictHeuristic(numRows, numCols) {\n    _classCallCheck(this, LinearConflictHeuristic);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LinearConflictHeuristic).call(this, numRows, numCols));\n  } // returns false if could not be completed, true otherwise\n\n\n  _createClass(LinearConflictHeuristic, [{\n    key: \"_precompute\",\n    value: function _precompute() {\n      _get(_getPrototypeOf(LinearConflictHeuristic.prototype), \"_precompute\", this).call(this);\n\n      var n = Math.max(this.numRows, this.numCols); // avoid precomputation when n > 8 or puzzle is 1D (can just use MD)\n      // 9 has 986,409 perms\n      // 8 has 19,173,960 spaces (each > 1 byte given Uint8Array and overhead)\n      // while precomputing still feasible for n = 9, no point as > 1D puzzles not\n      // optimally solvable at that point for current solvers here\n      // ndarray also becomes too large when n = 10 (thros error)\n\n      if (n > 8 || this.numRows === 1 || this.numCols === 1) {\n        return false;\n      } // NOTE: ndarray used instead of map, as constant toString() computationally costlier\n      // than indexing into ndarray\n      // cons: much larger space consumption (sum of n^k from k = 1 to n)\n      // consumes 19,173,960 spaces (each > 1 byte given Uint8Array and overhead) when n = 8\n\n\n      this._lc = new Array(n);\n\n      for (var permSize = 1; permSize <= n; permSize++) {\n        this._lc[permSize] = ndarray__WEBPACK_IMPORTED_MODULE_2___default()(new Uint8Array(Math.pow(n, permSize)), new Uint8Array(permSize).fill(n));\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._permutationHelper(n)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _this$_lc$perm$length;\n\n          var perm = _step.value;\n\n          (_this$_lc$perm$length = this._lc[perm.length]).set.apply(_this$_lc$perm$length, _toConsumableArray(perm).concat([this._calculate(perm)]));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    } // returns Generator over possible\n    // NOTE: # permutations = sum of n permute k from k = 1 to n = ⌊en!−1⌋\n\n  }, {\n    key: \"_permutationHelper\",\n    value:\n    /*#__PURE__*/\n    regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _permutationHelper(n) {\n      var arr, permSize, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, perm;\n\n      return regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _permutationHelper$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // while Int8Array goes from 0 to 255, acceptable as memory requirements\n              // balloon when numRows/numCols > 8\n              arr = Uint8Array.from(Object(_math_util__WEBPACK_IMPORTED_MODULE_4__[\"range\"])(n));\n              permSize = 1;\n\n            case 2:\n              if (!(permSize <= n)) {\n                _context.next = 32;\n                break;\n              }\n\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 6;\n              _iterator2 = Object(_math_util__WEBPACK_IMPORTED_MODULE_4__[\"permutationGenerator\"])(arr, permSize)[Symbol.iterator]();\n\n            case 8:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              perm = _step2.value;\n              _context.next = 12;\n              return perm;\n\n            case 12:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 8;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context[\"catch\"](6);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError2) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              permSize++;\n              _context.next = 2;\n              break;\n\n            case 32:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _permutationHelper, this, [[6, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: \"_calculate\",\n    value: function _calculate(arr) {\n      var map = new Map();\n\n      for (var i = 0; i < arr.length; i++) {\n        var goalInd = arr[i];\n        map.set(i, {\n          goalInd: goalInd,\n          conflicts: new Set()\n        });\n      }\n\n      return this._calculateForMap(map);\n    } // TODO: consider separating lc condition check into new function for possibly better performance\n    // (less \"if\" checks)\n    // calculates linear conflict of specified grid\n    // optional start/end params allow specifying section of grid to calculate conflict heuristic for\n    // rectangular section of grid, where start is inclusive and end if exclusive\n    // calcMD determines if calculate() includes Manhattan Distance in heuristic calculation\n    // NOTE: since linear conflict + MD always admissible and at least as good, only use\n    // calcMD = false for testing or if you plan on calculating MD in a different way\n    // ex: calculate(grid, 0, 3, 1, 2) calculates heuristic for 3 tile tall vertical chunk\n    // in col[1] from row[0->2]\n    // Heuristic explanation:\n    // linear conflict = 2 tiles in the same goal row/col but have inversion relationship.\n    // horizontal: (a is to right of b but a's goal is to left of b's goal)\n    // vertical: same but with bottom and top instead of right and left\n    // To reach goal positions, one of the tiles in the pair has to move out of the way\n    // for the other tile to reach their goal. The moved tile has to move back into their\n    // goal row/col to reach their goals.\n    //\n    // Linear conflict is calculated on every row and column, and can be combined with\n    // manhattan distance heuristic to make better admissible heuristic,\n    // as manhattan distance heuristic doesn't account for moving tiles out of the way\n    // and linear conflct doesn't account for moving to the correct tile position \n    //\n    // WARNING: You can't just add 2 to the heuristic value for each inversion found,\n    // as moving one tile out of the way can allow 2 tiles it conflicts with to move into their goals\n    // ex: [3, 1, 2] has goal positions of [1, 2, 3]\n    // to reach the goal, move 3 down and slide 1 and 2 over, and then move 3 to the goal\n    // while there are 2 inversions (3, 1) and (3, 2), moving 3 out of the way for 1 means\n    // that it is out of the way for 2 as well.\n    // If you added 2 for each inversion, heuristic = LC = (2 + 2) + MD = (2 + 1 + 1) = 8\n    // when the optimal solution only takes 6 moves (\"3\" down, \"1\" left, \"2\" left, \"3\" right x2, \"3\" up)\n\n  }, {\n    key: \"calculate\",\n    value: function calculate(grid) {\n      var heuristicValue = 0; // candidateTiles.get(i) = map of tiles of row/col i that are in their goal row/col\n      // map = {ind: {goalInd, conflicts}}\n      // - ind = current index in flattened puzzle array\n      // - goalInd = value at ind = index of the tile in the goal puzzle\n      // - conflicts is a set of conflicting indices (initially empty)\n      // NOTE: cols accessed at key = column index + grid.numRows\n      // (first grid.numRows entries are for rows, next grid.numCols entries for columns)\n\n      var candidateTiles = new Map(); // determines which tiles are in their goal row and/or column\n\n      for (var row = 0; row < this.numRows; row++) {\n        for (var col = 0; col < this.numCols; col++) {\n          var ind = grid.getIndex(row, col);\n          var goalInd = grid.tiles[ind],\n              goalRow = grid.getTileRow(goalInd),\n              goalCol = grid.getTileCol(goalInd);\n\n          if (ind !== grid.emptyPos) {\n            // add manhattan distance to heuristic value\n            if (this._md) {\n              heuristicValue += this._md.get(ind, goalInd);\n            } else {\n              heuristicValue += Math.abs(row - goalRow) + Math.abs(col - goalCol);\n            } // NOTE: single tile can be candidate for both row and col conflict\n            // as tile can be part of conflict even when it's in its goal position\n\n\n            if (grid.getTileRow(goalInd) === row) {\n              if (this._lc) {\n                if (!candidateTiles.has(row)) {\n                  candidateTiles.set(row, []);\n                }\n\n                candidateTiles.get(row).push(goalCol);\n              } else {\n                if (!candidateTiles.has(row)) {\n                  candidateTiles.set(row, new Map());\n                }\n\n                candidateTiles.get(row).set(ind, {\n                  goalInd: goalInd,\n                  conflicts: new Set()\n                });\n              }\n            }\n\n            if (grid.getTileCol(goalInd) === col) {\n              var key = grid.numRows + col;\n\n              if (this._lc) {\n                if (!candidateTiles.has(key)) {\n                  candidateTiles.set(key, []);\n                }\n\n                candidateTiles.get(key).push(goalRow);\n              } else {\n                if (!candidateTiles.has(key)) {\n                  candidateTiles.set(key, new Map());\n                }\n\n                candidateTiles.get(key).set(ind, {\n                  goalInd: goalInd,\n                  conflicts: new Set()\n                });\n              }\n            }\n          }\n        }\n      } // TODO: consider making custom function for update since only need to examine\n      // if tile in 1 (known) goal dimension and map also unnecessary\n      // maybe helper functions for processing each row/col?\n      // don't use helpers for regular calculate() though (probably less efficient\n      // since each tile would be iterated over twice (separately for row and col))\n\n\n      if (this._lc) {\n        // TODO: use values since keys unnecessary now\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = candidateTiles.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _this$_lc$arr$length;\n\n            var _step3$value = _slicedToArray(_step3.value, 2),\n                arr = _step3$value[1];\n\n            heuristicValue += (_this$_lc$arr$length = this._lc[arr.length]).get.apply(_this$_lc$arr$length, _toConsumableArray(arr));\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      } else {\n        // row/grid.numRows + col no longer relevant and can be discarded \n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = candidateTiles.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n                map = _step4$value[1];\n\n            heuristicValue += this._calculateForMap(map);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      return heuristicValue;\n    }\n  }, {\n    key: \"_calculateForMap\",\n    value: function _calculateForMap(map) {\n      if (map.size < 2) {\n        return 0;\n      }\n\n      var heuristicValue = 0;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = map[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              ind1 = _step5$value[0],\n              _step5$value$ = _step5$value[1],\n              goalInd1 = _step5$value$.goalInd,\n              conflicts1 = _step5$value$.conflicts;\n\n          var _iteratorNormalCompletion8 = true;\n          var _didIteratorError8 = false;\n          var _iteratorError8 = undefined;\n\n          try {\n            for (var _iterator8 = map[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n              var _step8$value = _slicedToArray(_step8.value, 2),\n                  ind2 = _step8$value[0],\n                  _step8$value$ = _step8$value[1],\n                  goalInd2 = _step8$value$.goalInd,\n                  conflicts2 = _step8$value$.conflicts;\n\n              if (ind2 > ind1 && goalInd2 < goalInd1) {\n                map.get(ind1).conflicts.add(ind2);\n                map.get(ind2).conflicts.add(ind1);\n              }\n            }\n          } catch (err) {\n            _didIteratorError8 = true;\n            _iteratorError8 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                _iterator8.return();\n              }\n            } finally {\n              if (_didIteratorError8) {\n                throw _iteratorError8;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var conflictTree = new avl__WEBPACK_IMPORTED_MODULE_3__[\"default\"](function (a, b) {\n        if (a.ind === b.ind) return 0;\n        var diff = a.conflicts.size - b.conflicts.size; // sorts by ind ascending if conflicts equal\n        // necessary to identify object by ind in tree, as node with same # conflicts\n        // as desired node can appear before desired node\n\n        return diff === 0 ? a.ind - b.ind : diff;\n      });\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = map[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              ind = _step6$value[0],\n              _step6$value$ = _step6$value[1],\n              goalInd = _step6$value$.goalInd,\n              conflicts = _step6$value$.conflicts;\n\n          if (conflicts.size > 0) {\n            conflictTree.insert({\n              conflicts: conflicts,\n              ind: ind\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var tile;\n\n      while (conflictTree.size > 0) {\n        tile = conflictTree.max(); // NOTE: library has no option for finding and removing largest item in one step\n        // could use pop() workaround with opposite comparator, but pop also calls\n        // remove() after finding min in current version (1.4.4)\n\n        conflictTree.remove(tile); // heuristic += 2 for each tile that must be removed before there are no conflicts\n\n        heuristicValue += 2;\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = tile.conflicts[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var conflict = _step7.value;\n            // corresponding conflicts of conflicting tile\n            // ex: a.conflicts = [b,c], b.conflicts = [a], corrConflicts of a = (Set) [a]\n            var corrConflicts = map.get(conflict).conflicts;\n            var corrObj = {\n              conflicts: corrConflicts,\n              ind: conflict\n            };\n            conflictTree.remove(corrObj); // NOTE: tree uses reference to same conflicts object, so conflicts updated there as well\n\n            corrConflicts.delete(tile.ind); // removed and inserted to reorder based on new number of conflicts\n\n            if (corrConflicts.size > 0) {\n              conflictTree.insert(corrObj);\n            }\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      }\n\n      return heuristicValue;\n    } // calculates LC for given row index\n    // NOTE: doesn't incorporate MD\n\n  }, {\n    key: \"_calculateForRow\",\n    value: function _calculateForRow(grid, row) {\n      var candidateTiles = this._lc ? [] : new Map();\n\n      for (var col = 0; col < this.numCols; col++) {\n        var ind = col + this.numCols * row;\n\n        if (ind !== grid.emptyPos) {\n          var goalInd = grid.tiles[ind],\n              goalRow = grid.getTileRow(goalInd),\n              goalCol = grid.getTileCol(goalInd);\n\n          if (row === goalRow) {\n            if (this._lc) {\n              candidateTiles.push(goalCol);\n            } else {\n              candidateTiles.set(col, {\n                goalInd: goalCol,\n                conflicts: new Set()\n              });\n            }\n          }\n        }\n      }\n\n      if (this._lc) {\n        var _this$_lc$candidateTi;\n\n        if (candidateTiles.length < 2) {\n          return 0;\n        }\n\n        return (_this$_lc$candidateTi = this._lc[candidateTiles.length]).get.apply(_this$_lc$candidateTi, _toConsumableArray(candidateTiles));\n      }\n\n      return this._calculateForMap(candidateTiles);\n    } // calculates LC for given column index\n    // NOTE: doesn't incorporate MD\n\n  }, {\n    key: \"_calculateForCol\",\n    value: function _calculateForCol(grid, col) {\n      var candidateTiles = this._lc ? [] : new Map();\n\n      for (var row = 0; row < this.numRows; row++) {\n        var ind = col + this.numCols * row;\n\n        if (ind !== grid.emptyPos) {\n          var goalInd = grid.tiles[ind],\n              goalRow = grid.getTileRow(goalInd),\n              goalCol = grid.getTileCol(goalInd);\n\n          if (col === goalCol) {\n            if (this._lc) {\n              candidateTiles.push(goalRow);\n            } else {\n              candidateTiles.set(row, {\n                goalInd: goalRow,\n                conflicts: new Set()\n              });\n            }\n          }\n        }\n      }\n\n      if (this._lc) {\n        var _this$_lc$candidateTi2;\n\n        if (candidateTiles.length < 2) {\n          return 0;\n        }\n\n        return (_this$_lc$candidateTi2 = this._lc[candidateTiles.length]).get.apply(_this$_lc$candidateTi2, _toConsumableArray(candidateTiles));\n      }\n\n      return this._calculateForMap(candidateTiles);\n    }\n  }, {\n    key: \"update\",\n    value: function update(newGrid, startInd, endInd, move) {\n      return this.getUpdateDelta(newGrid, startInd, endInd, move) + newGrid.heuristicValue;\n    } // TODO: consider maintaining separate update functions for clone and no clone\n    // can be called by cloneAndApplyMove and applyMove respectively\n    // TODO: consider splitting update into 2 parts so newGrid isn't switched back and forth in IDA*\n    // (or create helper that also takes in start and end locations of tile as well as newGrid\n    // for use in IDA*)\n    // TODO: have update function that returns updated grid for use in ida*\n    // TODO: see if calculate() needs anything changed besides emptyPos and tile swap\n    // returns change in heuristic distance from move\n    // newGrid = Grid after move (distinct object), with all properties updated besides heuristicValue\n    // startInd = ind moved tile started in\n    // endInd = ind moved tile ended up in\n    // move = single-letter move within 'l/r/u/d'\n\n  }, {\n    key: \"getUpdateDelta\",\n    value: function getUpdateDelta(newGrid, startInd, endInd, move) {\n      var startRow = newGrid.getTileRow(startInd),\n          startCol = newGrid.getTileCol(startInd);\n      var startVal = 0,\n          endVal = 0;\n      var func;\n      var inds;\n\n      switch (move) {\n        case 'l':\n          func = this._calculateForCol;\n          inds = [startCol, startCol - 1];\n          break;\n\n        case 'r':\n          func = this._calculateForCol;\n          inds = [startCol, startCol + 1];\n          break;\n\n        case 'u':\n          func = this._calculateForRow;\n          inds = [startRow, startRow - 1];\n          break;\n\n        case 'd':\n          func = this._calculateForRow;\n          inds = [startRow, startRow + 1];\n          break;\n      } // Manhattan distance not calculated in func as only needs to be calculated\n      // for single tile moved (more efficient to calculate separately)\n\n\n      endVal += func.call(this, newGrid, inds[0]);\n      endVal += func.call(this, newGrid, inds[1]); // returns grid partially to pre-move state to calculate LC for relevant cols pre-move\n\n      newGrid.swap(startInd, endInd);\n      newGrid.emptyPos = endInd;\n      startVal += func.call(this, newGrid, inds[0]);\n      startVal += func.call(this, newGrid, inds[1]); // return grid to original state\n\n      newGrid.swap(startInd, endInd);\n      newGrid.emptyPos = startInd;\n      return endVal - startVal + _get(_getPrototypeOf(LinearConflictHeuristic.prototype), \"getUpdateDelta\", this).call(this, newGrid, startInd, endInd, move);\n    } // returns whether heuristic value indicates if puzzle is solved\n\n  }, {\n    key: \"isSolved\",\n    value: function isSolved(heuristicValue) {\n      return heuristicValue === 0;\n    }\n  }]);\n\n  return LinearConflictHeuristic;\n}(ManhattanHeuristic); // NOTE: separate from puzzle-graphic's Puzzles to ease testing and reduce memory cost in A*\n// TODO: consider changing numCols/numRows to numRows, numCols for clarity + consistency\n\n\nvar Puzzle =\n/*#__PURE__*/\nfunction () {\n  // TODO: set default solver to null after done testing so solver adaptive to puzzle size\n\n  /**\n   * creates new Puzzle instance\n   * @param numRows # rows in grid\n   * @param numCols # columns in grid\n   * @param tiles flattened array of tile ids corresponding to their locations in the unsolved puzzle\n   * (where ids = tile positions in the solved puzzle left to right, top to bottom, 0 indexed)\n   * @param emptyPos position of empty tile in grid\n   * @param heuristic heuristic used to determine how far grid is from goal state. Default heuristic is Manhattan Distance\n   */\n  function Puzzle(numRows, numCols, tiles, emptyPos) {\n    var heuristic = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : LinearConflictHeuristic;\n    var solver = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'IDA*';\n\n    _classCallCheck(this, Puzzle);\n\n    this.numRows = numRows;\n    this.numCols = numCols; // use less memory if possible\n\n    this.tiles = numRows * numCols > 256 ? Uint16Array.from(tiles) : Uint8Array.from(tiles);\n    this.emptyPos = emptyPos;\n    this.heuristic = new heuristic(numRows, numCols);\n\n    if (solver === null) {\n      this.solver = numRows * numCols > 9 ? 'IDA*' : 'A*';\n    } else {\n      this.solver = solver;\n    }\n  }\n\n  _createClass(Puzzle, [{\n    key: \"solve\",\n    value: function solve() {\n      var maxIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100000;\n\n      if (this.solver === 'A*') {\n        return this.solveAStar(maxIterations);\n      } else if (this.solver === 'IDA*') {\n        return this.solveIDAStar(maxIterations);\n      }\n    }\n  }, {\n    key: \"solveAStar\",\n    value: function solveAStar(maxIterations) {\n      // TODO: consider using bucket queue instead of priority queue\n      // e.g. array where key = total distance, value = node with that distance\n      // also consider nested bucket queue to allow ordering by traveledDist to tie-break\n      var q = new fastpriorityqueue__WEBPACK_IMPORTED_MODULE_1___default.a( // NOTE: comparator puts grid1 first if return \"true\" (grid1 less than grid2)\n      function (grid1, grid2) {\n        var total1 = grid1.heuristicValue + grid1.traveledDist,\n            total2 = grid2.heuristicValue + grid2.traveledDist; // favor grids with more traveled distance\n        // explanation: since admissisible heuristics\n        // underestimate or match actual distance to goal,\n        // actual distance of grid with more traveled distance is likely to be <=\n        // actual distance of grid with less traveled distance\n        // when total distance is equal\n\n        return total1 === total2 ? grid1.traveledDist > grid2.traveledDist : total1 < total2;\n      });\n      var grid = new Grid(this.numRows, this.numCols, this.tiles, this.emptyPos, this.heuristic, 0);\n      q.add(grid);\n      var curr; // maps Grid state to best/shortest (heuristic + distance traveled) found so far\n\n      var best = new Map();\n      var iterations = 0;\n\n      while (q.size > 0) {\n        if (iterations > maxIterations) {\n          throw new Error('Max number of iterations exceeded');\n        }\n\n        curr = q.poll();\n\n        if (curr.isSolved()) {\n          console.log(iterations);\n          return curr.reconstructPath();\n        }\n\n        var _iteratorNormalCompletion9 = true;\n        var _didIteratorError9 = false;\n        var _iteratorError9 = undefined;\n\n        try {\n          for (var _iterator9 = curr.getValidMoves()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n            var move = _step9.value;\n\n            // reversing a move will never lead to an optimal path\n            if (move !== Grid.getReversedMove(curr.lastMove)) {\n              var newGrid = curr.cloneAndApplyMove(move);\n              var score = newGrid.traveledDist + newGrid.heuristicValue;\n              var key = newGrid.tiles.toString(); // add to queue and replace best score if score better than previous best\n              // NOTE: not using <, as previous best could be undefined\n              // executes if best either undefined or >= current score\n              // NOTE: obviates need for visited set, as only adds node when\n              // better than best found so far vs. adding when better than best possible\n              // (by the time best possible is found, several nodes could be discarded\n              // by being worse than previous discovered not-yet-popped nodes)\n\n              if (!(score >= best.get(key))) {\n                best.set(key, score);\n                q.add(newGrid);\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError9 = true;\n          _iteratorError9 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n              _iterator9.return();\n            }\n          } finally {\n            if (_didIteratorError9) {\n              throw _iteratorError9;\n            }\n          }\n        }\n\n        iterations++;\n      } // no solution found\n\n\n      return null;\n    } // TODO: make use of maxIterations or some other limiting function to stop freezing browser\n\n  }, {\n    key: \"solveIDAStar\",\n    value: function solveIDAStar(maxIterations) {\n      var grid = new Grid(this.numRows, this.numCols, this.tiles, this.emptyPos, this.heuristic, 0); // upper bound of total distance for when to stop exploring nodes in given iteration of dfs\n\n      var bound = grid.heuristicValue;\n      var path = [];\n\n      while (true) {\n        var output = this._searchIDAStar(grid, path, 0, bound);\n\n        if (output === true) {\n          return path;\n        } else if (output === Infinity) {\n          return null;\n        } // upper bound of search updated to min total distance explored that was\n        // greater than previous bound\n\n\n        bound = output;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_searchIDAStar\",\n    value: function _searchIDAStar(grid, path, traveledDist, bound) {\n      var totalDist = traveledDist + grid.heuristicValue;\n      if (totalDist > bound) return totalDist;\n      if (grid.isSolved()) return true; // tracks min total distance of all nodes explored\n\n      var minTotalDist = Infinity;\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = grid.getValidMoves()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var move = _step10.value;\n\n          // reversing previous move never leads to optimal solution\n          if (move !== Grid.getReversedMove(path[path.length - 1])) {\n            var moveRecord = grid.applyMove(move);\n            path.push(move);\n\n            var output = this._searchIDAStar(grid, path, traveledDist + 1, bound);\n\n            if (output === true) return true;\n            if (output < minTotalDist) minTotalDist = output;\n            path.pop();\n            grid.reverseMove(moveRecord);\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      return minTotalDist;\n    }\n  }]);\n\n  return Puzzle;\n}(); // TODO: consider moving validMoves to field of Class instead of instance\n// (indexed under grid dimensions)\n// TODO: consider having both this and graphical grid extend from same base class to reuse move functions\n\n\nvar Grid =\n/*#__PURE__*/\nfunction () {\n  function Grid(numRows, numCols, tiles, emptyPos, heuristic, traveledDist) {\n    var heuristicValue = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    var lastMove = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    var lastGrid = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n    var validMoves = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n\n    _classCallCheck(this, Grid);\n\n    this.numRows = numRows;\n    this.numCols = numCols;\n    this.tiles = tiles;\n    this.emptyPos = emptyPos;\n    this.heuristic = heuristic;\n    this.traveledDist = traveledDist;\n    this.heuristicValue = heuristicValue === null ? heuristic.calculate(this) : heuristicValue;\n    this.lastMove = lastMove;\n    this.lastGrid = lastGrid; // TODO: attach to external obj or pass between grids to avoid recomputing every new grid\n    // precomputing values for better performance\n    // IDEA: do all precomputing inside Puzzle() to be referenced by Grid\n    // (passing along takes up memory)\n\n    this.validMoves = validMoves === null ? this._precomputeValidMoves() : validMoves;\n  }\n\n  _createClass(Grid, [{\n    key: \"getTileCol\",\n    value: function getTileCol(ind) {\n      return ind % this.numCols;\n    }\n  }, {\n    key: \"getTileRow\",\n    value: function getTileRow(ind) {\n      return Math.floor(ind / this.numCols);\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(row, col) {\n      return row * this.numCols + col;\n    } // returns change in index of tile to be moved after move\n\n  }, {\n    key: \"getMoveDelta\",\n    value: function getMoveDelta(move) {\n      var moveDeltaMap = {\n        'r': 1,\n        'l': -1,\n        'u': -this.numCols,\n        'd': this.numCols\n      };\n      return moveDeltaMap[move];\n    } // TODO: consider instead caching movedInd for every move + emptyPos combo O(n)\n    // returns index of tile that would be moved by specified move\n\n  }, {\n    key: \"getMovedInd\",\n    value: function getMovedInd(move) {\n      return this.emptyPos - this.getMoveDelta(move);\n    }\n  }, {\n    key: \"getTileDist\",\n    value: function getTileDist(tile1, tile2) {\n      return Math.abs(this.getTileRow(tile1) - this.getTileRow(tile2)) + Math.abs(this.getTileCol(tile1) - this.getTileCol(tile2));\n    }\n  }, {\n    key: \"reconstructPath\",\n    value: function reconstructPath() {\n      var path = [];\n      var curr = this;\n\n      while (curr.lastMove !== null) {\n        path.unshift(curr.lastMove);\n        curr = curr.lastGrid;\n      }\n\n      return path;\n    }\n    /**\n     * returns deep copy of grid ignoring lastGrid (null)\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Grid(this.numRows, this.numCols, this.tiles.slice(), this.emptyPos, this.heuristic, this.traveledDist, this.heuristicValue, this.lastMove, null, this.validMoves);\n    }\n    /**\n     * returns copy of current grid with specified directional move applied to tile moving into empty position\n     * also updates all affected Grid fields in new Grid (emptyPos, heuristic/travel distance, etc.)\n     * @param move direction to move tile into empty space\n     * @return returns copy of current grid with specified move applied to tile into empty position\n     */\n\n  }, {\n    key: \"cloneAndApplyMove\",\n    value: function cloneAndApplyMove(move) {\n      var newGrid = this.clone();\n      newGrid.lastGrid = this;\n      newGrid.lastMove = move;\n      return Grid._applyMoveHelper(move, newGrid);\n    } // Applies move to grid NOT clone on grid\n    // Returns moveRecord object storing old heuristicValue and emptyPos (for use in reverseMove())\n    // (useful for IDA* as memory allocation can be avoided)\n    // NOTE: separate function instead of consolidation with \"clone\" param for slightly better performance\n    // NOTE: does NOT update lastMove or lastGrid\n\n  }, {\n    key: \"applyMove\",\n    value: function applyMove(move) {\n      var oldHeuristicValue = this.heuristicValue;\n      var oldEmptyPos = this.emptyPos;\n\n      Grid._applyMoveHelper(move, this); // TODO; consider changing to typedArray for slightly better performance\n\n\n      return {\n        heuristicValue: oldHeuristicValue,\n        emptyPos: oldEmptyPos\n      };\n    }\n  }, {\n    key: \"reverseMove\",\n    value: function reverseMove(moveRecord) {\n      this.traveledDist--;\n      this.heuristicValue = moveRecord.heuristicValue;\n      this.swap(this.emptyPos, moveRecord.emptyPos);\n      this.emptyPos = moveRecord.emptyPos;\n    } // applies move to specified grid WITHOUT updating lastMove or lastGrid\n\n  }, {\n    key: \"swap\",\n\n    /**\n     * WARNING: Does NOT update heuristicValue, lastMove, emptyPos, or lastGrid\n     * swaps 2 positions in grid.\n     */\n    value: function swap(pos1, pos2) {\n      var _ref = [this.tiles[pos2], this.tiles[pos1]];\n      this.tiles[pos1] = _ref[0];\n      this.tiles[pos2] = _ref[1];\n    } // precomputes valid moves for each possible emptyPos to give slight performance benefit\n\n  }, {\n    key: \"_precomputeValidMoves\",\n    value: function _precomputeValidMoves() {\n      var moves;\n      var validMoves = [];\n\n      for (var emptyPos = 0; emptyPos < this.tiles.length; emptyPos++) {\n        moves = [];\n        var row = this.getTileRow(emptyPos);\n        var col = this.getTileCol(emptyPos);\n\n        if (row < this.numRows - 1) {\n          moves.push('u');\n        }\n\n        if (row > 0) {\n          moves.push('d');\n        }\n\n        if (col < this.numCols - 1) {\n          moves.push('l');\n        }\n\n        if (col > 0) {\n          moves.push('r');\n        }\n\n        validMoves[emptyPos] = moves;\n      }\n\n      return validMoves;\n    }\n    /**\n     * returns array of valid moves, where 'l' = left, 'r' = right, 'd' = down, and 'u' = up.\n     * @returns {Array} array of valid moves, where moves are defined by tiles moving into the empty space in the grid\n     */\n\n  }, {\n    key: \"getValidMoves\",\n    value: function getValidMoves() {\n      return this.validMoves[this.emptyPos];\n    }\n    /**\n     * Returns whether grid is solved assuming goal is [0, 1, ... tiles.length - 1]\n     * @returns {boolean} whether puzzle is solved\n     */\n\n  }, {\n    key: \"isSolved\",\n    value: function isSolved() {\n      if (this.heuristic.isSolved(this.heuristicValue)) return true; // accounts for if can't determine if puzzle solved using heuristic value\n\n      return this.tiles.every(function (goalInd, ind) {\n        return goalInd === ind;\n      });\n    }\n  }], [{\n    key: \"getReversedMove\",\n    value: function getReversedMove(move) {\n      return REVERSE_MOVE_MAP[move];\n    }\n  }, {\n    key: \"_applyMoveHelper\",\n    value: function _applyMoveHelper(move, grid) {\n      var movedInd = grid.getMovedInd(move);\n      var endInd = grid.emptyPos;\n      grid.swap(endInd, movedInd);\n      grid.emptyPos = movedInd;\n      grid.traveledDist++;\n      grid.heuristicValue = grid.heuristic.update(grid, movedInd, endInd, move);\n      return grid;\n    }\n  }]);\n\n  return Grid;\n}();\n\nfunction testLinearConflictHeuristic() {\n  var testCases = [[[0, 2, 1, 7, 4, 5, 6, 3, 8], 0], [[0, 2, 1, 5, 4, 3, 6, 7, 8], 0], [[4, 3, 6, 8, 0, 7, 5, 2, 1], 4], [[2, 7, 0, 5, 4, 3, 8, 1, 6], 2]];\n  var ans = [8, 12, 22, 24];\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = testCases.entries()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var _step11$value = _slicedToArray(_step11.value, 2),\n          ind = _step11$value[0],\n          testCase = _step11$value[1];\n\n      var testGrid = _construct(Grid, [3, 3].concat(_toConsumableArray(testCase), [new LinearConflictHeuristic(3, 3), 0]));\n\n      console.assert(testGrid.heuristicValue === ans[ind], \"incorrect answer: answer = \".concat(testGrid.heuristicValue, \", correct answer = \").concat(ans[ind]));\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n} // TODO: remove after done testing\n// testLinearConflictHeuristic();\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Puzzle);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2xpZGluZy1wdXp6bGUtYWxnb3JpdGhtcy5qcz9iMTE5Il0sIm5hbWVzIjpbIlJFVkVSU0VfTU9WRV9NQVAiLCJNYW5oYXR0YW5IZXVyaXN0aWMiLCJudW1Sb3dzIiwibnVtQ29scyIsIm51bVRpbGVzIiwiX3ByZWNvbXB1dGUiLCJtb3ZlTnVtYmVyTWFwIiwiX21kIiwibmRhcnJheSIsIlVpbnQxNkFycmF5IiwiX21kRGVsdGEiLCJJbnQ4QXJyYXkiLCJtb3ZlRGVsdGFNYXAiLCJJbnQxNkFycmF5IiwiZnJvbSIsImluZCIsImdvYWxJbmQiLCJyb3cxIiwiY29sMSIsInJvdzIiLCJjb2wyIiwic2V0IiwiTWF0aCIsImFicyIsInN0YXJ0TUQiLCJnZXQiLCJtb3ZlIiwiZW5kTUQiLCJncmlkIiwiZGlzdCIsImkiLCJ0aWxlcyIsImxlbmd0aCIsImVtcHR5UG9zIiwiZ2V0VGlsZURpc3QiLCJuZXdHcmlkIiwic3RhcnRJbmQiLCJlbmRJbmQiLCJnZXRVcGRhdGVEZWx0YSIsImhldXJpc3RpY1ZhbHVlIiwiZ29hbFJvdyIsImdldFRpbGVSb3ciLCJnb2FsQ29sIiwiZ2V0VGlsZUNvbCIsInN0YXJ0Um93Iiwic3RhcnRDb2wiLCJlbmRSb3ciLCJlbmRDb2wiLCJMaW5lYXJDb25mbGljdEhldXJpc3RpYyIsIm4iLCJtYXgiLCJfbGMiLCJBcnJheSIsInBlcm1TaXplIiwiVWludDhBcnJheSIsImZpbGwiLCJfcGVybXV0YXRpb25IZWxwZXIiLCJwZXJtIiwiX2NhbGN1bGF0ZSIsImFyciIsInJhbmdlIiwicGVybXV0YXRpb25HZW5lcmF0b3IiLCJtYXAiLCJNYXAiLCJjb25mbGljdHMiLCJTZXQiLCJfY2FsY3VsYXRlRm9yTWFwIiwiY2FuZGlkYXRlVGlsZXMiLCJyb3ciLCJjb2wiLCJnZXRJbmRleCIsImhhcyIsInB1c2giLCJrZXkiLCJlbnRyaWVzIiwic2l6ZSIsImluZDEiLCJnb2FsSW5kMSIsImNvbmZsaWN0czEiLCJpbmQyIiwiZ29hbEluZDIiLCJjb25mbGljdHMyIiwiYWRkIiwiY29uZmxpY3RUcmVlIiwiQVZMVHJlZSIsImEiLCJiIiwiZGlmZiIsImluc2VydCIsInRpbGUiLCJyZW1vdmUiLCJjb25mbGljdCIsImNvcnJDb25mbGljdHMiLCJjb3JyT2JqIiwiZGVsZXRlIiwic3RhcnRWYWwiLCJlbmRWYWwiLCJmdW5jIiwiaW5kcyIsIl9jYWxjdWxhdGVGb3JDb2wiLCJfY2FsY3VsYXRlRm9yUm93IiwiY2FsbCIsInN3YXAiLCJQdXp6bGUiLCJoZXVyaXN0aWMiLCJzb2x2ZXIiLCJtYXhJdGVyYXRpb25zIiwic29sdmVBU3RhciIsInNvbHZlSURBU3RhciIsInEiLCJGYXN0UHJpb3JpdHlRdWV1ZSIsImdyaWQxIiwiZ3JpZDIiLCJ0b3RhbDEiLCJ0cmF2ZWxlZERpc3QiLCJ0b3RhbDIiLCJHcmlkIiwiY3VyciIsImJlc3QiLCJpdGVyYXRpb25zIiwiRXJyb3IiLCJwb2xsIiwiaXNTb2x2ZWQiLCJjb25zb2xlIiwibG9nIiwicmVjb25zdHJ1Y3RQYXRoIiwiZ2V0VmFsaWRNb3ZlcyIsImdldFJldmVyc2VkTW92ZSIsImxhc3RNb3ZlIiwiY2xvbmVBbmRBcHBseU1vdmUiLCJzY29yZSIsInRvU3RyaW5nIiwiYm91bmQiLCJwYXRoIiwib3V0cHV0IiwiX3NlYXJjaElEQVN0YXIiLCJJbmZpbml0eSIsInRvdGFsRGlzdCIsIm1pblRvdGFsRGlzdCIsIm1vdmVSZWNvcmQiLCJhcHBseU1vdmUiLCJwb3AiLCJyZXZlcnNlTW92ZSIsImxhc3RHcmlkIiwidmFsaWRNb3ZlcyIsImNhbGN1bGF0ZSIsIl9wcmVjb21wdXRlVmFsaWRNb3ZlcyIsImZsb29yIiwiZ2V0TW92ZURlbHRhIiwidGlsZTEiLCJ0aWxlMiIsInVuc2hpZnQiLCJzbGljZSIsImNsb25lIiwiX2FwcGx5TW92ZUhlbHBlciIsIm9sZEhldXJpc3RpY1ZhbHVlIiwib2xkRW1wdHlQb3MiLCJwb3MxIiwicG9zMiIsIm1vdmVzIiwiZXZlcnkiLCJtb3ZlZEluZCIsImdldE1vdmVkSW5kIiwidXBkYXRlIiwidGVzdExpbmVhckNvbmZsaWN0SGV1cmlzdGljIiwidGVzdENhc2VzIiwiYW5zIiwidGVzdENhc2UiLCJ0ZXN0R3JpZCIsImFzc2VydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQSxJQUFNQSxnQkFBZ0IsR0FBRztBQUNyQixPQUFLLEdBRGdCO0FBRXJCLE9BQUssR0FGZ0I7QUFHckIsT0FBSyxHQUhnQjtBQUlyQixPQUFLLEdBSmdCLENBU3pCO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQWxCeUIsQ0FBekI7O0lBbUJNQyxrQjs7O0FBRUYsOEJBQVlDLE9BQVosRUFBcUJDLE9BQXJCLEVBQThCO0FBQUE7O0FBQzFCLFNBQUtELE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0JGLE9BQU8sR0FBR0MsT0FBMUI7O0FBRUEsU0FBS0UsV0FBTDs7QUFFQSxTQUFLQyxhQUFMLEdBQXFCO0FBQ2pCLFdBQUssQ0FEWTtBQUVqQixXQUFLLENBRlk7QUFHakIsV0FBSyxDQUhZO0FBSWpCLFdBQUs7QUFKWSxLQUFyQjtBQU1ILEcsQ0FFRDtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7OztrQ0FDYztBQUVWO0FBQ0EsVUFBSSxLQUFLRixRQUFMLEdBQWdCLEdBQXBCLEVBQXlCO0FBQ3JCLGVBQU8sS0FBUDtBQUNILE9BTFMsQ0FPVjs7O0FBQ0EsV0FBS0csR0FBTCxHQUFXQyw4Q0FBTyxDQUFDLElBQUlDLFdBQUosVUFBZ0IsS0FBS0wsUUFBckIsRUFBaUMsQ0FBakMsRUFB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QUFHLENBQUN2SixHQUFELENBQTlDLHVDQUNrQ3lKLFFBQVEsQ0FBQ2pJLGNBRDNDLGdDQUMrRStILEdBQUcsQ0FBQ3ZKLEdBQUQsQ0FEbEY7QUFFSDtBQWJrQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBY3RDLEMsQ0FFRDtBQUNBOzs7QUFHZXdGLHFFQUFmIiwiZmlsZSI6Ii4vc3JjL3NsaWRpbmctcHV6emxlLWFsZ29yaXRobXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPcGVyYXRvciBwcmUtY29tcHV0YXRpb24sIGluLXBsYWNlIG1vZGlmaWNhdGlvbiBvZiBncmlkIHN0YXRlIGZvciBpZGEqIGJhc2VkIG9uXG4vLyBcIkltcGxlbWVudGluZyBGYXN0IEhldXJpc3RpYyBTZWFyY2ggQ29kZVwiXG4vLyBieSBFdGhhbiBCdXJucyBhbmQgTWF0dGhldyBIYXRlbSBhbmQgTWljaGFlbCBKLiBMZWlnaHRvbiBhbmQgV2hlZWxlciBSdW1sXG5cbi8vIExpbmVhciBjb25mbGljdCBoZXVyaXN0aWMgYmFzZWQgb25cbi8vIFwiQ3JpdGljaXppbmcgU29sdXRpb25zIHRvIFJlbGF4ZWQgTW9kZWxzIFlpZWxkcyBQb3dlcmZ1bCBBZG1pc3NpYmxlIEhldXJpc3RpY3NcIlxuLy8gYnkgT3RoYXIgSGFuc3NvbiBhbmQgQW5kcmV3IE1heWVyXG5cbi8vIFRPRE86IHdyaXRlIGZ1bmN0aW9uIHRvIHRpbWUgcGVyZm9ybWFuY2Ugb2YgZGlmZmVyZW50IGFsZytoZXVyaXN0aWMgY29tYm9zXG5cbi8vIFRPRE86IGZpeCBmcmVlemUgd2hlbiB0cnlpbmcgdG8gc29sdmUgc29tZSA1eDQgcHV6emxlcyAoYW5kIHByZXN1bWFibHkgdGhvc2UgbGFyZ2VyIHRoYW4gdGhhdClcbi8vIGl0ZXJhdGlvbiBsaW1pdCBzaG91bGQgd29yaywgYnV0IG5vdCB3b3JraW5nIGFuZC9vciBpdGVyYXRpb25zIHRha2luZyBzdWJzdGFudGlhbGx5IG1vcmUgbWVtb3J5ICsgbG9uZ2VyXG5cbi8vIFRPRE86IGNvbnNpZGVyIHN0b3JpbmcgcHJlY29tcHV0ZWQgdmFsdWVzIGluIGdsb2JhbCBvYmplY3Rcbi8vIHByb3M6IHNpbXBsZSwgbWFrZXMgYWxsIHNvbHZlKClzIG9uIHNhbWUgZGltZW5zaW9uIHB1enpsZSBmYXN0ZXJcbi8vIGNvbnM6IG1lbW9yeSBsZWFrIHRoYXQgY2FuIHBpbGUgdXAgaWYgdXNlciBzd2l0Y2hlcyBiZXR3ZWVuIG1hbnkgZGlmZmVyZW50IHB1enpsZSBkaW1lbnNpb25zXG4vLyBhbHRlcm5hdGl2ZTogcHJlY29tcHV0ZSBvbmNlIHBlciBQdXp6bGUsIGFuZCBtYWtlIHN1cmUgY2FsbGluZyBmdW5jdGlvbnMgcmVtZW1iZXIgdG8gcmV1c2Vcbi8vIFB1enpsZSBpbnN0YW5jZSB3aGVuIHNpemUgaXMgdGhlIHNhbWU7XG4vLyBjb25zOiBtZXNzaWVyLCBjYWxsaW5nIGZ1bmN0aW9ucyByZXF1aXJlZCB0byBtYWludGFpbiBsb2dpYyBmb3Igd2hpY2ggUHV6emxlIHRvIHVzZSxcbi8vIHB1enpsZSBvYmplY3QgbmVlZHMgbWV0aG9kIGZvciB1cGRhdGluZyBpdCwgY2FjaGUgY2FuJ3QgYmUgdXNlZCBiZXR3ZWVuIFB1enpsZSBvYmplY3RzXG4vLyBhbHRlcm5hdGl2ZTogc3RvcmUgY2FjaGUgZ2xvYmFsbHkvYXMgQ2xhc3MgcHJvcGVydHksIGJ1dCBzZXQgb2JqZWN0IHRvIG51bGwgd2l0aGluIFB1enpsZSBjb25zdHJ1Y3RvclxuLy8gd2hlbiBwdXp6bGUgZGltZW5zaW9ucyBjaGFuZ2Vcbi8vIHByb3M6IGZhaXJseSBzaW1wbGUsIGF2b2lkcyBtZW1vcnkgbGVhaywgZmFzdGVyIHNvbHZpbmcgb2Ygc2FtZSBzaXplIHB1enpsZVxuLy8gY29uczogYSBsaXR0bGUgbWVzc2llciwgY2FuJ3QgbWFuYWdlIG11bHRpcGxlIGluZGVwZW5kZW50IFB1enpsZXMgYXQgc2FtZSB0aW1lIHdpdGggZGlmZmVyZW50IHNpemVcbi8vIGV4OiAyIHB1enpsZXMgd2l0aCAyeDIsIDN4MyBkaW1lbnNpb25zLCBjYWNoZSB3b3VsZCBiZSByZXNldCBlYWNoIHRpbWUgb25lIHdhcyBzb2x2ZWRcbi8vIEFkZG9uOiBwcmVjb21wdXRlIHZhbHVlcyBpbiBzY3JpcHQuanMgYmVmb3JlIFwic29sdmVcIiBidXR0b24gaXMgY2xpY2tlZCwgdG8gYXZvaWQgbG9uZ2VyXG4vLyBzb2x2ZSB0aW1lIG9uIGZpcnN0IGNsaWNrLiBNYXkgbmVlZCB0byBiZSBhc3luYyB0byBiZSBpbnZpc2libGUgdG8gdXNlclxuaW1wb3J0IHJlZ2VuZXJhdG9yUnVudGltZSBmcm9tIFwicmVnZW5lcmF0b3ItcnVudGltZVwiXG5cbmltcG9ydCBGYXN0UHJpb3JpdHlRdWV1ZSBmcm9tICdmYXN0cHJpb3JpdHlxdWV1ZSdcbmltcG9ydCBuZGFycmF5IGZyb20gJ25kYXJyYXknXG5pbXBvcnQgQVZMVHJlZSBmcm9tICdhdmwnXG5cbmltcG9ydCB7cmFuZ2UsIHBlcm11dGF0aW9uR2VuZXJhdG9yfSBmcm9tICcuL21hdGgtdXRpbCdcblxuY29uc3QgUkVWRVJTRV9NT1ZFX01BUCA9IHtcbiAgICAncic6ICdsJyxcbiAgICAnbCc6ICdyJyxcbiAgICAnZCc6ICd1JyxcbiAgICAndSc6ICdkJ1xufVxuXG5cblxuLy8gVE9ETzogcmUtaW52ZXN0aWdhdGUgd2hldGhlciB1c2luZyB0eXBlZEFycmF5cyB3b3J0aCBpdCAocHJvYmFibHkgbm90LCBnaXZlbiBzbWFsbCBhcnJheXMgYW5kIGNhc3RpbmcpXG5cbi8vIFRPRE86IGNvbWJpbmUgbXVsdGlwbGUgaGV1cmlzdGljcyBtYXgobWFuaGF0dGFuLCBjb3JuZXIsIHBhdHRlcm4gZGF0YWJhc2UsIGxpbmVhciBjb25mbGljdCksIG9yIGFkZGl0aXZlIGRpc2pvaW50IHBhdHRlcm5zXG4vLyBUT0RPOiBpZiB1c2luZyBwYXR0ZXJuIGRhdGFiYXNlLCBjb25zaWRlciBlbmNvZGluZyBwYXR0ZXJuIG51bWJlcnMgaW50byBieXRlcyBhbmQgc3RvcmluZyBpbiBpbnRcbi8vIFRPRE86IG5vdGUgdGhhdCBwYXR0ZXJuIGRicyB3aWxsIG1ha2UgaXQgZGlmZmljdWx0IHRvIGFsbG93IG5vbi1zcXVhcmUgcHV6emxlcyB3aXRoIGRpbWVuc2lvbnMgPiA0XG5cbi8vIFRPRE86IGNvbnNpZGVyIHByZWNvbXB1dGluZyBMQyBmb3IgZWFjaCBwb3NzaWJsZSBzdGF0ZSB0byByZWR1Y2UgdXBkYXRlcyB0byB0YWJsZSBsb29rdXBzXG5cbi8vIE5PVEU6IG1ldGhvZHMgbm90IHN0YXRpYyB0byBzdXBwb3J0IHVzaW5nIGNhY2hlZCBNRCBkYXRhIHNwZWNpZmljIHRvIHB1enpsZVxuLy8gZ3JpZCBub3QgcGFydCBvZiBjb25zdHJ1Y3RvciBhcyBzaW5nbGUgaGV1cmlzdGljIHBhc3NlZCBiZXR3ZWVuIGFsbCBncmlkcyBpbiBhIGdpdmVuIFB1enpsZVxuY2xhc3MgTWFuaGF0dGFuSGV1cmlzdGljIHtcblxuICAgIGNvbnN0cnVjdG9yKG51bVJvd3MsIG51bUNvbHMpIHtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gbnVtUm93cztcbiAgICAgICAgdGhpcy5udW1Db2xzID0gbnVtQ29scztcbiAgICAgICAgdGhpcy5udW1UaWxlcyA9IG51bVJvd3MgKiBudW1Db2xzO1xuXG4gICAgICAgIHRoaXMuX3ByZWNvbXB1dGUoKTtcblxuICAgICAgICB0aGlzLm1vdmVOdW1iZXJNYXAgPSB7XG4gICAgICAgICAgICAnbCc6IDAsXG4gICAgICAgICAgICAncic6IDEsXG4gICAgICAgICAgICAndSc6IDIsXG4gICAgICAgICAgICAnZCc6IDNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IGNoYW5nZSBzbyBwcmVjb21wdXRlIGNhbGxlZCBvbmNlIGZvciBhbGwgcHV6emxlcyBvZiBzYW1lIHNpemVcbiAgICAvLyBzaW5jZSBubyBtYXR0ZXIgd2hhdCB1c2VyIHNldHRpbmdzIGFyZSBjYWxsZWQsIGFsbCBwb3NzaWJsZSBpbmRzIGFuZCBnb2FsSW5kcyBhY2NvdW50ZWQgZm9yXG4gICAgLy8gc3RvcmUgYXMgY2xhc3MgcHJvcGVydHksIGFuZCBjaGFuZ2UgaGV1cmlzdGljcyBiYWNrIHRvIHN0YXRpY1xuXG4gICAgLy8gVE9ETzogbWFrZSBfcHJlY29tcHV0ZSgpIHN0YXR1cyAoY2FjaGUgZXhpc3RhbmNlKSBhZmZlY3QgdXBkYXRlKCkgYW5kIGNhbGN1bGF0ZSgpXG4gICAgLy8gcmV0dXJucyBmYWxzZSBpZiBjb3VsZCBub3QgYmUgY29tcGxldGVkLCB0cnVlIG90aGVyd2lzZVxuICAgIF9wcmVjb21wdXRlKCkge1xuXG4gICAgICAgIC8vIHN0b3AgcHJlY29tcHV0aW5nIHdoZW4gbnVtVGlsZXMgPiAxMDAgKDUwLDAwMCBhcnJheSBlbnRyaWVzIGluIGNhY2hlKVxuICAgICAgICBpZiAodGhpcy5udW1UaWxlcyA+IDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gX21kLmdldChpLCBqKSA9IG1kIHZhbHVlIGF0IGluZCA9IGksIGdvYWxJbmQgPSBqXG4gICAgICAgIHRoaXMuX21kID0gbmRhcnJheShuZXcgVWludDE2QXJyYXkodGhpcy5udW1UaWxlcyAqKiAyKSwgW3RoaXMubnVtVGlsZXMsIHRoaXMubnVtVGlsZXNdKTtcbiAgICAgICAgLy8gX21kRGVsdGEuZ2V0KGksIGosIGspID0gY2hhbmdlIGluIE1EIHdoZW4gaW5kID0gaSwgZ29hbEluZCA9IGosIGFuZCBtb3ZlID0ga1xuICAgICAgICAvLyB3aGVyZSBtb3ZlID0gMCAtPiAnbCcsIDEgLT4gJ3InLCAyIC0+ICd1JyAzIC0+ICdkJ1xuICAgICAgICB0aGlzLl9tZERlbHRhID0gbmRhcnJheShuZXcgSW50OEFycmF5KDQgKiB0aGlzLm51bVRpbGVzICoqIDIpLCBbdGhpcy5udW1UaWxlcywgdGhpcy5udW1UaWxlcywgNF0pO1xuXG4gICAgICAgIC8vIGwsIHIsIHUsIGRcbiAgICAgICAgY29uc3QgbW92ZURlbHRhTWFwID0gSW50MTZBcnJheS5mcm9tKFstMSwgMSwgLXRoaXMubnVtQ29scywgdGhpcy5udW1Db2xzXSk7XG5cbiAgICAgICAgbGV0IGluZCwgZ29hbEluZDtcblxuICAgICAgICBpbmQgPSAwO1xuICAgICAgICBmb3IgKGxldCByb3cxID0gMDsgcm93MSA8IHRoaXMubnVtUm93czsgcm93MSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wxID0gMDsgY29sMSA8IHRoaXMubnVtQ29sczsgY29sMSsrKSB7XG4gICAgICAgICAgICAgICAgZ29hbEluZCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93MiA9IDA7IHJvdzIgPCB0aGlzLm51bVJvd3M7IHJvdzIrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wyID0gMDsgY29sMiA8IHRoaXMubnVtQ29sczsgY29sMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZC5zZXQoaW5kLCBnb2FsSW5kLCBNYXRoLmFicyhyb3cyIC0gcm93MSkgKyBNYXRoLmFicyhjb2wyIC0gY29sMSkpOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvYWxJbmQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluZCA9IDA7XG4gICAgICAgIGZvciAobGV0IHJvdzEgPSAwOyByb3cxIDwgdGhpcy5udW1Sb3dzOyByb3cxKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbDEgPSAwOyBjb2wxIDwgdGhpcy5udW1Db2xzOyBjb2wxKyspIHtcbiAgICAgICAgICAgICAgICBnb2FsSW5kID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cyID0gMDsgcm93MiA8IHRoaXMubnVtUm93czsgcm93MisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbDIgPSAwOyBjb2wyIDwgdGhpcy5udW1Db2xzOyBjb2wyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydE1EID0gdGhpcy5fbWQuZ2V0KGluZCwgZ29hbEluZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsLCByLCB1LCBkXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBtb3ZlID0gMDsgbW92ZSA8IDQ7IG1vdmUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRNRCA9IHRoaXMuX21kLmdldChpbmQgKyBtb3ZlRGVsdGFNYXBbbW92ZV0sIGdvYWxJbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21kRGVsdGEuc2V0KGluZCwgZ29hbEluZCwgbW92ZSwgZW5kTUQgLSBzdGFydE1EKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdvYWxJbmQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGhldXJpc3RpYyBkaXN0YW5jZSBmcm9tIGdvYWxcbiAgICBjYWxjdWxhdGUoZ3JpZCkge1xuICAgICAgICBsZXQgZGlzdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZC50aWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgIT09IGdyaWQuZW1wdHlQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCArPSB0aGlzLl9tZC5nZXQoaSwgZ3JpZC50aWxlc1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCArPSBncmlkLmdldFRpbGVEaXN0KGksIGdyaWQudGlsZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb25zaWRlciByZWZhY3RvcmluZyB0byBqdXN0IHVzZSBcImdyaWRcIiB0byBwcmV2ZW50IGNvbmZ1c2lvblxuXG4gICAgLy8gUmV0dXJucyB1cGRhdGVkIGhldXJpc3RpYyBkaXN0YW5jZSBmcm9tIGdvYWwgYWZ0ZXIgbW92ZVxuICAgIC8vIG5ld0dyaWQgPSBHcmlkIGFmdGVyIG1vdmUgKGRpc3RpbmN0IG9iamVjdCksIHdpdGggYWxsIHByb3BlcnRpZXMgdXBkYXRlZCBiZXNpZGVzIGhldXJpc3RpY1ZhbHVlXG4gICAgLy8gc3RhcnRJbmQgPSBpbmQgbW92ZWQgdGlsZSBzdGFydGVkIGluXG4gICAgLy8gZW5kSW5kID0gaW5kIG1vdmVkIHRpbGUgZW5kZWQgdXAgaW5cbiAgICAvLyBtb3ZlID0gc2luZ2xlLWxldHRlciBtb3ZlIHdpdGhpbiAnbC9yL3UvZCdcbiAgICAvLyBOT1RFOiBhc3N1bWVzIG5ld0dyaWQncyBoZXVyaXN0aWMgdmFsdWUgaXMgc2FtZSBhcyBvbGQgZ3JpZCAobm90IHlldCB1cGRhdGVkKVxuICAgIHVwZGF0ZShuZXdHcmlkLCBzdGFydEluZCwgZW5kSW5kLCBtb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVwZGF0ZURlbHRhKG5ld0dyaWQsIHN0YXJ0SW5kLCBlbmRJbmQsIG1vdmUpICsgbmV3R3JpZC5oZXVyaXN0aWNWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGNoYW5nZSBpbiBoZXVyaXN0aWMgZGlzdGFuY2UgZnJvbSBtb3ZlXG4gICAgLy8gbmV3R3JpZCA9IEdyaWQgYWZ0ZXIgbW92ZSAoZGlzdGluY3Qgb2JqZWN0KSwgd2l0aCBhbGwgcHJvcGVydGllcyB1cGRhdGVkIGJlc2lkZXMgaGV1cmlzdGljVmFsdWVcbiAgICAvLyBzdGFydEluZCA9IGluZCBtb3ZlZCB0aWxlIHN0YXJ0ZWQgaW5cbiAgICAvLyBlbmRJbmQgPSBpbmQgbW92ZWQgdGlsZSBlbmRlZCB1cCBpblxuICAgIC8vIG1vdmUgPSBzaW5nbGUtbGV0dGVyIG1vdmUgd2l0aGluICdsL3IvdS9kJ1xuICAgIGdldFVwZGF0ZURlbHRhKG5ld0dyaWQsIHN0YXJ0SW5kLCBlbmRJbmQsIG1vdmUpIHtcblxuICAgICAgICBpZiAodGhpcy5fbWREZWx0YSkge1xuICAgICAgICAgICAgLy8gZ2V0KG1vdmVkSW5kLCBnb2FsSW5kLCBtb3ZlKVxuICAgICAgICAgICAgLy8gKGdvYWxJbmQgaXMgdmFsdWUgb2YgdGlsZSBhdCBlbmRJbmQsIGFzIG5ld0dyaWQncyBlbmRJbmQgaXMgb2xkR3JpZCdzIHN0YXJ0SW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21kRGVsdGEuZ2V0KHN0YXJ0SW5kLCBuZXdHcmlkLnRpbGVzW2VuZEluZF0sIHRoaXMubW92ZU51bWJlck1hcFttb3ZlXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvYWxJbmQgPSBuZXdHcmlkLnRpbGVzW2VuZEluZF0sXG4gICAgICAgICAgICBnb2FsUm93ID0gbmV3R3JpZC5nZXRUaWxlUm93KGdvYWxJbmQpLFxuICAgICAgICAgICAgZ29hbENvbCA9IG5ld0dyaWQuZ2V0VGlsZUNvbChnb2FsSW5kKTtcblxuICAgICAgICBsZXQgc3RhcnRSb3cgPSBuZXdHcmlkLmdldFRpbGVSb3coc3RhcnRJbmQpLFxuICAgICAgICAgICAgc3RhcnRDb2wgPSBuZXdHcmlkLmdldFRpbGVDb2woc3RhcnRJbmQpO1xuXG4gICAgICAgIGxldCBlbmRSb3cgPSBuZXdHcmlkLmdldFRpbGVSb3coZW5kSW5kKSxcbiAgICAgICAgICAgIGVuZENvbCA9IG5ld0dyaWQuZ2V0VGlsZUNvbChlbmRJbmQpO1xuXG4gICAgICAgIHJldHVybiAoTWF0aC5hYnMoZ29hbFJvdyAtIGVuZFJvdykgKyBNYXRoLmFicyhnb2FsQ29sIC0gZW5kQ29sKSkgLVxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdvYWxSb3cgLSBzdGFydFJvdykgKyBNYXRoLmFicyhnb2FsQ29sIC0gc3RhcnRDb2wpO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgd2hldGhlciBoZXVyaXN0aWMgdmFsdWUgaW5kaWNhdGVzIGlmIHB1enpsZSBpcyBzb2x2ZWRcbiAgICBpc1NvbHZlZChoZXVyaXN0aWNWYWx1ZSkge1xuICAgICAgICByZXR1cm4gaGV1cmlzdGljVmFsdWUgPT09IDA7XG4gICAgfVxufVxuXG5cbi8vIE5PVEU6IG1ldGhvZHMgbm90IHN0YXRpYyB0byBzdXBwb3J0IHVzaW5nIGNhY2hlZCBNRCBkYXRhIHNwZWNpZmljIHRvIHB1enpsZVxuY2xhc3MgTGluZWFyQ29uZmxpY3RIZXVyaXN0aWMgZXh0ZW5kcyBNYW5oYXR0YW5IZXVyaXN0aWN7XG5cbiAgICBjb25zdHJ1Y3RvcihudW1Sb3dzLCBudW1Db2xzKSB7XG4gICAgICAgIHN1cGVyKG51bVJvd3MsIG51bUNvbHMpO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgZmFsc2UgaWYgY291bGQgbm90IGJlIGNvbXBsZXRlZCwgdHJ1ZSBvdGhlcndpc2VcbiAgICBfcHJlY29tcHV0ZSgpIHtcbiAgICAgICAgc3VwZXIuX3ByZWNvbXB1dGUoKTtcblxuICAgICAgICBsZXQgbiA9IE1hdGgubWF4KHRoaXMubnVtUm93cywgdGhpcy5udW1Db2xzKTtcblxuICAgICAgICAvLyBhdm9pZCBwcmVjb21wdXRhdGlvbiB3aGVuIG4gPiA4IG9yIHB1enpsZSBpcyAxRCAoY2FuIGp1c3QgdXNlIE1EKVxuICAgICAgICAvLyA5IGhhcyA5ODYsNDA5IHBlcm1zXG4gICAgICAgIC8vIDggaGFzIDE5LDE3Myw5NjAgc3BhY2VzIChlYWNoID4gMSBieXRlIGdpdmVuIFVpbnQ4QXJyYXkgYW5kIG92ZXJoZWFkKVxuICAgICAgICAvLyB3aGlsZSBwcmVjb21wdXRpbmcgc3RpbGwgZmVhc2libGUgZm9yIG4gPSA5LCBubyBwb2ludCBhcyA+IDFEIHB1enpsZXMgbm90XG4gICAgICAgIC8vIG9wdGltYWxseSBzb2x2YWJsZSBhdCB0aGF0IHBvaW50IGZvciBjdXJyZW50IHNvbHZlcnMgaGVyZVxuICAgICAgICAvLyBuZGFycmF5IGFsc28gYmVjb21lcyB0b28gbGFyZ2Ugd2hlbiBuID0gMTAgKHRocm9zIGVycm9yKVxuICAgICAgICBpZiAobiA+IDggfHwgdGhpcy5udW1Sb3dzID09PSAxIHx8IHRoaXMubnVtQ29scyA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTk9URTogbmRhcnJheSB1c2VkIGluc3RlYWQgb2YgbWFwLCBhcyBjb25zdGFudCB0b1N0cmluZygpIGNvbXB1dGF0aW9uYWxseSBjb3N0bGllclxuICAgICAgICAvLyB0aGFuIGluZGV4aW5nIGludG8gbmRhcnJheVxuICAgICAgICAvLyBjb25zOiBtdWNoIGxhcmdlciBzcGFjZSBjb25zdW1wdGlvbiAoc3VtIG9mIG5eayBmcm9tIGsgPSAxIHRvIG4pXG4gICAgICAgIC8vIGNvbnN1bWVzIDE5LDE3Myw5NjAgc3BhY2VzIChlYWNoID4gMSBieXRlIGdpdmVuIFVpbnQ4QXJyYXkgYW5kIG92ZXJoZWFkKSB3aGVuIG4gPSA4XG4gICAgICAgIHRoaXMuX2xjID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKGxldCBwZXJtU2l6ZSA9IDE7IHBlcm1TaXplIDw9IG47IHBlcm1TaXplKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xjW3Blcm1TaXplXSA9IG5kYXJyYXkoXG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkobiAqKiBwZXJtU2l6ZSksXG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkocGVybVNpemUpLmZpbGwobilcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHBlcm0gb2YgdGhpcy5fcGVybXV0YXRpb25IZWxwZXIobikpIHtcbiAgICAgICAgICAgIHRoaXMuX2xjW3Blcm0ubGVuZ3RoXS5zZXQoLi4ucGVybSwgdGhpcy5fY2FsY3VsYXRlKHBlcm0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgR2VuZXJhdG9yIG92ZXIgcG9zc2libGVcbiAgICAvLyBOT1RFOiAjIHBlcm11dGF0aW9ucyA9IHN1bSBvZiBuIHBlcm11dGUgayBmcm9tIGsgPSAxIHRvIG4gPSDijIplbiHiiJIx4oyLXG4gICAgKl9wZXJtdXRhdGlvbkhlbHBlcihuKSB7XG4gICAgICAgIC8vIHdoaWxlIEludDhBcnJheSBnb2VzIGZyb20gMCB0byAyNTUsIGFjY2VwdGFibGUgYXMgbWVtb3J5IHJlcXVpcmVtZW50c1xuICAgICAgICAvLyBiYWxsb29uIHdoZW4gbnVtUm93cy9udW1Db2xzID4gOFxuICAgICAgICBsZXQgYXJyID0gVWludDhBcnJheS5mcm9tKHJhbmdlKG4pKTtcbiAgICAgICAgZm9yIChsZXQgcGVybVNpemUgPSAxOyBwZXJtU2l6ZSA8PSBuOyBwZXJtU2l6ZSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwZXJtIG9mIHBlcm11dGF0aW9uR2VuZXJhdG9yKGFyciwgcGVybVNpemUpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgcGVybTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jYWxjdWxhdGUoYXJyKSB7XG4gICAgICAgIGxldCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZ29hbEluZCA9IGFycltpXTtcbiAgICAgICAgICAgIG1hcC5zZXQoaSwge2dvYWxJbmQsIGNvbmZsaWN0czogbmV3IFNldCgpfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlRm9yTWFwKG1hcCk7XG4gICAgfVxuICAgIC8vIFRPRE86IGNvbnNpZGVyIHNlcGFyYXRpbmcgbGMgY29uZGl0aW9uIGNoZWNrIGludG8gbmV3IGZ1bmN0aW9uIGZvciBwb3NzaWJseSBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAvLyAobGVzcyBcImlmXCIgY2hlY2tzKVxuXG4gICAgLy8gY2FsY3VsYXRlcyBsaW5lYXIgY29uZmxpY3Qgb2Ygc3BlY2lmaWVkIGdyaWRcbiAgICAvLyBvcHRpb25hbCBzdGFydC9lbmQgcGFyYW1zIGFsbG93IHNwZWNpZnlpbmcgc2VjdGlvbiBvZiBncmlkIHRvIGNhbGN1bGF0ZSBjb25mbGljdCBoZXVyaXN0aWMgZm9yXG4gICAgLy8gcmVjdGFuZ3VsYXIgc2VjdGlvbiBvZiBncmlkLCB3aGVyZSBzdGFydCBpcyBpbmNsdXNpdmUgYW5kIGVuZCBpZiBleGNsdXNpdmVcbiAgICAvLyBjYWxjTUQgZGV0ZXJtaW5lcyBpZiBjYWxjdWxhdGUoKSBpbmNsdWRlcyBNYW5oYXR0YW4gRGlzdGFuY2UgaW4gaGV1cmlzdGljIGNhbGN1bGF0aW9uXG4gICAgLy8gTk9URTogc2luY2UgbGluZWFyIGNvbmZsaWN0ICsgTUQgYWx3YXlzIGFkbWlzc2libGUgYW5kIGF0IGxlYXN0IGFzIGdvb2QsIG9ubHkgdXNlXG4gICAgLy8gY2FsY01EID0gZmFsc2UgZm9yIHRlc3Rpbmcgb3IgaWYgeW91IHBsYW4gb24gY2FsY3VsYXRpbmcgTUQgaW4gYSBkaWZmZXJlbnQgd2F5XG4gICAgLy8gZXg6IGNhbGN1bGF0ZShncmlkLCAwLCAzLCAxLCAyKSBjYWxjdWxhdGVzIGhldXJpc3RpYyBmb3IgMyB0aWxlIHRhbGwgdmVydGljYWwgY2h1bmtcbiAgICAvLyBpbiBjb2xbMV0gZnJvbSByb3dbMC0+Ml1cbiAgICAvLyBIZXVyaXN0aWMgZXhwbGFuYXRpb246XG4gICAgLy8gbGluZWFyIGNvbmZsaWN0ID0gMiB0aWxlcyBpbiB0aGUgc2FtZSBnb2FsIHJvdy9jb2wgYnV0IGhhdmUgaW52ZXJzaW9uIHJlbGF0aW9uc2hpcC5cbiAgICAvLyBob3Jpem9udGFsOiAoYSBpcyB0byByaWdodCBvZiBiIGJ1dCBhJ3MgZ29hbCBpcyB0byBsZWZ0IG9mIGIncyBnb2FsKVxuICAgIC8vIHZlcnRpY2FsOiBzYW1lIGJ1dCB3aXRoIGJvdHRvbSBhbmQgdG9wIGluc3RlYWQgb2YgcmlnaHQgYW5kIGxlZnRcbiAgICAvLyBUbyByZWFjaCBnb2FsIHBvc2l0aW9ucywgb25lIG9mIHRoZSB0aWxlcyBpbiB0aGUgcGFpciBoYXMgdG8gbW92ZSBvdXQgb2YgdGhlIHdheVxuICAgIC8vIGZvciB0aGUgb3RoZXIgdGlsZSB0byByZWFjaCB0aGVpciBnb2FsLiBUaGUgbW92ZWQgdGlsZSBoYXMgdG8gbW92ZSBiYWNrIGludG8gdGhlaXJcbiAgICAvLyBnb2FsIHJvdy9jb2wgdG8gcmVhY2ggdGhlaXIgZ29hbHMuXG4gICAgLy9cbiAgICAvLyBMaW5lYXIgY29uZmxpY3QgaXMgY2FsY3VsYXRlZCBvbiBldmVyeSByb3cgYW5kIGNvbHVtbiwgYW5kIGNhbiBiZSBjb21iaW5lZCB3aXRoXG4gICAgLy8gbWFuaGF0dGFuIGRpc3RhbmNlIGhldXJpc3RpYyB0byBtYWtlIGJldHRlciBhZG1pc3NpYmxlIGhldXJpc3RpYyxcbiAgICAvLyBhcyBtYW5oYXR0YW4gZGlzdGFuY2UgaGV1cmlzdGljIGRvZXNuJ3QgYWNjb3VudCBmb3IgbW92aW5nIHRpbGVzIG91dCBvZiB0aGUgd2F5XG4gICAgLy8gYW5kIGxpbmVhciBjb25mbGN0IGRvZXNuJ3QgYWNjb3VudCBmb3IgbW92aW5nIHRvIHRoZSBjb3JyZWN0IHRpbGUgcG9zaXRpb24gXG4gICAgLy9cbiAgICAvLyBXQVJOSU5HOiBZb3UgY2FuJ3QganVzdCBhZGQgMiB0byB0aGUgaGV1cmlzdGljIHZhbHVlIGZvciBlYWNoIGludmVyc2lvbiBmb3VuZCxcbiAgICAvLyBhcyBtb3Zpbmcgb25lIHRpbGUgb3V0IG9mIHRoZSB3YXkgY2FuIGFsbG93IDIgdGlsZXMgaXQgY29uZmxpY3RzIHdpdGggdG8gbW92ZSBpbnRvIHRoZWlyIGdvYWxzXG4gICAgLy8gZXg6IFszLCAxLCAyXSBoYXMgZ29hbCBwb3NpdGlvbnMgb2YgWzEsIDIsIDNdXG4gICAgLy8gdG8gcmVhY2ggdGhlIGdvYWwsIG1vdmUgMyBkb3duIGFuZCBzbGlkZSAxIGFuZCAyIG92ZXIsIGFuZCB0aGVuIG1vdmUgMyB0byB0aGUgZ29hbFxuICAgIC8vIHdoaWxlIHRoZXJlIGFyZSAyIGludmVyc2lvbnMgKDMsIDEpIGFuZCAoMywgMiksIG1vdmluZyAzIG91dCBvZiB0aGUgd2F5IGZvciAxIG1lYW5zXG4gICAgLy8gdGhhdCBpdCBpcyBvdXQgb2YgdGhlIHdheSBmb3IgMiBhcyB3ZWxsLlxuICAgIC8vIElmIHlvdSBhZGRlZCAyIGZvciBlYWNoIGludmVyc2lvbiwgaGV1cmlzdGljID0gTEMgPSAoMiArIDIpICsgTUQgPSAoMiArIDEgKyAxKSA9IDhcbiAgICAvLyB3aGVuIHRoZSBvcHRpbWFsIHNvbHV0aW9uIG9ubHkgdGFrZXMgNiBtb3ZlcyAoXCIzXCIgZG93biwgXCIxXCIgbGVmdCwgXCIyXCIgbGVmdCwgXCIzXCIgcmlnaHQgeDIsIFwiM1wiIHVwKVxuICAgIGNhbGN1bGF0ZShncmlkKSB7XG4gICAgICAgIGxldCBoZXVyaXN0aWNWYWx1ZSA9IDA7XG5cbiAgICAgICAgLy8gY2FuZGlkYXRlVGlsZXMuZ2V0KGkpID0gbWFwIG9mIHRpbGVzIG9mIHJvdy9jb2wgaSB0aGF0IGFyZSBpbiB0aGVpciBnb2FsIHJvdy9jb2xcbiAgICAgICAgLy8gbWFwID0ge2luZDoge2dvYWxJbmQsIGNvbmZsaWN0c319XG4gICAgICAgIC8vIC0gaW5kID0gY3VycmVudCBpbmRleCBpbiBmbGF0dGVuZWQgcHV6emxlIGFycmF5XG4gICAgICAgIC8vIC0gZ29hbEluZCA9IHZhbHVlIGF0IGluZCA9IGluZGV4IG9mIHRoZSB0aWxlIGluIHRoZSBnb2FsIHB1enpsZVxuICAgICAgICAvLyAtIGNvbmZsaWN0cyBpcyBhIHNldCBvZiBjb25mbGljdGluZyBpbmRpY2VzIChpbml0aWFsbHkgZW1wdHkpXG4gICAgICAgIC8vIE5PVEU6IGNvbHMgYWNjZXNzZWQgYXQga2V5ID0gY29sdW1uIGluZGV4ICsgZ3JpZC5udW1Sb3dzXG4gICAgICAgIC8vIChmaXJzdCBncmlkLm51bVJvd3MgZW50cmllcyBhcmUgZm9yIHJvd3MsIG5leHQgZ3JpZC5udW1Db2xzIGVudHJpZXMgZm9yIGNvbHVtbnMpXG4gICAgICAgIGxldCBjYW5kaWRhdGVUaWxlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvLyBkZXRlcm1pbmVzIHdoaWNoIHRpbGVzIGFyZSBpbiB0aGVpciBnb2FsIHJvdyBhbmQvb3IgY29sdW1uXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMubnVtUm93czsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMubnVtQ29sczsgY29sKyspIHtcblxuICAgICAgICAgICAgICAgIGxldCBpbmQgPSBncmlkLmdldEluZGV4KHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICBsZXQgZ29hbEluZCA9IGdyaWQudGlsZXNbaW5kXSxcbiAgICAgICAgICAgICAgICAgICAgZ29hbFJvdyA9IGdyaWQuZ2V0VGlsZVJvdyhnb2FsSW5kKSxcbiAgICAgICAgICAgICAgICAgICAgZ29hbENvbCA9IGdyaWQuZ2V0VGlsZUNvbChnb2FsSW5kKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmQgIT09IGdyaWQuZW1wdHlQb3MpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbWFuaGF0dGFuIGRpc3RhbmNlIHRvIGhldXJpc3RpYyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhldXJpc3RpY1ZhbHVlICs9IHRoaXMuX21kLmdldChpbmQsIGdvYWxJbmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV1cmlzdGljVmFsdWUgKz0gTWF0aC5hYnMocm93IC0gZ29hbFJvdylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIE1hdGguYWJzKGNvbCAtIGdvYWxDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHNpbmdsZSB0aWxlIGNhbiBiZSBjYW5kaWRhdGUgZm9yIGJvdGggcm93IGFuZCBjb2wgY29uZmxpY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGlsZSBjYW4gYmUgcGFydCBvZiBjb25mbGljdCBldmVuIHdoZW4gaXQncyBpbiBpdHMgZ29hbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZC5nZXRUaWxlUm93KGdvYWxJbmQpID09PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlVGlsZXMuaGFzKHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMuc2V0KHJvdywgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVUaWxlcy5nZXQocm93KS5wdXNoKGdvYWxDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVRpbGVzLmhhcyhyb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVRpbGVzLnNldChyb3csIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVRpbGVzLmdldChyb3cpLnNldChpbmQsIHtnb2FsSW5kLCBjb25mbGljdHM6IG5ldyBTZXQoKX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkLmdldFRpbGVDb2woZ29hbEluZCkgPT09IGNvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IGdyaWQubnVtUm93cyArIGNvbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlVGlsZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMuc2V0KGtleSwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVUaWxlcy5nZXQoa2V5KS5wdXNoKGdvYWxSb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVRpbGVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVRpbGVzLnNldChrZXksIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVRpbGVzLmdldChrZXkpLnNldChpbmQsIHtnb2FsSW5kLCBjb25mbGljdHM6IG5ldyBTZXQoKX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgbWFraW5nIGN1c3RvbSBmdW5jdGlvbiBmb3IgdXBkYXRlIHNpbmNlIG9ubHkgbmVlZCB0byBleGFtaW5lXG4gICAgICAgIC8vIGlmIHRpbGUgaW4gMSAoa25vd24pIGdvYWwgZGltZW5zaW9uIGFuZCBtYXAgYWxzbyB1bm5lY2Vzc2FyeVxuICAgICAgICAvLyBtYXliZSBoZWxwZXIgZnVuY3Rpb25zIGZvciBwcm9jZXNzaW5nIGVhY2ggcm93L2NvbD9cbiAgICAgICAgLy8gZG9uJ3QgdXNlIGhlbHBlcnMgZm9yIHJlZ3VsYXIgY2FsY3VsYXRlKCkgdGhvdWdoIChwcm9iYWJseSBsZXNzIGVmZmljaWVudFxuICAgICAgICAvLyBzaW5jZSBlYWNoIHRpbGUgd291bGQgYmUgaXRlcmF0ZWQgb3ZlciB0d2ljZSAoc2VwYXJhdGVseSBmb3Igcm93IGFuZCBjb2wpKVxuICAgICAgICBpZiAodGhpcy5fbGMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHVzZSB2YWx1ZXMgc2luY2Uga2V5cyB1bm5lY2Vzc2FyeSBub3dcbiAgICAgICAgICAgIGZvciAobGV0IFssIGFycl0gb2YgY2FuZGlkYXRlVGlsZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaGV1cmlzdGljVmFsdWUgKz0gdGhpcy5fbGNbYXJyLmxlbmd0aF0uZ2V0KC4uLmFycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByb3cvZ3JpZC5udW1Sb3dzICsgY29sIG5vIGxvbmdlciByZWxldmFudCBhbmQgY2FuIGJlIGRpc2NhcmRlZCBcbiAgICAgICAgICAgIGZvciAobGV0IFssIG1hcF0gb2YgY2FuZGlkYXRlVGlsZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaGV1cmlzdGljVmFsdWUgKz0gdGhpcy5fY2FsY3VsYXRlRm9yTWFwKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGV1cmlzdGljVmFsdWU7XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZUZvck1hcChtYXApIHtcbiAgICAgICAgaWYgKG1hcC5zaXplIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaGV1cmlzdGljVmFsdWUgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IFtpbmQxLCB7Z29hbEluZDogZ29hbEluZDEsIGNvbmZsaWN0czogY29uZmxpY3RzMX1dIG9mIG1hcCkge1xuICAgICAgICAgICAgZm9yIChsZXQgW2luZDIsIHtnb2FsSW5kOiBnb2FsSW5kMiwgY29uZmxpY3RzOiBjb25mbGljdHMyfV0gb2YgbWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZDIgPiBpbmQxICYmIGdvYWxJbmQyIDwgZ29hbEluZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLmdldChpbmQxKS5jb25mbGljdHMuYWRkKGluZDIpO1xuICAgICAgICAgICAgICAgICAgICBtYXAuZ2V0KGluZDIpLmNvbmZsaWN0cy5hZGQoaW5kMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbmZsaWN0VHJlZSA9IG5ldyBBVkxUcmVlKChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYS5pbmQgPT09IGIuaW5kKSByZXR1cm4gMDtcblxuICAgICAgICAgICAgbGV0IGRpZmYgPSBhLmNvbmZsaWN0cy5zaXplIC0gYi5jb25mbGljdHMuc2l6ZTtcblxuICAgICAgICAgICAgICAgIC8vIHNvcnRzIGJ5IGluZCBhc2NlbmRpbmcgaWYgY29uZmxpY3RzIGVxdWFsXG4gICAgICAgICAgICAgICAgLy8gbmVjZXNzYXJ5IHRvIGlkZW50aWZ5IG9iamVjdCBieSBpbmQgaW4gdHJlZSwgYXMgbm9kZSB3aXRoIHNhbWUgIyBjb25mbGljdHNcbiAgICAgICAgICAgICAgICAvLyBhcyBkZXNpcmVkIG5vZGUgY2FuIGFwcGVhciBiZWZvcmUgZGVzaXJlZCBub2RlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPT09IDAgPyBhLmluZCAtIGIuaW5kIDogZGlmZjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAobGV0IFtpbmQsIHtnb2FsSW5kLCBjb25mbGljdHN9XSBvZiBtYXApIHtcblxuICAgICAgICAgICAgaWYgKGNvbmZsaWN0cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbmZsaWN0VHJlZS5pbnNlcnQoe2NvbmZsaWN0cywgaW5kfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGlsZTtcblxuICAgICAgICB3aGlsZSAoY29uZmxpY3RUcmVlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aWxlID0gY29uZmxpY3RUcmVlLm1heCgpO1xuICAgICAgICAgICAgLy8gTk9URTogbGlicmFyeSBoYXMgbm8gb3B0aW9uIGZvciBmaW5kaW5nIGFuZCByZW1vdmluZyBsYXJnZXN0IGl0ZW0gaW4gb25lIHN0ZXBcbiAgICAgICAgICAgIC8vIGNvdWxkIHVzZSBwb3AoKSB3b3JrYXJvdW5kIHdpdGggb3Bwb3NpdGUgY29tcGFyYXRvciwgYnV0IHBvcCBhbHNvIGNhbGxzXG4gICAgICAgICAgICAvLyByZW1vdmUoKSBhZnRlciBmaW5kaW5nIG1pbiBpbiBjdXJyZW50IHZlcnNpb24gKDEuNC40KVxuICAgICAgICAgICAgY29uZmxpY3RUcmVlLnJlbW92ZSh0aWxlKTtcblxuICAgICAgICAgICAgLy8gaGV1cmlzdGljICs9IDIgZm9yIGVhY2ggdGlsZSB0aGF0IG11c3QgYmUgcmVtb3ZlZCBiZWZvcmUgdGhlcmUgYXJlIG5vIGNvbmZsaWN0c1xuICAgICAgICAgICAgaGV1cmlzdGljVmFsdWUgKz0gMjtcblxuICAgICAgICAgICAgZm9yIChsZXQgY29uZmxpY3Qgb2YgdGlsZS5jb25mbGljdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGNvbmZsaWN0cyBvZiBjb25mbGljdGluZyB0aWxlXG4gICAgICAgICAgICAgICAgLy8gZXg6IGEuY29uZmxpY3RzID0gW2IsY10sIGIuY29uZmxpY3RzID0gW2FdLCBjb3JyQ29uZmxpY3RzIG9mIGEgPSAoU2V0KSBbYV1cbiAgICAgICAgICAgICAgICBsZXQgY29yckNvbmZsaWN0cyA9IG1hcC5nZXQoY29uZmxpY3QpLmNvbmZsaWN0cztcblxuICAgICAgICAgICAgICAgIGxldCBjb3JyT2JqID0ge2NvbmZsaWN0czogY29yckNvbmZsaWN0cywgaW5kOiBjb25mbGljdH07XG5cbiAgICAgICAgICAgICAgICBjb25mbGljdFRyZWUucmVtb3ZlKGNvcnJPYmopO1xuXG4gICAgICAgICAgICAgICAgLy8gTk9URTogdHJlZSB1c2VzIHJlZmVyZW5jZSB0byBzYW1lIGNvbmZsaWN0cyBvYmplY3QsIHNvIGNvbmZsaWN0cyB1cGRhdGVkIHRoZXJlIGFzIHdlbGxcbiAgICAgICAgICAgICAgICBjb3JyQ29uZmxpY3RzLmRlbGV0ZSh0aWxlLmluZCk7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGFuZCBpbnNlcnRlZCB0byByZW9yZGVyIGJhc2VkIG9uIG5ldyBudW1iZXIgb2YgY29uZmxpY3RzXG4gICAgICAgICAgICAgICAgaWYgKGNvcnJDb25mbGljdHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RUcmVlLmluc2VydChjb3JyT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhldXJpc3RpY1ZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZXMgTEMgZm9yIGdpdmVuIHJvdyBpbmRleFxuICAgIC8vIE5PVEU6IGRvZXNuJ3QgaW5jb3Jwb3JhdGUgTURcbiAgICBfY2FsY3VsYXRlRm9yUm93KGdyaWQsIHJvdykge1xuICAgICAgICBsZXQgY2FuZGlkYXRlVGlsZXMgPSB0aGlzLl9sYyA/IFtdIDogbmV3IE1hcCgpO1xuXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMubnVtQ29sczsgY29sKyspIHtcbiAgICAgICAgICAgIGxldCBpbmQgPSBjb2wgKyB0aGlzLm51bUNvbHMgKiByb3c7XG5cbiAgICAgICAgICAgIGlmIChpbmQgIT09IGdyaWQuZW1wdHlQb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZ29hbEluZCA9IGdyaWQudGlsZXNbaW5kXSxcbiAgICAgICAgICAgICAgICAgICAgZ29hbFJvdyA9IGdyaWQuZ2V0VGlsZVJvdyhnb2FsSW5kKSxcbiAgICAgICAgICAgICAgICAgICAgZ29hbENvbCA9IGdyaWQuZ2V0VGlsZUNvbChnb2FsSW5kKTtcbiAgICAgICAgICAgICAgICBpZiAocm93ID09PSBnb2FsUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMucHVzaChnb2FsQ29sKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVRpbGVzLnNldChjb2wsIHtnb2FsSW5kOiBnb2FsQ29sLCBjb25mbGljdHM6IG5ldyBTZXQoKX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xjKSB7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlVGlsZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xjW2NhbmRpZGF0ZVRpbGVzLmxlbmd0aF0uZ2V0KC4uLmNhbmRpZGF0ZVRpbGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVGb3JNYXAoY2FuZGlkYXRlVGlsZXMpO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZXMgTEMgZm9yIGdpdmVuIGNvbHVtbiBpbmRleFxuICAgIC8vIE5PVEU6IGRvZXNuJ3QgaW5jb3Jwb3JhdGUgTURcbiAgICBfY2FsY3VsYXRlRm9yQ29sKGdyaWQsIGNvbCkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlVGlsZXMgPSB0aGlzLl9sYyA/IFtdIDogbmV3IE1hcCgpO1xuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMubnVtUm93czsgcm93KyspIHtcbiAgICAgICAgICAgIGxldCBpbmQgPSBjb2wgKyB0aGlzLm51bUNvbHMgKiByb3c7XG5cbiAgICAgICAgICAgIGlmIChpbmQgIT09IGdyaWQuZW1wdHlQb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZ29hbEluZCA9IGdyaWQudGlsZXNbaW5kXSxcbiAgICAgICAgICAgICAgICAgICAgZ29hbFJvdyA9IGdyaWQuZ2V0VGlsZVJvdyhnb2FsSW5kKSxcbiAgICAgICAgICAgICAgICAgICAgZ29hbENvbCA9IGdyaWQuZ2V0VGlsZUNvbChnb2FsSW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sID09PSBnb2FsQ29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVGlsZXMucHVzaChnb2FsUm93KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVRpbGVzLnNldChyb3csIHtnb2FsSW5kOiBnb2FsUm93LCBjb25mbGljdHM6IG5ldyBTZXQoKX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xjKSB7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlVGlsZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xjW2NhbmRpZGF0ZVRpbGVzLmxlbmd0aF0uZ2V0KC4uLmNhbmRpZGF0ZVRpbGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVGb3JNYXAoY2FuZGlkYXRlVGlsZXMpO1xuICAgIH1cblxuICAgIHVwZGF0ZShuZXdHcmlkLCBzdGFydEluZCwgZW5kSW5kLCBtb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVwZGF0ZURlbHRhKG5ld0dyaWQsIHN0YXJ0SW5kLCBlbmRJbmQsIG1vdmUpICsgbmV3R3JpZC5oZXVyaXN0aWNWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb25zaWRlciBtYWludGFpbmluZyBzZXBhcmF0ZSB1cGRhdGUgZnVuY3Rpb25zIGZvciBjbG9uZSBhbmQgbm8gY2xvbmVcbiAgICAvLyBjYW4gYmUgY2FsbGVkIGJ5IGNsb25lQW5kQXBwbHlNb3ZlIGFuZCBhcHBseU1vdmUgcmVzcGVjdGl2ZWx5XG5cbiAgICAvLyBUT0RPOiBjb25zaWRlciBzcGxpdHRpbmcgdXBkYXRlIGludG8gMiBwYXJ0cyBzbyBuZXdHcmlkIGlzbid0IHN3aXRjaGVkIGJhY2sgYW5kIGZvcnRoIGluIElEQSpcbiAgICAvLyAob3IgY3JlYXRlIGhlbHBlciB0aGF0IGFsc28gdGFrZXMgaW4gc3RhcnQgYW5kIGVuZCBsb2NhdGlvbnMgb2YgdGlsZSBhcyB3ZWxsIGFzIG5ld0dyaWRcbiAgICAvLyBmb3IgdXNlIGluIElEQSopXG5cbiAgICAvLyBUT0RPOiBoYXZlIHVwZGF0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdXBkYXRlZCBncmlkIGZvciB1c2UgaW4gaWRhKlxuICAgIC8vIFRPRE86IHNlZSBpZiBjYWxjdWxhdGUoKSBuZWVkcyBhbnl0aGluZyBjaGFuZ2VkIGJlc2lkZXMgZW1wdHlQb3MgYW5kIHRpbGUgc3dhcFxuXG4gICAgLy8gcmV0dXJucyBjaGFuZ2UgaW4gaGV1cmlzdGljIGRpc3RhbmNlIGZyb20gbW92ZVxuICAgIC8vIG5ld0dyaWQgPSBHcmlkIGFmdGVyIG1vdmUgKGRpc3RpbmN0IG9iamVjdCksIHdpdGggYWxsIHByb3BlcnRpZXMgdXBkYXRlZCBiZXNpZGVzIGhldXJpc3RpY1ZhbHVlXG4gICAgLy8gc3RhcnRJbmQgPSBpbmQgbW92ZWQgdGlsZSBzdGFydGVkIGluXG4gICAgLy8gZW5kSW5kID0gaW5kIG1vdmVkIHRpbGUgZW5kZWQgdXAgaW5cbiAgICAvLyBtb3ZlID0gc2luZ2xlLWxldHRlciBtb3ZlIHdpdGhpbiAnbC9yL3UvZCdcbiAgICBnZXRVcGRhdGVEZWx0YShuZXdHcmlkLCBzdGFydEluZCwgZW5kSW5kLCBtb3ZlKSB7XG5cbiAgICAgICAgbGV0IHN0YXJ0Um93ID0gbmV3R3JpZC5nZXRUaWxlUm93KHN0YXJ0SW5kKSxcbiAgICAgICAgICAgIHN0YXJ0Q29sID0gbmV3R3JpZC5nZXRUaWxlQ29sKHN0YXJ0SW5kKTtcblxuICAgICAgICBsZXQgc3RhcnRWYWwgPSAwLFxuICAgICAgICAgICAgZW5kVmFsID0gMDtcblxuICAgICAgICBsZXQgZnVuYztcbiAgICAgICAgbGV0IGluZHM7XG5cbiAgICAgICAgc3dpdGNoIChtb3ZlKSB7XG4gICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICBmdW5jID0gdGhpcy5fY2FsY3VsYXRlRm9yQ29sO1xuICAgICAgICAgICAgICAgIGluZHMgPSBbc3RhcnRDb2wsIHN0YXJ0Q29sIC0gMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICBmdW5jID0gdGhpcy5fY2FsY3VsYXRlRm9yQ29sO1xuICAgICAgICAgICAgICAgIGluZHMgPSBbc3RhcnRDb2wsIHN0YXJ0Q29sICsgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICBmdW5jID0gdGhpcy5fY2FsY3VsYXRlRm9yUm93O1xuICAgICAgICAgICAgICAgIGluZHMgPSBbc3RhcnRSb3csIHN0YXJ0Um93IC0gMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICBmdW5jID0gdGhpcy5fY2FsY3VsYXRlRm9yUm93O1xuICAgICAgICAgICAgICAgIGluZHMgPSBbc3RhcnRSb3csIHN0YXJ0Um93ICsgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYW5oYXR0YW4gZGlzdGFuY2Ugbm90IGNhbGN1bGF0ZWQgaW4gZnVuYyBhcyBvbmx5IG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgLy8gZm9yIHNpbmdsZSB0aWxlIG1vdmVkIChtb3JlIGVmZmljaWVudCB0byBjYWxjdWxhdGUgc2VwYXJhdGVseSlcbiAgICAgICAgZW5kVmFsICs9IGZ1bmMuY2FsbCh0aGlzLCBuZXdHcmlkLCBpbmRzWzBdKTtcbiAgICAgICAgZW5kVmFsICs9IGZ1bmMuY2FsbCh0aGlzLCBuZXdHcmlkLCBpbmRzWzFdKTtcblxuICAgICAgICAvLyByZXR1cm5zIGdyaWQgcGFydGlhbGx5IHRvIHByZS1tb3ZlIHN0YXRlIHRvIGNhbGN1bGF0ZSBMQyBmb3IgcmVsZXZhbnQgY29scyBwcmUtbW92ZVxuICAgICAgICBuZXdHcmlkLnN3YXAoc3RhcnRJbmQsIGVuZEluZCk7XG4gICAgICAgIG5ld0dyaWQuZW1wdHlQb3MgPSBlbmRJbmQ7XG5cbiAgICAgICAgc3RhcnRWYWwgKz0gZnVuYy5jYWxsKHRoaXMsIG5ld0dyaWQsIGluZHNbMF0pO1xuICAgICAgICBzdGFydFZhbCArPSBmdW5jLmNhbGwodGhpcywgbmV3R3JpZCwgaW5kc1sxXSk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGdyaWQgdG8gb3JpZ2luYWwgc3RhdGVcbiAgICAgICAgbmV3R3JpZC5zd2FwKHN0YXJ0SW5kLCBlbmRJbmQpO1xuICAgICAgICBuZXdHcmlkLmVtcHR5UG9zID0gc3RhcnRJbmQ7XG5cbiAgICAgICAgcmV0dXJuIGVuZFZhbCAtIHN0YXJ0VmFsICsgc3VwZXIuZ2V0VXBkYXRlRGVsdGEobmV3R3JpZCwgc3RhcnRJbmQsIGVuZEluZCwgbW92ZSk7XG4gICAgfVxuXG5cbiAgICAvLyByZXR1cm5zIHdoZXRoZXIgaGV1cmlzdGljIHZhbHVlIGluZGljYXRlcyBpZiBwdXp6bGUgaXMgc29sdmVkXG4gICAgaXNTb2x2ZWQoaGV1cmlzdGljVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGhldXJpc3RpY1ZhbHVlID09PSAwO1xuICAgIH1cbn1cblxuLy8gTk9URTogc2VwYXJhdGUgZnJvbSBwdXp6bGUtZ3JhcGhpYydzIFB1enpsZXMgdG8gZWFzZSB0ZXN0aW5nIGFuZCByZWR1Y2UgbWVtb3J5IGNvc3QgaW4gQSpcbi8vIFRPRE86IGNvbnNpZGVyIGNoYW5naW5nIG51bUNvbHMvbnVtUm93cyB0byBudW1Sb3dzLCBudW1Db2xzIGZvciBjbGFyaXR5ICsgY29uc2lzdGVuY3lcbmNsYXNzIFB1enpsZSB7XG5cbiAgICAvLyBUT0RPOiBzZXQgZGVmYXVsdCBzb2x2ZXIgdG8gbnVsbCBhZnRlciBkb25lIHRlc3Rpbmcgc28gc29sdmVyIGFkYXB0aXZlIHRvIHB1enpsZSBzaXplXG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGVzIG5ldyBQdXp6bGUgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gbnVtUm93cyAjIHJvd3MgaW4gZ3JpZFxuICAgICAqIEBwYXJhbSBudW1Db2xzICMgY29sdW1ucyBpbiBncmlkXG4gICAgICogQHBhcmFtIHRpbGVzIGZsYXR0ZW5lZCBhcnJheSBvZiB0aWxlIGlkcyBjb3JyZXNwb25kaW5nIHRvIHRoZWlyIGxvY2F0aW9ucyBpbiB0aGUgdW5zb2x2ZWQgcHV6emxlXG4gICAgICogKHdoZXJlIGlkcyA9IHRpbGUgcG9zaXRpb25zIGluIHRoZSBzb2x2ZWQgcHV6emxlIGxlZnQgdG8gcmlnaHQsIHRvcCB0byBib3R0b20sIDAgaW5kZXhlZClcbiAgICAgKiBAcGFyYW0gZW1wdHlQb3MgcG9zaXRpb24gb2YgZW1wdHkgdGlsZSBpbiBncmlkXG4gICAgICogQHBhcmFtIGhldXJpc3RpYyBoZXVyaXN0aWMgdXNlZCB0byBkZXRlcm1pbmUgaG93IGZhciBncmlkIGlzIGZyb20gZ29hbCBzdGF0ZS4gRGVmYXVsdCBoZXVyaXN0aWMgaXMgTWFuaGF0dGFuIERpc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobnVtUm93cywgbnVtQ29scywgdGlsZXMsIGVtcHR5UG9zLCBoZXVyaXN0aWMgPSBMaW5lYXJDb25mbGljdEhldXJpc3RpYywgc29sdmVyPSdJREEqJykge1xuICAgICAgICB0aGlzLm51bVJvd3MgPSBudW1Sb3dzO1xuICAgICAgICB0aGlzLm51bUNvbHMgPSBudW1Db2xzO1xuICAgICAgICAvLyB1c2UgbGVzcyBtZW1vcnkgaWYgcG9zc2libGVcbiAgICAgICAgdGhpcy50aWxlcyA9IG51bVJvd3MgKiBudW1Db2xzID4gMjU2ID8gVWludDE2QXJyYXkuZnJvbSh0aWxlcyk6IFVpbnQ4QXJyYXkuZnJvbSh0aWxlcyk7XG4gICAgICAgIHRoaXMuZW1wdHlQb3MgPSBlbXB0eVBvcztcbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBuZXcgaGV1cmlzdGljKG51bVJvd3MsIG51bUNvbHMpO1xuICAgICAgICBpZiAoc29sdmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNvbHZlciA9IG51bVJvd3MgKiBudW1Db2xzID4gOSA/ICdJREEqJyA6ICdBKic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvbHZlciA9IHNvbHZlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNvbHZlKG1heEl0ZXJhdGlvbnMgPSAxMDAwMDApIHtcbiAgICAgICAgaWYgKHRoaXMuc29sdmVyID09PSAnQSonKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb2x2ZUFTdGFyKG1heEl0ZXJhdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc29sdmVyID09PSAnSURBKicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvbHZlSURBU3RhcihtYXhJdGVyYXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNvbHZlQVN0YXIobWF4SXRlcmF0aW9ucykge1xuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciB1c2luZyBidWNrZXQgcXVldWUgaW5zdGVhZCBvZiBwcmlvcml0eSBxdWV1ZVxuICAgICAgICAvLyBlLmcuIGFycmF5IHdoZXJlIGtleSA9IHRvdGFsIGRpc3RhbmNlLCB2YWx1ZSA9IG5vZGUgd2l0aCB0aGF0IGRpc3RhbmNlXG4gICAgICAgIC8vIGFsc28gY29uc2lkZXIgbmVzdGVkIGJ1Y2tldCBxdWV1ZSB0byBhbGxvdyBvcmRlcmluZyBieSB0cmF2ZWxlZERpc3QgdG8gdGllLWJyZWFrXG4gICAgICAgIGxldCBxID0gbmV3IEZhc3RQcmlvcml0eVF1ZXVlKFxuICAgICAgICBcbiAgICAgICAgICAgIC8vIE5PVEU6IGNvbXBhcmF0b3IgcHV0cyBncmlkMSBmaXJzdCBpZiByZXR1cm4gXCJ0cnVlXCIgKGdyaWQxIGxlc3MgdGhhbiBncmlkMilcbiAgICAgICAgICAgIChncmlkMSwgZ3JpZDIpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWwxID0gZ3JpZDEuaGV1cmlzdGljVmFsdWUgKyBncmlkMS50cmF2ZWxlZERpc3QsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsMiA9IGdyaWQyLmhldXJpc3RpY1ZhbHVlICsgZ3JpZDIudHJhdmVsZWREaXN0O1xuXG4gICAgICAgICAgICAgICAgLy8gZmF2b3IgZ3JpZHMgd2l0aCBtb3JlIHRyYXZlbGVkIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgLy8gZXhwbGFuYXRpb246IHNpbmNlIGFkbWlzc2lzaWJsZSBoZXVyaXN0aWNzXG4gICAgICAgICAgICAgICAgLy8gdW5kZXJlc3RpbWF0ZSBvciBtYXRjaCBhY3R1YWwgZGlzdGFuY2UgdG8gZ29hbCxcbiAgICAgICAgICAgICAgICAvLyBhY3R1YWwgZGlzdGFuY2Ugb2YgZ3JpZCB3aXRoIG1vcmUgdHJhdmVsZWQgZGlzdGFuY2UgaXMgbGlrZWx5IHRvIGJlIDw9XG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsIGRpc3RhbmNlIG9mIGdyaWQgd2l0aCBsZXNzIHRyYXZlbGVkIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0b3RhbCBkaXN0YW5jZSBpcyBlcXVhbFxuICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbDEgPT09IHRvdGFsMiA/IFxuICAgICAgICAgICAgICAgICAgICBncmlkMS50cmF2ZWxlZERpc3QgPiBncmlkMi50cmF2ZWxlZERpc3QgOiBcbiAgICAgICAgICAgICAgICAgICAgdG90YWwxIDwgdG90YWwyO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGdyaWQgPSBuZXcgR3JpZCh0aGlzLm51bVJvd3MsIHRoaXMubnVtQ29scywgdGhpcy50aWxlcywgdGhpcy5lbXB0eVBvcywgdGhpcy5oZXVyaXN0aWMsIDApO1xuICAgICAgICBxLmFkZChncmlkKTtcblxuICAgICAgICBsZXQgY3VycjtcbiAgICAgICAgXG4gICAgICAgIC8vIG1hcHMgR3JpZCBzdGF0ZSB0byBiZXN0L3Nob3J0ZXN0IChoZXVyaXN0aWMgKyBkaXN0YW5jZSB0cmF2ZWxlZCkgZm91bmQgc28gZmFyXG4gICAgICAgIGxldCBiZXN0ID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHEuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRpb25zID4gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF4IG51bWJlciBvZiBpdGVyYXRpb25zIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnIgPSBxLnBvbGwoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnIuaXNTb2x2ZWQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZXJhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyLnJlY29uc3RydWN0UGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBtb3ZlIG9mIGN1cnIuZ2V0VmFsaWRNb3ZlcygpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJzaW5nIGEgbW92ZSB3aWxsIG5ldmVyIGxlYWQgdG8gYW4gb3B0aW1hbCBwYXRoXG4gICAgICAgICAgICAgICAgaWYgKG1vdmUgIT09IEdyaWQuZ2V0UmV2ZXJzZWRNb3ZlKGN1cnIubGFzdE1vdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdHcmlkID0gY3Vyci5jbG9uZUFuZEFwcGx5TW92ZShtb3ZlKTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgc2NvcmUgPSBuZXdHcmlkLnRyYXZlbGVkRGlzdCArIG5ld0dyaWQuaGV1cmlzdGljVmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IG5ld0dyaWQudGlsZXMudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gcXVldWUgYW5kIHJlcGxhY2UgYmVzdCBzY29yZSBpZiBzY29yZSBiZXR0ZXIgdGhhbiBwcmV2aW91cyBiZXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IG5vdCB1c2luZyA8LCBhcyBwcmV2aW91cyBiZXN0IGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlcyBpZiBiZXN0IGVpdGhlciB1bmRlZmluZWQgb3IgPj0gY3VycmVudCBzY29yZVxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBvYnZpYXRlcyBuZWVkIGZvciB2aXNpdGVkIHNldCwgYXMgb25seSBhZGRzIG5vZGUgd2hlblxuICAgICAgICAgICAgICAgICAgICAvLyBiZXR0ZXIgdGhhbiBiZXN0IGZvdW5kIHNvIGZhciB2cy4gYWRkaW5nIHdoZW4gYmV0dGVyIHRoYW4gYmVzdCBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyAoYnkgdGhlIHRpbWUgYmVzdCBwb3NzaWJsZSBpcyBmb3VuZCwgc2V2ZXJhbCBub2RlcyBjb3VsZCBiZSBkaXNjYXJkZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgYmVpbmcgd29yc2UgdGhhbiBwcmV2aW91cyBkaXNjb3ZlcmVkIG5vdC15ZXQtcG9wcGVkIG5vZGVzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShzY29yZSA+PSBiZXN0LmdldChrZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5zZXQoa2V5LCBzY29yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmFkZChuZXdHcmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBzb2x1dGlvbiBmb3VuZFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBtYWtlIHVzZSBvZiBtYXhJdGVyYXRpb25zIG9yIHNvbWUgb3RoZXIgbGltaXRpbmcgZnVuY3Rpb24gdG8gc3RvcCBmcmVlemluZyBicm93c2VyXG4gICAgc29sdmVJREFTdGFyKG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgbGV0IGdyaWQgPSBuZXcgR3JpZCh0aGlzLm51bVJvd3MsIHRoaXMubnVtQ29scywgdGhpcy50aWxlcywgdGhpcy5lbXB0eVBvcywgdGhpcy5oZXVyaXN0aWMsIDApO1xuXG4gICAgICAgIC8vIHVwcGVyIGJvdW5kIG9mIHRvdGFsIGRpc3RhbmNlIGZvciB3aGVuIHRvIHN0b3AgZXhwbG9yaW5nIG5vZGVzIGluIGdpdmVuIGl0ZXJhdGlvbiBvZiBkZnNcbiAgICAgICAgbGV0IGJvdW5kID0gZ3JpZC5oZXVyaXN0aWNWYWx1ZTtcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcblxuICAgICAgICB3aGlsZSAodHJ1ZSl7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5fc2VhcmNoSURBU3RhcihncmlkLCBwYXRoLCAwLCBib3VuZCk7XG4gICAgICAgICAgICBpZiAob3V0cHV0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dHB1dCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwcGVyIGJvdW5kIG9mIHNlYXJjaCB1cGRhdGVkIHRvIG1pbiB0b3RhbCBkaXN0YW5jZSBleHBsb3JlZCB0aGF0IHdhc1xuICAgICAgICAgICAgLy8gZ3JlYXRlciB0aGFuIHByZXZpb3VzIGJvdW5kXG4gICAgICAgICAgICBib3VuZCA9IG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfc2VhcmNoSURBU3RhcihncmlkLCBwYXRoLCB0cmF2ZWxlZERpc3QsIGJvdW5kKSB7XG5cbiAgICAgICAgbGV0IHRvdGFsRGlzdCA9IHRyYXZlbGVkRGlzdCArIGdyaWQuaGV1cmlzdGljVmFsdWU7XG5cbiAgICAgICAgaWYgKHRvdGFsRGlzdCA+IGJvdW5kKSByZXR1cm4gdG90YWxEaXN0O1xuICAgICAgICBpZiAoZ3JpZC5pc1NvbHZlZCgpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyB0cmFja3MgbWluIHRvdGFsIGRpc3RhbmNlIG9mIGFsbCBub2RlcyBleHBsb3JlZFxuICAgICAgICBsZXQgbWluVG90YWxEaXN0ID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IG1vdmUgb2YgZ3JpZC5nZXRWYWxpZE1vdmVzKCkpIHtcbiAgICAgICAgICAgIC8vIHJldmVyc2luZyBwcmV2aW91cyBtb3ZlIG5ldmVyIGxlYWRzIHRvIG9wdGltYWwgc29sdXRpb25cbiAgICAgICAgICAgIGlmIChtb3ZlICE9PSBHcmlkLmdldFJldmVyc2VkTW92ZShwYXRoW3BhdGgubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vdmVSZWNvcmQgPSBncmlkLmFwcGx5TW92ZShtb3ZlKTtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobW92ZSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5fc2VhcmNoSURBU3RhcihncmlkLCBwYXRoLCB0cmF2ZWxlZERpc3QgKyAxLCBib3VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCA9PT0gdHJ1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCA8IG1pblRvdGFsRGlzdCkgbWluVG90YWxEaXN0ID0gb3V0cHV0O1xuXG4gICAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBncmlkLnJldmVyc2VNb3ZlKG1vdmVSZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW5Ub3RhbERpc3Q7XG4gICAgfSBcblxufVxuXG4vLyBUT0RPOiBjb25zaWRlciBtb3ZpbmcgdmFsaWRNb3ZlcyB0byBmaWVsZCBvZiBDbGFzcyBpbnN0ZWFkIG9mIGluc3RhbmNlXG4vLyAoaW5kZXhlZCB1bmRlciBncmlkIGRpbWVuc2lvbnMpXG5cbi8vIFRPRE86IGNvbnNpZGVyIGhhdmluZyBib3RoIHRoaXMgYW5kIGdyYXBoaWNhbCBncmlkIGV4dGVuZCBmcm9tIHNhbWUgYmFzZSBjbGFzcyB0byByZXVzZSBtb3ZlIGZ1bmN0aW9uc1xuY2xhc3MgR3JpZCB7XG5cbiAgICBjb25zdHJ1Y3RvcihudW1Sb3dzLCBudW1Db2xzLCB0aWxlcywgZW1wdHlQb3MsIGhldXJpc3RpYywgdHJhdmVsZWREaXN0LCBoZXVyaXN0aWNWYWx1ZSA9IG51bGwsIFxuICAgICAgICBsYXN0TW92ZSA9IG51bGwsIGxhc3RHcmlkID0gbnVsbCwgdmFsaWRNb3ZlcyA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gbnVtUm93cztcbiAgICAgICAgdGhpcy5udW1Db2xzID0gbnVtQ29scztcbiAgICAgICAgdGhpcy50aWxlcyA9IHRpbGVzO1xuICAgICAgICB0aGlzLmVtcHR5UG9zID0gZW1wdHlQb3M7XG5cbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBoZXVyaXN0aWM7XG4gICAgICAgIHRoaXMudHJhdmVsZWREaXN0ID0gdHJhdmVsZWREaXN0O1xuICAgICAgICB0aGlzLmhldXJpc3RpY1ZhbHVlID0gaGV1cmlzdGljVmFsdWUgPT09IG51bGwgPyBoZXVyaXN0aWMuY2FsY3VsYXRlKHRoaXMpIDogaGV1cmlzdGljVmFsdWU7XG5cbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IGxhc3RNb3ZlO1xuICAgICAgICB0aGlzLmxhc3RHcmlkID0gbGFzdEdyaWQ7XG5cbiAgICAgICAgLy8gVE9ETzogYXR0YWNoIHRvIGV4dGVybmFsIG9iaiBvciBwYXNzIGJldHdlZW4gZ3JpZHMgdG8gYXZvaWQgcmVjb21wdXRpbmcgZXZlcnkgbmV3IGdyaWRcbiAgICAgICAgLy8gcHJlY29tcHV0aW5nIHZhbHVlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICAgIC8vIElERUE6IGRvIGFsbCBwcmVjb21wdXRpbmcgaW5zaWRlIFB1enpsZSgpIHRvIGJlIHJlZmVyZW5jZWQgYnkgR3JpZFxuICAgICAgICAvLyAocGFzc2luZyBhbG9uZyB0YWtlcyB1cCBtZW1vcnkpXG4gICAgICAgIHRoaXMudmFsaWRNb3ZlcyA9IHZhbGlkTW92ZXMgPT09IG51bGwgPyB0aGlzLl9wcmVjb21wdXRlVmFsaWRNb3ZlcygpIDogdmFsaWRNb3ZlcztcbiAgICB9XG5cbiAgICBnZXRUaWxlQ29sKGluZCkge1xuICAgICAgICByZXR1cm4gaW5kICUgdGhpcy5udW1Db2xzO1xuICAgIH1cblxuICAgIGdldFRpbGVSb3coaW5kKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGluZCAvIHRoaXMubnVtQ29scyk7XG4gICAgfVxuXG4gICAgZ2V0SW5kZXgocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHJvdyAqIHRoaXMubnVtQ29scyArIGNvbDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGNoYW5nZSBpbiBpbmRleCBvZiB0aWxlIHRvIGJlIG1vdmVkIGFmdGVyIG1vdmVcbiAgICBnZXRNb3ZlRGVsdGEobW92ZSkge1xuICAgICAgICBsZXQgbW92ZURlbHRhTWFwID0ge1xuICAgICAgICAgICAgJ3InOiAxLFxuICAgICAgICAgICAgJ2wnOiAtMSxcbiAgICAgICAgICAgICd1JzogLXRoaXMubnVtQ29scyxcbiAgICAgICAgICAgICdkJzogdGhpcy5udW1Db2xzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVEZWx0YU1hcFttb3ZlXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb25zaWRlciBpbnN0ZWFkIGNhY2hpbmcgbW92ZWRJbmQgZm9yIGV2ZXJ5IG1vdmUgKyBlbXB0eVBvcyBjb21ibyBPKG4pXG4gICAgLy8gcmV0dXJucyBpbmRleCBvZiB0aWxlIHRoYXQgd291bGQgYmUgbW92ZWQgYnkgc3BlY2lmaWVkIG1vdmVcbiAgICBnZXRNb3ZlZEluZChtb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtcHR5UG9zIC0gdGhpcy5nZXRNb3ZlRGVsdGEobW92ZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFJldmVyc2VkTW92ZShtb3ZlKSB7XG4gICAgICAgIHJldHVybiBSRVZFUlNFX01PVkVfTUFQW21vdmVdO1xuICAgIH1cblxuICAgIGdldFRpbGVEaXN0KHRpbGUxLCB0aWxlMikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5nZXRUaWxlUm93KHRpbGUxKSAtIHRoaXMuZ2V0VGlsZVJvdyh0aWxlMikpICtcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZ2V0VGlsZUNvbCh0aWxlMSkgLSB0aGlzLmdldFRpbGVDb2wodGlsZTIpKTtcbiAgICB9XG5cbiAgICByZWNvbnN0cnVjdFBhdGgoKSB7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGxldCBjdXJyID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGN1cnIubGFzdE1vdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChjdXJyLmxhc3RNb3ZlKTtcbiAgICAgICAgICAgIGN1cnIgPSBjdXJyLmxhc3RHcmlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgZGVlcCBjb3B5IG9mIGdyaWQgaWdub3JpbmcgbGFzdEdyaWQgKG51bGwpXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR3JpZCh0aGlzLm51bVJvd3MsIHRoaXMubnVtQ29scywgdGhpcy50aWxlcy5zbGljZSgpLCB0aGlzLmVtcHR5UG9zLCB0aGlzLmhldXJpc3RpYyxcbiAgICAgICAgICAgIHRoaXMudHJhdmVsZWREaXN0LCB0aGlzLmhldXJpc3RpY1ZhbHVlLCB0aGlzLmxhc3RNb3ZlLCBudWxsLCB0aGlzLnZhbGlkTW92ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgY29weSBvZiBjdXJyZW50IGdyaWQgd2l0aCBzcGVjaWZpZWQgZGlyZWN0aW9uYWwgbW92ZSBhcHBsaWVkIHRvIHRpbGUgbW92aW5nIGludG8gZW1wdHkgcG9zaXRpb25cbiAgICAgKiBhbHNvIHVwZGF0ZXMgYWxsIGFmZmVjdGVkIEdyaWQgZmllbGRzIGluIG5ldyBHcmlkIChlbXB0eVBvcywgaGV1cmlzdGljL3RyYXZlbCBkaXN0YW5jZSwgZXRjLilcbiAgICAgKiBAcGFyYW0gbW92ZSBkaXJlY3Rpb24gdG8gbW92ZSB0aWxlIGludG8gZW1wdHkgc3BhY2VcbiAgICAgKiBAcmV0dXJuIHJldHVybnMgY29weSBvZiBjdXJyZW50IGdyaWQgd2l0aCBzcGVjaWZpZWQgbW92ZSBhcHBsaWVkIHRvIHRpbGUgaW50byBlbXB0eSBwb3NpdGlvblxuICAgICAqL1xuICAgIGNsb25lQW5kQXBwbHlNb3ZlKG1vdmUpIHtcbiAgICAgICAgbGV0IG5ld0dyaWQgPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgbmV3R3JpZC5sYXN0R3JpZCA9IHRoaXM7XG4gICAgICAgIG5ld0dyaWQubGFzdE1vdmUgPSBtb3ZlO1xuXG4gICAgICAgIHJldHVybiBHcmlkLl9hcHBseU1vdmVIZWxwZXIobW92ZSwgbmV3R3JpZCk7XG4gICAgfVxuXG4gICAgLy8gQXBwbGllcyBtb3ZlIHRvIGdyaWQgTk9UIGNsb25lIG9uIGdyaWRcbiAgICAvLyBSZXR1cm5zIG1vdmVSZWNvcmQgb2JqZWN0IHN0b3Jpbmcgb2xkIGhldXJpc3RpY1ZhbHVlIGFuZCBlbXB0eVBvcyAoZm9yIHVzZSBpbiByZXZlcnNlTW92ZSgpKVxuICAgIC8vICh1c2VmdWwgZm9yIElEQSogYXMgbWVtb3J5IGFsbG9jYXRpb24gY2FuIGJlIGF2b2lkZWQpXG4gICAgLy8gTk9URTogc2VwYXJhdGUgZnVuY3Rpb24gaW5zdGVhZCBvZiBjb25zb2xpZGF0aW9uIHdpdGggXCJjbG9uZVwiIHBhcmFtIGZvciBzbGlnaHRseSBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAvLyBOT1RFOiBkb2VzIE5PVCB1cGRhdGUgbGFzdE1vdmUgb3IgbGFzdEdyaWRcbiAgICBhcHBseU1vdmUobW92ZSkge1xuICAgICAgICBsZXQgb2xkSGV1cmlzdGljVmFsdWUgPSB0aGlzLmhldXJpc3RpY1ZhbHVlO1xuICAgICAgICBsZXQgb2xkRW1wdHlQb3MgPSB0aGlzLmVtcHR5UG9zO1xuXG4gICAgICAgIEdyaWQuX2FwcGx5TW92ZUhlbHBlcihtb3ZlLCB0aGlzKTtcblxuICAgICAgICAvLyBUT0RPOyBjb25zaWRlciBjaGFuZ2luZyB0byB0eXBlZEFycmF5IGZvciBzbGlnaHRseSBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgICAgcmV0dXJuIHtoZXVyaXN0aWNWYWx1ZTogb2xkSGV1cmlzdGljVmFsdWUsIGVtcHR5UG9zOiBvbGRFbXB0eVBvc307XG4gICAgfVxuXG4gICAgcmV2ZXJzZU1vdmUobW92ZVJlY29yZCkge1xuICAgICAgICB0aGlzLnRyYXZlbGVkRGlzdC0tO1xuXG4gICAgICAgIHRoaXMuaGV1cmlzdGljVmFsdWUgPSBtb3ZlUmVjb3JkLmhldXJpc3RpY1ZhbHVlO1xuXG4gICAgICAgIHRoaXMuc3dhcCh0aGlzLmVtcHR5UG9zLCBtb3ZlUmVjb3JkLmVtcHR5UG9zKTtcbiAgICAgICAgdGhpcy5lbXB0eVBvcyA9IG1vdmVSZWNvcmQuZW1wdHlQb3M7XG4gICAgfVxuXG4gICAgLy8gYXBwbGllcyBtb3ZlIHRvIHNwZWNpZmllZCBncmlkIFdJVEhPVVQgdXBkYXRpbmcgbGFzdE1vdmUgb3IgbGFzdEdyaWRcbiAgICBzdGF0aWMgX2FwcGx5TW92ZUhlbHBlcihtb3ZlLCBncmlkKSB7XG4gICAgICAgIGxldCBtb3ZlZEluZCA9IGdyaWQuZ2V0TW92ZWRJbmQobW92ZSk7XG4gICAgICAgIGxldCBlbmRJbmQgPSBncmlkLmVtcHR5UG9zO1xuXG4gICAgICAgIGdyaWQuc3dhcChlbmRJbmQsIG1vdmVkSW5kKTtcbiAgICAgICAgZ3JpZC5lbXB0eVBvcyA9IG1vdmVkSW5kO1xuXG4gICAgICAgIGdyaWQudHJhdmVsZWREaXN0Kys7XG5cbiAgICAgICAgZ3JpZC5oZXVyaXN0aWNWYWx1ZSA9IGdyaWQuaGV1cmlzdGljLnVwZGF0ZShncmlkLCBtb3ZlZEluZCwgZW5kSW5kLCBtb3ZlKTtcbiAgICAgICAgcmV0dXJuIGdyaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV0FSTklORzogRG9lcyBOT1QgdXBkYXRlIGhldXJpc3RpY1ZhbHVlLCBsYXN0TW92ZSwgZW1wdHlQb3MsIG9yIGxhc3RHcmlkXG4gICAgICogc3dhcHMgMiBwb3NpdGlvbnMgaW4gZ3JpZC5cbiAgICAgKi9cbiAgICBzd2FwKHBvczEsIHBvczIpIHtcbiAgICAgICAgW3RoaXMudGlsZXNbcG9zMV0sIHRoaXMudGlsZXNbcG9zMl1dID0gW3RoaXMudGlsZXNbcG9zMl0sIHRoaXMudGlsZXNbcG9zMV1dO1xuICAgIH1cblxuICAgIC8vIHByZWNvbXB1dGVzIHZhbGlkIG1vdmVzIGZvciBlYWNoIHBvc3NpYmxlIGVtcHR5UG9zIHRvIGdpdmUgc2xpZ2h0IHBlcmZvcm1hbmNlIGJlbmVmaXRcbiAgICBfcHJlY29tcHV0ZVZhbGlkTW92ZXMoKSB7XG4gICAgICAgIGxldCBtb3ZlcztcbiAgICAgICAgbGV0IHZhbGlkTW92ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZW1wdHlQb3MgPSAwOyBlbXB0eVBvcyA8IHRoaXMudGlsZXMubGVuZ3RoOyBlbXB0eVBvcysrKSB7XG4gICAgICAgICAgICBtb3ZlcyA9IFtdO1xuXG4gICAgICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRUaWxlUm93KGVtcHR5UG9zKTtcbiAgICAgICAgICAgIGxldCBjb2wgPSB0aGlzLmdldFRpbGVDb2woZW1wdHlQb3MpO1xuXG4gICAgICAgICAgICBpZiAocm93IDwgdGhpcy5udW1Sb3dzIC0gMSkge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2goJ3UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgbW92ZXMucHVzaCgnZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbCA8IHRoaXMubnVtQ29scyAtIDEpIHtcbiAgICAgICAgICAgICAgICBtb3Zlcy5wdXNoKCdsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sID4gMCkge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2goJ3InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsaWRNb3Zlc1tlbXB0eVBvc10gPSBtb3ZlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRNb3ZlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGFycmF5IG9mIHZhbGlkIG1vdmVzLCB3aGVyZSAnbCcgPSBsZWZ0LCAncicgPSByaWdodCwgJ2QnID0gZG93biwgYW5kICd1JyA9IHVwLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2YgdmFsaWQgbW92ZXMsIHdoZXJlIG1vdmVzIGFyZSBkZWZpbmVkIGJ5IHRpbGVzIG1vdmluZyBpbnRvIHRoZSBlbXB0eSBzcGFjZSBpbiB0aGUgZ3JpZFxuICAgICAqL1xuICAgIGdldFZhbGlkTW92ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkTW92ZXNbdGhpcy5lbXB0eVBvc107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGdyaWQgaXMgc29sdmVkIGFzc3VtaW5nIGdvYWwgaXMgWzAsIDEsIC4uLiB0aWxlcy5sZW5ndGggLSAxXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHB1enpsZSBpcyBzb2x2ZWRcbiAgICAgKi9cbiAgICBpc1NvbHZlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGV1cmlzdGljLmlzU29sdmVkKHRoaXMuaGV1cmlzdGljVmFsdWUpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBhY2NvdW50cyBmb3IgaWYgY2FuJ3QgZGV0ZXJtaW5lIGlmIHB1enpsZSBzb2x2ZWQgdXNpbmcgaGV1cmlzdGljIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVzLmV2ZXJ5KChnb2FsSW5kLCBpbmQpID0+IGdvYWxJbmQgPT09IGluZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0TGluZWFyQ29uZmxpY3RIZXVyaXN0aWMoKSB7XG4gICAgY29uc3QgdGVzdENhc2VzID0gW1xuICAgICAgICBbWzAsMiwxLDcsNCw1LDYsMyw4XSwgMF0sXG4gICAgICAgIFtbMCwyLDEsNSw0LDMsNiw3LDhdLCAwXSxcbiAgICAgICAgW1s0LDMsNiw4LDAsNyw1LDIsMV0sIDRdLFxuICAgICAgICBbWzIsNywwLDUsNCwzLDgsMSw2XSwgMl1dO1xuXG4gICAgY29uc3QgYW5zID0gWzgsIDEyLCAyMiwgMjRdO1xuXG4gICAgZm9yIChsZXQgW2luZCwgdGVzdENhc2VdIG9mIHRlc3RDYXNlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgbGV0IHRlc3RHcmlkID0gbmV3IEdyaWQoMywgMywgLi4udGVzdENhc2UsIG5ldyBMaW5lYXJDb25mbGljdEhldXJpc3RpYygzLCAzKSwgMCk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRlc3RHcmlkLmhldXJpc3RpY1ZhbHVlID09PSBhbnNbaW5kXSwgXG4gICAgICAgICAgICBgaW5jb3JyZWN0IGFuc3dlcjogYW5zd2VyID0gJHt0ZXN0R3JpZC5oZXVyaXN0aWNWYWx1ZX0sIGNvcnJlY3QgYW5zd2VyID0gJHthbnNbaW5kXX1gKTtcbiAgICB9XG59XG5cbi8vIFRPRE86IHJlbW92ZSBhZnRlciBkb25lIHRlc3Rpbmdcbi8vIHRlc3RMaW5lYXJDb25mbGljdEhldXJpc3RpYygpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFB1enpsZTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/sliding-puzzle-algorithms.js\n");

/***/ })

/******/ });
//# sourceMappingURL=main.bundle.js.map